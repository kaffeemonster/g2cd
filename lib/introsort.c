/*
 * this is all quite PD, nothing magic:
 * search introsort
 * search quicksort
 * search heapsort
 * search insertsort
 * glue it all together
 *
 * Thanks go to Ralph Unden for a paper about intro sort with
 * concrete java demonstration code, i'm better at comprehending
 * code than dry formal talk "given an set epsilon...".
 *
 * rewritten for uint32_t and C by me, so all errors are
 * mine - Jan
 */

#include "../config.h"
#include "other.h"
#include "my_bitops.h"

/*
 * introsort_u32 - sort an array of u32 with intro sort
 *
 * This sort tries to eliminate duplicates, it does not remove
 * every possible dublicate, but some.
 *
 * a[]: array of u32 to sort
 * n: number of u32 in a
 *
 * return value: number of "valid" output elements
 *
 * Intro sort is a variant of quick sort, which tries to fall back
 * to another sorting algorithm, when we are heading for the worst
 * case for quick sort (O(n^2)).
 * Rest is quite of the mill, except for the duplication removal.
 *
 * AGAIN: we remove duplicates, this is a deviation not reflected
 *        in the name and has to be changed when used as a normal
 *        generic sorting alg.
 */

/*
 * ~~~   Motivation   ~~~
 *
 * The reason we have this code is 3 fold:
 * - mainly to remove the overhead of a generic lib sort. We really
 *   want to do simple number sorting, like textbook code does, so
 *   away with elemsize and compare callbacks, nice clean aligned
 *   access for the RISC archs.
 * - not all libc qsort() are born equal, they sometimes miss the tuning
 *   and only some systems use introsort as qsort
 *   -> since this is in the scope of G2CD, we have to look at what
 *      we are sorting: hashes, generated by foreign input.
 *      On normal operation they are totaly random distributed, (so
 *      algs which try to find preruns or such stuff don't pay off,
 *      and we don't care for stable) but an attacker may craft an
 *      request to generate hashes in the worst-case order: We
 *      really really want introsort to get the best of both worlds.
 *      (sure, hitting the heapesort fallback hurts, but...).
 * - we expect low to modest n (search requests generating 1000'th
 *   of hashes are also large as packets (untransportable) and prop.
 *   malicious...), with a overhelming number in the low 1 to 20
 *   hashes. Sorting such a low number even n^2 is cheaper than
 *   hitting the unsorted case in the QHT lookups.
 *
 * Additionaly we try to remove duplicates, since we are traversing the
 * array and doing lots of compares anyway. This is not 100%, but at
 * least should find some to reduce the number of elements in the output
 * (and lookups in the QHTs).
 */

/*
 * Be carefull when changing this value.
 * Due to quicksorts D&C aprouch, there is a "2 for the price of 1"
 * hidden here: When partioning went ideal, we half the array every
 * time, so those last SIZE_THRESHOLD "unsorted" values lay next to
 * another partition of SIZE_THRESHOLD "unsorted" values.
 * (This is _very_ rough, quicksort did it's thing on the way down
 * so they are not totaly unsorted, but the last steps before ending
 * the quicksort recursion on SIZE_THRESHOLD saw fewer pivoting).
 * This means more work for insertion sort, which is good for nearly
 * sorted arrays (why we use it as final sort), but quickly collapses
 * when presented with to much disorder.
 *
 * If you now scratch your head what i mean or want to send me flaming
 * emails about me talking nonsense:
 * This is some "how-do-i-put-it-into-words" talk after looking at lots
 * of traces. So take it "as is".
 */
#define SIZE_THRESHOLD 5

/*
 * Common helper
 */
static inline void exchange_u32(uint32_t *a, uint32_t *b)
{
	uint32_t t = *a;
	*a = *b;
	*b = t;
}

/*
 * heap sort as worst case fallback
 */
// TODO: this could be rewritten? (Floyd??)
/*
 * this way we get fewer compares, but "walk" the array 3 times...
 * so the question is how this hits the caches, esp. since
 * this should only be the fallback on deep recursion, so small
 * array partitions
 */
static void downheap_u32(uint32_t a[], size_t i, size_t n)
{
	uint32_t d = a[i - 1];
	size_t child;

	while((child = i * 2) <= n)
	{
		if(child < n && a[child - 1] < a[child])
			child++;
		if(!(d < a[child - 1]))
			break;
		a[i - 1] = a[child - 1];
		i = child;
	}
	a[i - 1] = d;
}

static void heapsort_u32(uint32_t a[], size_t n)
{
	size_t i;
	for(i = n / 2; i >= 1; i--)
		downheap_u32(a, i, n);
	for(i = n; i > 1; i--) {
		exchange_u32(a, a + i - 1);
		downheap_u32(a, 1, i - 1);
	}
}

/*
 * insertion sort which tries to removes duplicates.
 * The final sorting alg. to smooth out the roughly presorted
 * array. Suggested by Sedgewick
 */
static size_t insertionsort_u32_c(uint32_t a[], size_t n)
{
	size_t i, j, k;
	uint32_t t;

	/* n can not be 0 here */
	i = 0; k = 0;
	goto start_loop;
	do
	{
		/*
		 * Since i don't see any super intelligent way to remove
		 * all duplicates, this simple check should remove most,
		 * since our input array is rougly presorted.
		 */
		if(a[i] == a[k - 1] ||
		   a[i] == t)
			continue;
start_loop:
		j = k;
		t = a[i];
		while(j && t < a[j - 1]) {
			a[j] = a[j - 1];
			j--;
		}
		a[j] = t;
		k++;
	} while(++i < n);
	return k;
}

/*
 * intro sort
 */
static uint32_t medianof3_u32(uint32_t a[], size_t n)
{
	uint32_t lo = *a, mid = a[n / 2 + 1], hi = a[n - 1];
	return mid < lo ? (hi < mid ? mid : (hi < lo ? hi : lo)) :
	                  (hi < mid ? (hi < lo ? lo : hi) : mid);
}

static size_t partition_u32(uint32_t a[], size_t j, uint32_t x)
{
	size_t i = 0;
	while(1)
	{
		while(a[i] < x)
			i++;
		j--;
		while(x < a[j])
			j--;
		if(!(i < j))
			return i;
		exchange_u32(a + i, a + j);
		i++;
	}
}

static void introsort_loop_u32(uint32_t a[], size_t n, unsigned depth_limit)
{
	size_t p, n_s, n_b;
	uint32_t *a_s, *a_b;

	/*
	 * only pre sort, where quick sort is most effective,
	 * final run will be something else
	 */
	if(n <= SIZE_THRESHOLD)
		return;

	/* throttle it? */
	if(unlikely(!depth_limit))
	{
		/*
		 * we left the "optimal" recursion depth, so we are prop. heading
		 * for the worst case, quickly switch to some other sorting
		 * alg. for this partition
		 */
		heapsort_u32(a, n);
		return;
	}

	p = partition_u32(a, n, medianof3_u32(a, n));
	/*
	 * recurse into the smaller partition first (costs _real_
	 * stack), 'cause it should be easier to sort, while the
	 * bigger partition uses the tail recursion eliminated path.
	 * Suggested by Sedgewick
	 */
	if(n - p < p) {
		a_s = a + p; n_s = n - p;
		a_b = a;     n_b = p;
	} else {
		a_s = a;     n_s = p;
		a_b = a + p; n_b = n - p;
	}
	prefetch(a_s);
	introsort_loop_u32(a_s, n_s, depth_limit - 1);
	/*
	 * we could write a loop, but keep tail recursion for simplycity
	 * the compiler should be able to eliminate it
	 * this way we also do keep track of the depth limit
	 */
	prefetch(a_b);
	introsort_loop_u32(a_b, n_b, depth_limit - 1);
}

size_t introsort_u32(uint32_t a[], size_t n)
{
	prefetch(a);
	if(n < 2)
		return n;
	introsort_loop_u32(a, n, flsst(n) - 1 /* floor(ld(n)) */);
	return insertionsort_u32_c(a, n);
}

/*@unused@*/
static char const rcsid_is[] GCC_ATTR_USED_VAR = "$Id: $";
/* EOF */
