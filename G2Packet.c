/*
 * G2Packet.c
 * helper-functions for G2-packets
 *
 * Copyright (c) 2004 - 2011 Jan Seiffert
 *
 * This file is part of g2cd.
 *
 * g2cd is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 3
 * of the License, or (at your option) any later version.
 *
 * g2cd is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public
 * License along with g2cd.
 * If not, see <http://www.gnu.org/licenses/>.
 *
 * $Id: G2Packet.c,v 1.12 2004/12/18 18:06:13 redbully Exp redbully $
 */

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
/* System includes */
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <stdbool.h>
#include <time.h>
#if defined(HAVE_DLOPEN) && !defined(WIN32)
# include <dlfcn.h>
#endif
/* other */
#include "lib/other.h"
/* own includes */
#define _G2PACKET_C
#define _NEED_G2_P_TYPE
#define G2PACKET_POWER_MONGER
#include "G2Packet.h"
#include "G2PacketSerializer.h"
#include "G2QHT.h"
#include "G2KHL.h"
#include "G2GUIDCache.h"
#include "G2UDP.h"
#include "G2MainServer.h"
#include "G2ConRegistry.h"
#include "G2QueryKey.h"
#include "G2Handler.h"
#include "lib/sec_buffer.h"
#include "lib/log_facility.h"
#include "lib/my_bitops.h"
#include "lib/guid.h"

/* minutes to seconds */
#define Q2_T_TIMEOUT   (    1)
#define Q2_U_TIMEOUT   (    5)
#define PI_TIMEOUT     (   30)
#define LNI_TIMEOUT    ( 1*60)
#define QHT_TIMEOUT    ( 1*60)
#define KHL_TIMEOUT    ( 2*60)
#define CRAWLR_TIMEOUT ( 3*60)
#define UPROC_TIMEOUT  (15*60)
#define G2CDC_TIMEOUT  (30*60)

/*
 * Autogenerated packet typer table
 * include NO where else!!
 */
#include "G2PacketTyper.h"

/*
 * Internal Prototypes
 */
static bool g2_packet_steal_data_space(g2_packet_t *, size_t);
static bool g2_packet_steal_data_space_lit(g2_packet_t *, size_t);
static bool g2_packet_decide_spec_int(struct ptype_action_args *, g2_ptype_action_func const *);
/* packet handler */
static bool empty_action_p(struct ptype_action_args *);
static bool unimpl_action_p(struct ptype_action_args *);
static bool handle_KHLR(struct ptype_action_args *);
static bool handle_KHLR_UKHLID(struct ptype_action_args *);
static bool handle_KHLR_QK(struct ptype_action_args *);
static bool handle_KHL(struct ptype_action_args *);
static bool handle_KHL_TS(struct ptype_action_args *);
static bool handle_KHL_NH(struct ptype_action_args *);
static bool handle_KHL_NH_GU(struct ptype_action_args *);
static bool handle_KHL_CH(struct ptype_action_args *);
static bool handle_KHL_CH_GU(struct ptype_action_args *);
static bool handle_LNI(struct ptype_action_args *);
static bool handle_LNI_FW(struct ptype_action_args *);
static bool handle_LNI_HS(struct ptype_action_args *);
static bool handle_LNI_NA(struct ptype_action_args *);
static bool handle_LNI_RTR(struct ptype_action_args *);
static bool handle_LNI_GU(struct ptype_action_args *);
static bool handle_LNI_QK(struct ptype_action_args *);
static bool handle_LNI_HA(struct ptype_action_args *);
static bool handle_LNI_V(struct ptype_action_args *);
static bool handle_PI(struct ptype_action_args *);
static bool handle_PI_UDP(struct ptype_action_args *);
static bool handle_PI_RELAY(struct ptype_action_args *);
static bool handle_PO(struct ptype_action_args *);
static bool handle_Q2(struct ptype_action_args *);
static bool handle_Q2_UDP(struct ptype_action_args *);
static bool handle_Q2_QKY(struct ptype_action_args *);
static bool handle_Q2_URN(struct ptype_action_args *);
static bool handle_Q2_DN(struct ptype_action_args *);
static bool handle_Q2_MD(struct ptype_action_args *);
static bool handle_Q2_HURN(struct ptype_action_args *);
static bool handle_Q2_HKEY(struct ptype_action_args *);
static bool handle_QA(struct ptype_action_args *);
static bool handle_QA_FR(struct ptype_action_args *parg);
static bool handle_QA_TS(struct ptype_action_args *);
static bool handle_QA_D(struct ptype_action_args *);
static bool handle_QA_S(struct ptype_action_args *);
static bool handle_QH2(struct ptype_action_args *);
static bool handle_QH2_GU(struct ptype_action_args *);
static bool handle_QH2_NA(struct ptype_action_args *);
static bool handle_QH1(struct ptype_action_args *);
static bool handle_QHT(struct ptype_action_args *);
static bool handle_QKR(struct ptype_action_args *);
static bool handle_QKR_RNA(struct ptype_action_args *parg);
static bool handle_QKR_QNA(struct ptype_action_args *parg);
static bool handle_QKR_SNA(struct ptype_action_args *parg);
static bool handle_QKR_REF(struct ptype_action_args *parg);
static bool handle_QKA(struct ptype_action_args *);
static bool handle_QKA_QK(struct ptype_action_args *);
static bool handle_QKA_SNA(struct ptype_action_args *);
static bool handle_QKA_QNA(struct ptype_action_args *);
static bool handle_QKA_CACHED(struct ptype_action_args *);
static bool handle_HAW(struct ptype_action_args *);
static bool handle_HAW_NA(struct ptype_action_args *);
static bool handle_UPROC(struct ptype_action_args *);
static bool handle_UPROD(struct ptype_action_args *);
static bool handle_CRAWLR(struct ptype_action_args *);
static bool handle_CRAWLR_REXT(struct ptype_action_args *);
static bool handle_CRAWLR_RGPS(struct ptype_action_args *);
static bool handle_CRAWLR_RNAME(struct ptype_action_args *);
static bool handle_CRAWLR_RLEAF(struct ptype_action_args *);
static bool handle_G2CDC(struct ptype_action_args *);

/*
 * Packet dicts
 */
/* main dict */
const g2_ptype_action_func g2_packet_dict[PT_MAXIMUM] GCC_ATTR_VIS("hidden") =
{
	[PT_G2CDc ] = handle_G2CDC,
	[PT_KHL   ] = handle_KHL,
	[PT_LNI   ] = handle_LNI,
	[PT_HAW   ] = handle_HAW,
	[PT_PI    ] = handle_PI,
	[PT_PO    ] = handle_PO,
	[PT_PUSH  ] = empty_action_p, /* we do not push */
	[PT_Q2    ] = handle_Q2,
	[PT_QA    ] = handle_QA,
	[PT_QH2   ] = handle_QH2,
	[PT_QHT   ] = handle_QHT,
	[PT_QKR   ] = handle_QKR,
	[PT_QKA   ] = handle_QKA,
	[PT_UPROC ] = handle_UPROC,
	[PT_UPROD ] = handle_UPROD,
	[PT_dna   ] = empty_action_p, /* marker the packet came from a GnucDNA client */
	[PT_QH1   ] = handle_QH1,
	[PT_CLOSE ] = empty_action_p, /* do we want to also close or what? */
};

const g2_ptype_action_func g2_packet_dict_udp[PT_MAXIMUM] GCC_ATTR_VIS("hidden") =
{
	[PT_CRAWLA] = empty_action_p, /* we don't request crawls */
	[PT_CRAWLR] = handle_CRAWLR,
	[PT_KHL   ] = empty_action_p, /* we don't request khls by udp */
	[PT_KHLA  ] = empty_action_p, /* we don't request khls by udp */
	[PT_KHLR  ] = handle_KHLR,
	[PT_DIS   ] = handle_KHLR,
	[PT_PI    ] = handle_PI,
	[PT_PO    ] = empty_action_p, /* yeah, so what */
	[PT_JCT   ] = empty_action_p, /* no answer needed, it's ACKed */
	[PT_Q2    ] = handle_Q2,
	[PT_QA    ] = handle_QA,
	[PT_QH2   ] = handle_QH2,
	[PT_QKR   ] = handle_QKR,
	[PT_QKA   ] = handle_QKA,
	[PT_PUSH  ] = empty_action_p, /* we do not push */
	[PT_QH1   ] = handle_QH1,
	[PT_dna   ] = empty_action_p, /* see tcp */
};

/* PI-childs */
static const g2_ptype_action_func PI_packet_dict[PT_MAXIMUM] =
{
	[PT_TO    ] = empty_action_p,
	[PT_UDP   ] = handle_PI_UDP,
	[PT_RELAY ] = handle_PI_RELAY,
	[PT_CR    ] = empty_action_p, /* we connect to no one */
	[PT_TFW   ] = empty_action_p, /* test firewall, ??? */
	[PT_IDENT ] = empty_action_p, /* no, i don't give my ident */
};

/* LNI-childs */
static const g2_ptype_action_func LNI_packet_dict[PT_MAXIMUM] =
{
	[PT_TO    ] = empty_action_p,
	[PT_FW    ] = handle_LNI_FW,
	[PT_GU    ] = handle_LNI_GU,
	[PT_HS    ] = handle_LNI_HS,
	[PT_LS    ] = empty_action_p,
	[PT_RTR   ] = handle_LNI_RTR,
	[PT_NA    ] = handle_LNI_NA,
	[PT_QK    ] = handle_LNI_QK,
	[PT_UP    ] = empty_action_p, /* uptime */
	[PT_HA    ] = handle_LNI_HA,
	[PT_V     ] = handle_LNI_V,
	[PT_IDENT ] = empty_action_p,
	[PT_NBW   ] = empty_action_p, /* bandwidth */
	[PT_CM    ] = empty_action_p, /* cpu & mem */
	[PT_GPS   ] = empty_action_p, /* coords */
	[PT_NFW   ] = empty_action_p, /* ?? */
	[PT_TCPNFW] = empty_action_p, /* ?? */
	[PT_UDPNFW] = empty_action_p, /* ?? */
	[PT_UDPFW ] = empty_action_p, /* ?? */
	[PT_g2core] = empty_action_p, /* this is a quazaa client */
};

/* KHLR-childs */
/*
 * This is speculation, this packet is not documented, only
 * the answer...
 */
static const g2_ptype_action_func KHLR_packet_dict[PT_MAXIMUM] =
{
	[PT_TO    ] = empty_action_p,
	[PT_UKHLID] = handle_KHLR_UKHLID,
	[PT_QK    ] = handle_KHLR_QK,
	[PT_G2NS  ] = empty_action_p, /* ?? */
};

/* KHL-childs */
static const g2_ptype_action_func KHL_packet_dict[PT_MAXIMUM] =
{
	[PT_TO    ] = empty_action_p,
	[PT_TS    ] = handle_KHL_TS,
	[PT_NH    ] = handle_KHL_NH,
	[PT_CH    ] = handle_KHL_CH,
	[PT_YOURIP] = empty_action_p, /* yeah, my IP, thanks for the tip */
};

/* KHL/NH-childs */
static const g2_ptype_action_func KHL_NH_packet_dict[PT_MAXIMUM] =
{
	[PT_GU] = handle_KHL_NH_GU,
	[PT_V ] = empty_action_p,
	[PT_LS] = empty_action_p,
	[PT_HS] = empty_action_p,
};

/* KHL/CH-childs */
static const g2_ptype_action_func KHL_CH_packet_dict[PT_MAXIMUM] =
{
	[PT_GU] = handle_KHL_CH_GU,
	[PT_V ] = empty_action_p,
	[PT_LS] = empty_action_p,
	[PT_HS] = empty_action_p,
};

/* Q2-childs */
static const g2_ptype_action_func Q2_packet_dict[PT_MAXIMUM] =
{
	[PT_TO  ] = empty_action_p,
	[PT_UDP ] = handle_Q2_UDP,
	[PT_QKY ] = handle_Q2_QKY,
	[PT_URN ] = handle_Q2_URN,
	[PT_DN  ] = handle_Q2_DN,
	[PT_MD  ] = handle_Q2_MD,
	[PT_SZR ] = empty_action_p,
	[PT_I   ] = empty_action_p,
	[PT_dna ] = empty_action_p, /* marker it came from a GnucDNA client */
	[PT_NAT ] = empty_action_p, /* ??? needs to be handled */
	[PT_HKEY] = handle_Q2_HKEY,
	[PT_HURN] = handle_Q2_HURN,
	[PT_G1  ] = empty_action_p, /* after Q1 is deprecated, this is it? */
	[PT_NOG1] = empty_action_p, /* ??? */
	[PT_SV  ] = empty_action_p, /* needs to be processes? because there is no GUID... */
};

/* QH2-childs */
/*
 * These packets are a nightmare...
 * Since we do not search, all QH2 which pass us are:
 * a) not for us
 * or
 * b) spam, malicious
 * maybe both at the same time.
 *
 * The NA is useless, if we do not intend to know every client there is
 * (but we have to, to provide routing...)
 * we could look at the other packets to guess if the node is firewalled,
 * the NH are only interresting as a route back to the client
 * (taking them as khl is to dangerous...)
 * and the guid is only good for this routing, which is important, since
 * the node could be firewalled.
 *
 * BULLSHIT! Everything.
 *
 * At least the guid is a must-have field, check it, so we
 * can drop broken packets before forwarding.
 */
static const g2_ptype_action_func QH2_packet_dict[PT_MAXIMUM] =
{
	[PT_TO   ] = empty_action_p,
	[PT_GU   ] = handle_QH2_GU,
	[PT_NA   ] = handle_QH2_NA,
	[PT_NH   ] = empty_action_p,
	[PT_V    ] = empty_action_p, /* not interresting */
	[PT_FW   ] = empty_action_p,
	[PT_BH   ] = empty_action_p,
	[PT_BUP  ] = empty_action_p,
	[PT_BUSY ] = empty_action_p,
	[PT_UNSTA] = empty_action_p,
	[PT_PCH  ] = empty_action_p,
	[PT_HG   ] = empty_action_p,
	[PT_H    ] = empty_action_p,
	[PT_MD   ] = empty_action_p,
	[PT_UPRO ] = empty_action_p,
	[PT_SS   ] = empty_action_p,
	[PT_G1PP ] = empty_action_p, /* ?? */
	[PT_CS   ] = empty_action_p, /* ?? */
};

/* QA-childs */
/*
 * The same is true for QA, but they are trusted a little bit more,
 * since they come from hubs...
 * Check that? How? By knowing every Hub at every corner of
 * the Network?
 * We simply take whats delivered there (as Shareaza), actually we
 * don't care for the khl that much.
 */
static const g2_ptype_action_func QA_packet_dict[PT_MAXIMUM] =
{
	[PT_TO] = empty_action_p,
	[PT_TS] = handle_QA_TS,
	[PT_D ] = handle_QA_D,
	[PT_S ] = handle_QA_S,
	[PT_RA] = empty_action_p,
	[PT_FR] = handle_QA_FR, /* check if there is one to: Remove? Substitude? */
};


/* QKR-childs */
static const g2_ptype_action_func QKR_packet_dict[PT_MAXIMUM] =
{
	[PT_TO ] = empty_action_p,
	[PT_RNA] = handle_QKR_RNA,
	[PT_QNA] = handle_QKR_QNA,
	[PT_SNA] = handle_QKR_SNA,
	[PT_REF] = handle_QKR_REF,
	[PT_dna] = empty_action_p, /* marker it comes from a GnucDNA client  */
};

/* QKA-childs */
static const g2_ptype_action_func QKA_packet_dict[PT_MAXIMUM] =
{
	[PT_TO    ] = empty_action_p,
	[PT_QK    ] = handle_QKA_QK,
	[PT_QNA   ] = handle_QKA_QNA,
	[PT_SNA   ] = handle_QKA_SNA,
	[PT_CACHED] = handle_QKA_CACHED,
};

/* CRAWLR-childs */
static const g2_ptype_action_func CRAWLR_packet_dict[PT_MAXIMUM] =
{
	[PT_TO   ] = empty_action_p,
	[PT_REXT ] = handle_CRAWLR_REXT,
	[PT_RGPS ] = handle_CRAWLR_RGPS,
	[PT_RLEAF] = handle_CRAWLR_RLEAF,
	[PT_RNAME] = handle_CRAWLR_RNAME,
};

/* HAW-childs */
static const g2_ptype_action_func HAW_packet_dict[PT_MAXIMUM] =
{
	[PT_TO] = empty_action_p,
	[PT_HS] = empty_action_p, /* not interresting */
	[PT_NA] = handle_HAW_NA,
	[PT_V ] = empty_action_p, /* not interresting */
};

#define ENUM_CMD(x, y) str_it(x)
const char g2_ptype_names[][8] GCC_ATTR_VIS("hidden") =
{
	G2_PACKET_TYPES
};
#undef ENUM_CMD

#define ENUM_CMD(x, y) str_size(str_it(x))
const uint8_t g2_ptype_names_length[] GCC_ATTR_VIS("hidden") =
{
	G2_PACKET_TYPES
};
#undef ENUM_CMD

/*
 * Packet typer function
 *
 */
void g2_packet_find_type(g2_packet_t *packet, const char type_str[16])
{
	unsigned i = g2_ptype_dict_table[(unsigned char)type_str[0]] << 1;
	unsigned j = 1;

	prefetch(&g2_ptype_state_table[i]);
	packet->type = PT_UNKNOWN;
	if(unlikely((unsigned char)-1 == i))
		goto out;

	do
	{
		const unsigned char x = g2_ptype_state_table[i].c;
		const char match = T_GET_CHAR(x);
		logg_develd_old("\tp x: 0x%02X m: 0x%02X, '%c', %i, %i\n", x, match ? : '0',
			type_str[j] ? : '0', i, g2_ptype_state_table[i].u.d);
		if(likely(type_str[j] == match))
		{
			if(likely(T_IS_LAST(x))) {
				if(likely(type_str[j+1] == '\0')) {
					packet->type = T_GET_TYPE(g2_ptype_state_table[i].u.t);
					break;;
				}
			} else {
				i += T_GET_DELTA(g2_ptype_state_table[i].u.d);
				j++;
				continue;
			}
		}
		if(unlikely(T_IS_END(g2_ptype_state_table[i].u.d)))
			break;
		i++;
	} while(j < 16);

out:
	if(unlikely(PT_UNKNOWN == packet->type))
		logg_posd(LOGF_DEBUG, "Unknown packet type \"%s\"\tC: %s\n", type_str, packet->is_compound ? "true" : "false");
}

/*
 * prebuild packets
 */
static const char packet_po[]    = { 0x08, 'P', 'O', };
static const char packet_uproc[] = { 0x20, 'U', 'P', 'R', 'O', 'C' };

#define logg_packet(x, ...) logg_develd("\t"x, __VA_ARGS__)
#define logg_packet_old(x, ...) logg_develd_old("\t"x, __VA_ARGS__)
#define STDSF	"%s\n"
#define STDLF	"%s -> /%s\n"

/*
 * Packet handler helper
 *
 */
static GCC_ATTRIB_UNUSED void g2_packet_print_one(g2_packet_t *x)
{
	char pr_buf[2048];
	char *pr_ptr = pr_buf;

	pr_ptr += my_snprintf(pr_ptr, sizeof(pr_buf), "-Type: \"%s\"\tlength: %u\n", g2_ptype_names[x->type], x->length);
	pr_ptr += my_snprintf(pr_ptr, sizeof(pr_buf) - (pr_ptr - pr_buf), "-ll: %hhu\ttl: %hhu\n", x->length_length, x->type_length);
	pr_ptr += my_snprintf(pr_ptr, sizeof(pr_buf) - (pr_ptr - pr_buf), "-big-e: %s\tid-c: %s\n",
		x->big_endian ? "true" : "false", x->is_compound ? "true" : "false");
	pr_ptr += my_snprintf(pr_ptr, sizeof(pr_buf) - (pr_ptr - pr_buf), "-pde: %i\tpen: %i\n",
		x->packet_decode, x->packet_encode);
	pr_ptr += my_snprintf(pr_ptr, sizeof(pr_buf) - (pr_ptr - pr_buf), "-if: %s\tdtif: %s\tisl: %s\n",
		x->is_freeable ? "true" : "false", x->data_trunk_is_freeable ? "true" : "false",
		x->is_literal ? "true" : "false");
	pr_ptr += my_snprintf(pr_ptr, sizeof(pr_buf) - (pr_ptr - pr_buf), "-dtp: %p\tdtpos: %zu\tdtl: %zu\tdtc: %zu\n",
		buffer_start(x->data_trunk), x->data_trunk.pos, x->data_trunk.limit, x->data_trunk.capacity);
	pr_ptr += my_snprintf(pr_ptr, sizeof(pr_buf) - (pr_ptr - pr_buf), "-ln: %p\tlp: %p\tcn: %p\tcp: %p\n",
		x->list.next, x->list.prev, x->children.next, x->children.prev);
	logg_develd("%s", pr_buf);
}

static noinline bool skip_child(g2_packet_t *s, const char *name)
{
	bool ret_val = false;

	do
	{
		g2_packet_t child_p;
		child_p.more_bytes_needed = false;
		child_p.packet_decode = CHECK_CONTROLL_BYTE;
		ret_val = g2_packet_decode_from_packet(s, &child_p, 0);
		if(!ret_val) {
			logg_packet(STDLF, name, "broken child");
			break;
		}
		logg_packet("%s -> */%s additinaly found\n", name, g2_ptype_names[child_p.type]);
	} while(ret_val && s->packet_decode != DECODE_FINISHED);

//TODO: handle "reserverd" (important even if unknown) packets?

	return ret_val;
}

static bool skip_unexpected_child(g2_packet_t *s, const char *name)
{
	if(unlikely(s->is_compound))
		return skip_child(s, name);
	return true;
}

static inline bool unexpected_child(g2_packet_t *s, const char *name)
{
	if(s->is_compound) {
		logg_packet("%s\twith child! len: %zu\n", name, buffer_remaining(s->data_trunk));
		return true;
	}
	return false;
}

static bool read_na_from_packet(g2_packet_t *source, union combo_addr *target, const char *name)
{
	size_t rem = buffer_remaining(source->data_trunk);
	uint16_t tmp_port;

	if(6 != rem && 18 != rem) {
		logg_packet(STDLF, name, "NA not an IPv4 or IPv6 address");
		return false;
	}

	memset(target, 0, sizeof(*target));
	/* We Assume network byte order for the IP */
	if(6 == rem) {
		target->s.fam = AF_INET;
		target->in.sin_addr.s_addr = get_unaligned((uint32_t *)buffer_start(source->data_trunk));
		source->data_trunk.pos += sizeof(uint32_t);
	} else {
		target->s.fam = AF_INET6;
		memcpy(&target->in6.sin6_addr.s6_addr, buffer_start(source->data_trunk), INET6_ADDRLEN);
		source->data_trunk.pos += INET6_ADDRLEN;
	}
	casalen_ii(target);

	/* load port and fix it for those, who sent it the wrong way round */
	tmp_port = get_unaligned((uint16_t *)buffer_start(source->data_trunk));
	if(!source->big_endian)
		tmp_port = (tmp_port >> 8) | (tmp_port << 8);
	combo_addr_set_port(target, tmp_port);

	logg_packet_old("%s:\t%p#I\n", name, target);
	return true;
}

/*
 * sna are a na without port
 */
static bool read_sna_from_packet(g2_packet_t *source, union combo_addr *target, const char *name)
{
	size_t rem = buffer_remaining(source->data_trunk);

	/* sna should not have a port, but reallity... */
	if(4 != rem &&
		INET6_ADDRLEN != rem &&
		4+2 != rem &&
		INET6_ADDRLEN+2 != rem) {
		logg_packet(STDLF" %zu", name, "SNA not an IPv4 or IPv6 address", rem);
		return false;
	}

	memset(target, 0, sizeof(*target));
	/* We Assume network byte order for the IP */
	if(4 == rem || 6 == rem)
	{
		target->s.fam = AF_INET;
		target->in.sin_addr.s_addr = get_unaligned((uint32_t *) buffer_start(source->data_trunk));
		source->data_trunk.pos += sizeof(uint32_t);
		if(6 == rem)
		{
			uint16_t tmp_port = get_unaligned((uint16_t *)buffer_start(source->data_trunk));
			if(!source->big_endian)
				tmp_port = (tmp_port >> 8) | (tmp_port << 8);
			target->in.sin_port = tmp_port;
			source->data_trunk.pos += sizeof(uint16_t);
		}
	}
	else
	{
		target->s.fam = AF_INET6;
		memcpy(&target->in6.sin6_addr.s6_addr, buffer_start(source->data_trunk), INET6_ADDRLEN);
		source->data_trunk.pos += INET6_ADDRLEN;
		if(INET6_ADDRLEN+2 == rem)
		{
			uint16_t tmp_port = get_unaligned((uint16_t *)buffer_start(source->data_trunk));
			if(!source->big_endian)
				tmp_port = (tmp_port >> 8) | (tmp_port << 8);
			target->in6.sin6_port = tmp_port;
			source->data_trunk.pos += sizeof(uint16_t);
		}
	}
	casalen_ii(target);

	logg_packet_old("%s:\t%p#I\n", name, target);
	return true;
}

static bool read_ts_from_packet(g2_packet_t *source, time_t *tio, const char *name)
{
	time_t foreign_time;

	foreign_time = local_time_now;
	if(unlikely(!skip_unexpected_child(source, name)))
		goto out;

	if(unlikely(4 != buffer_remaining(source->data_trunk) &&
	            8 != buffer_remaining(source->data_trunk))) {
		logg_packet(STDLF, name, "not 4 or 8 byte");
		goto out;
	}

	/* fill the upper bit of time_t if we need more than the recvd 32 bit */
	if(8 == sizeof(time_t))
		foreign_time &= (time_t)0xFFFFFFFF00000000;
	else
		foreign_time  = 0;

	/* the most commen case 32-bit time_t and little endian (all the Win-Clients) */
	if(likely(4 == buffer_remaining(source->data_trunk)))
	{
		uint32_t t;
		get_unaligned_endian(t, (uint32_t *)buffer_start(source->data_trunk),
		                     source->big_endian);
		foreign_time |= (time_t)t;
	}
	else
	{
		uint64_t t;
		logg_packet(STDLF, name, "with 8 byte! Ola, a 64-bit OS?");
		/*
		 * Lets try too cludge it together, if we also have a 64-bit OS,
		 * everything will be fine, if not, we hopefully get the lower 32 bit,
		 * and if we don't test at the moment of overflow in 2032 (or when ever)
		 * it should work
		 */
		get_unaligned_endian(t, (uint64_t *)buffer_start(source->data_trunk),
		                     source->big_endian);
		foreign_time = (time_t)t;
	}

	*tio = foreign_time;

	return true;
out:
	return false;

}

static bool write_na_to_packet(g2_packet_t *target, union combo_addr *source)
{
	uint16_t port;
	size_t len, old_pos;

	len  = AF_INET == source->s.fam ? sizeof(uint32_t) : INET6_ADDRLEN;
	len += sizeof(port);

	if(!g2_packet_steal_data_space(target, len))
		return false;

	old_pos = target->data_trunk.pos;
	/* We Assume network byte order for the IP */
	if(AF_INET == source->s.fam) {
		put_unaligned(source->in.sin_addr.s_addr,
		              (uint32_t *)buffer_start(target->data_trunk));
		target->data_trunk.pos += sizeof(uint32_t);
	} else {
		memcpy(buffer_start(target->data_trunk),
		       &source->in6.sin6_addr.s6_addr, INET6_ADDRLEN);
		target->data_trunk.pos += INET6_ADDRLEN;
	}

	/* and use host byte order for the port */
	port = combo_addr_port(source);
	port = ntohs(port);
	put_unaligned(port, (uint16_t *)(buffer_start(target->data_trunk)));

	target->data_trunk.pos = old_pos;
	target->big_endian = HOST_IS_BIGENDIAN;
	return true;
}

static bool write_nats_to_packet(g2_packet_t *target, union combo_addr *source, time_t when)
{
	size_t len, old_pos;
	uint16_t port;

	len  = AF_INET == source->s.fam ? sizeof(uint32_t) : INET6_ADDRLEN;
	len += sizeof(time_t) + sizeof(uint16_t);

	if(!g2_packet_steal_data_space(target, len))
		return false;

	old_pos = target->data_trunk.pos;
	/* We Assume network byte order for the IP */
	if(AF_INET == source->s.fam) {
		put_unaligned(source->in.sin_addr.s_addr,
		              (uint32_t *)buffer_start(target->data_trunk));
		target->data_trunk.pos += sizeof(uint32_t);
	} else {
		memcpy(buffer_start(target->data_trunk),
		       &source->in6.sin6_addr.s6_addr, INET6_ADDRLEN);
		target->data_trunk.pos += INET6_ADDRLEN;
	}

	/* and use host byte order for the port */
	port = combo_addr_port(source);
	port = ntohs(port);
	put_unaligned(port, (uint16_t *)(buffer_start(target->data_trunk)));
	target->data_trunk.pos += sizeof(uint16_t);

	/* now the time stamp */
	put_unaligned(when, (time_t *)buffer_start(target->data_trunk));

	target->data_trunk.pos = old_pos;
	target->big_endian = HOST_IS_BIGENDIAN;
	return true;
}

static void link_sna_to_packet(g2_packet_t *target, union combo_addr *source)
{
	/* We Assume network byte order for the IP */
	if(AF_INET == source->s.fam){
		target->data_trunk.data = (void *)&source->in.sin_addr.s_addr;
		target->data_trunk.capacity = sizeof(uint32_t);
	} else {
		target->data_trunk.data = (void *)source->in6.sin6_addr.s6_addr;
		target->data_trunk.capacity = INET6_ADDRLEN;
	}
	target->data_trunk_is_freeable = false;
	buffer_clear(target->data_trunk);
	target->big_endian = HOST_IS_BIGENDIAN;
}

static bool write_sna_to_packet_endian(g2_packet_t *target, union combo_addr *source, bool b_endian)
{
	size_t len;
	uint16_t port = 0, *p_ptr;

	len = AF_INET == source->s.fam ? sizeof(uint32_t) : INET6_ADDRLEN;
	if(AF_INET == source->s.fam)
		port = source->in.sin_port;
	else
		port = source->in6.sin6_port;
	if(port)
		len += sizeof(port);

	if(!g2_packet_steal_data_space(target, len))
		return false;

	/* We Assume network byte order for the IP */
	if(AF_INET == source->s.fam) {
		put_unaligned(source->in.sin_addr.s_addr,
		              (uint32_t *)buffer_start(target->data_trunk));
		p_ptr = (uint16_t *)(buffer_start(target->data_trunk) + sizeof(uint32_t));
	} else {
		memcpy(buffer_start(target->data_trunk),
		       &source->in6.sin6_addr.s6_addr, INET6_ADDRLEN);
		p_ptr = (uint16_t *)(buffer_start(target->data_trunk) + INET6_ADDRLEN);
	}
	if(port) {
		if(!b_endian)
			port = __swab16(port);
		put_unaligned(port, p_ptr);
	}

	target->big_endian = b_endian;
	return true;
}

static bool write_sna_to_packet(g2_packet_t *target, union combo_addr *source)
{
	return write_sna_to_packet_endian(target, source, HOST_IS_BIGENDIAN);
}

static bool fill_d_packet(g2_packet_t *d, union combo_addr *taddr, uint16_t leafs)
{
	size_t len, old_pos_in;
	uint16_t port;

	len  = AF_INET == taddr->s.fam ? sizeof(uint32_t) : INET6_ADDRLEN;
	len += sizeof(port) + sizeof(uint16_t);

	if(!g2_packet_steal_data_space(d, len))
		return false;

	d->type = PT_D;
	d->big_endian = HOST_IS_BIGENDIAN;

	old_pos_in = d->data_trunk.pos;
	/* We Assume network byte order for the IP */
	if(AF_INET == taddr->s.fam) {
		put_unaligned(taddr->in.sin_addr.s_addr,
		              (uint32_t *)buffer_start(d->data_trunk));
		d->data_trunk.pos += sizeof(uint32_t);
	} else {
		memcpy(buffer_start(d->data_trunk),
		       &taddr->in6.sin6_addr.s6_addr, INET6_ADDRLEN);
		d->data_trunk.pos += INET6_ADDRLEN;
	}

	/* and use host byte order for the port and leaf count */
	port = combo_addr_port(taddr);
	port = ntohs(port);
	put_unaligned(port, (uint16_t *)(buffer_start(d->data_trunk)));
	d->data_trunk.pos += sizeof(port);

	put_unaligned(leafs, (uint16_t *)(buffer_start(d->data_trunk)));
	d->data_trunk.pos = old_pos_in;

	return true;
}

static bool g2_packet_has_TO(g2_packet_t *src, uint8_t **guid)
{
	char *data;

	/*
	 * This is a utterly dirty Hack
	 * we skim the start of the packet buffer for a TO packet,
	 * without proper decoding.
	 * This allows us to decide to route on a generic level, without
	 * going into the details of all packets, and without repeating
	 * code over and over again.
	 * Shareaza does the same (maybe with a little more checking
	 * hidden in C++ fluff).
	 * Thats also the reason why the TO packet has to be the first
	 * child packet.
	 */

	/* child packets? */
	if(!src->is_compound)
		return false;

	/* enough space for TO packet + guid? */
	if(buffer_remaining(src->data_trunk) < 4 + 16)
		return false;

	/* TO signature? */
	data = buffer_start(src->data_trunk);
	if(data[0] != 0x48)
		return false;
	if(data[1] != 0x10)
		return false;
	if(data[2] != 'T')
		return false;
	if(data[3] != 'O')
		return false;

	*guid = (uint8_t *)&data[4];
	return true;
}

static bool g2_packet_needs_routing(g2_packet_t *src, uint8_t **guid)
{
	/* do we have a to? */
	if(!g2_packet_has_TO(src, guid))
		return false;

	/* is it addressed to us? */
	if(0 == memcmp(server.settings.our_guid, *guid, 16))
		return false; /* handle localy */

	return true;
}

static void g2_packet_send_qka(const union combo_addr *req_addr, union combo_addr *send_addr, const union combo_addr *from)
{
	struct list_head answer;
	g2_packet_t qka, qk, sna;
	uint32_t key;

	if(!combo_addr_is_public(req_addr) || !combo_addr_port(req_addr))
		return;

	g2_packet_init_on_stack(&qka);
	g2_packet_init_on_stack(&qk);

	/* should not fail */
	if(!g2_packet_steal_data_space(&qk, sizeof(uint32_t)))
		return;

// TODO: check for our own IP
	if(send_addr &&
	   !combo_addr_eq_ip(req_addr, send_addr))
	{
		g2_packet_init_on_stack(&sna);
		sna.type = PT_SNA;
		link_sna_to_packet(&sna, send_addr);
		list_add_tail(&sna.list, &qka.children);
	}

	key = g2_qk_generate(req_addr);
	qk.type = PT_QK;
	put_unaligned(key, (uint32_t *)buffer_start(qk.data_trunk));
	qk.big_endian = HOST_IS_BIGENDIAN;
	list_add_tail(&qk.list, &qka.children);

	qka.big_endian = HOST_IS_BIGENDIAN;
	qka.type = PT_QKA;

	INIT_LIST_HEAD(&answer);
	list_add_tail(&qka.list, &answer);
	g2_udp_send(req_addr, from, &answer);
}

static void g2_packet_add2target(g2_packet_t *to_add, struct list_head *target, shortlock_t *target_lock)
{
	if(target_lock)
	{
		shortlock_t_lock(target_lock);
		list_add_tail(&to_add->list, target);
		shortlock_t_unlock(target_lock);
	}
	else
		list_add_tail(&to_add->list, target);
}

static intptr_t forward_lit_callback_ignore(g2_connection_t *con, void *carg)
{
	struct ptype_action_args *parg = carg;
	g2_packet_t *t, *source = parg->source;

	logg_packet_old("/%s -> wants routing to %p#I\n", g2_ptype_names[parg->source->type], &con->remote_host);
	/*
	 * The connection is locked against removal inside this callback
	 * (but because of this we do not want to lock to long, we have
	 * a whole hash slot locked in the conreg...).
	 * But there may be further locking needed.
	 */
	t = g2_packet_clone(source);
	if(!t)
		return 0;

	/* if we can, steal the data form the source packet */
	if(unlikely(source->data_trunk_is_freeable)) {
		source->data_trunk.data = NULL;
		source->data_trunk.pos = source->data_trunk.limit = source->data_trunk.capacity = 0;
		source->data_trunk_is_freeable = false;
	} else {
		/* data in packet buffer? Adjust */
		if(unlikely(source->data_trunk.data >= source->pd.out &&
		            source->data_trunk.data < &source->pd.out[sizeof(source->pd.out)])) {
			ptrdiff_t diff = source->data_trunk.data - source->pd.out;
			t->data_trunk.data = &t->pd.out[diff];
		}
		else
		{
			/* data still lingers in the recv buff, we have to copy it */
			if(!g2_packet_steal_data_space_lit(t, buffer_remaining(source->data_trunk))) {
				g2_packet_free(t);
				return 0;
			}
			my_memcpy(buffer_start(t->data_trunk), buffer_start(source->data_trunk),
			          buffer_remaining(source->data_trunk));
		}
	}
	t->is_literal = true;
	/*
	 * MB:
	 * the spinlock in con_mark_write should barrier our doings
	 */
	g2_handler_con_mark_write(t, con);

	return 0;
}

static intptr_t forward_lit_callback_found(g2_connection_t *con, void *carg)
{
	struct ptype_action_args *parg = carg;
	g2_packet_t *t, *source = parg->source;

	/*
	 * The connection is locked against removal inside this callback
	 * (but because of this we do not want to lock to long, we have
	 * a whole hash slot locked in the conreg...).
	 * But there may be further locking needed.
	 */
	t = g2_packet_clone(source);
	if(!t)
		return 1;

	/* if we can, steal the data form the source packet */
	if(unlikely(source->data_trunk_is_freeable)) {
		source->data_trunk.data = NULL;
		source->data_trunk.pos = source->data_trunk.limit = source->data_trunk.capacity = 0;
		source->data_trunk_is_freeable = false;
	} else {
		/* data in packet buffer? Adjust */
		if(unlikely(source->data_trunk.data >= source->pd.out &&
		            source->data_trunk.data < &source->pd.out[sizeof(source->pd.out)])) {
			ptrdiff_t diff = source->data_trunk.data - source->pd.out;
			t->data_trunk.data = &t->pd.out[diff];
		}
		else
		{
			/* data still lingers in the recv buff, we have to copy it */
			if(!g2_packet_steal_data_space_lit(t, buffer_remaining(source->data_trunk))) {
				g2_packet_free(t);
				return 1;
			}
			my_memcpy(buffer_start(t->data_trunk), buffer_start(source->data_trunk),
			          buffer_remaining(source->data_trunk));
		}
	}
	t->is_literal = true;
	/*
	 * MB:
	 * the spinlock in con_mark_write should barrier our doings
	 */
	g2_handler_con_mark_write(t, con);

	return 1;
}

/*
 * Packet handler functions
 *
 *
 */
static bool empty_action_p(struct ptype_action_args *parg GCC_ATTR_UNUSED_PARAM)
{
	/* packet is not useful for us */
	logg_packet_old("%s/%s\tC: %s -> ignored\n", parg->father ? g2_ptype_names[parg->father->type] : "", g2_ptype_names[parg->source->type], parg->source->is_compound ? "true" : "false");
	return false;
}

static inline bool unimpl_action_p(struct ptype_action_args *parg GCC_ATTR_UNUSED_PARAM)
{
	/* packet should be handled,  */
	logg_packet("%s/%s\tC: %s -> unimplemented\n", parg->father ? g2_ptype_names[parg->father->type] : "", g2_ptype_names[parg->source->type], parg->source->is_compound ? "true" : "false");
	return false;
}

struct KHLR_data
{
	char *id;
	uint32_t query_key;
	bool query_key_valid;
};

static bool handle_KHLR(struct ptype_action_args *parg)
{
	struct khl_entry khle[8];
	struct KHLR_data rdata;
	g2_packet_t *khla, *ts, *yourip, *url;
	size_t res;
	bool ret_val = false;

	rdata.id = NULL;
	rdata.query_key_valid = false;
	if(parg->source->is_compound)
	{
		struct ptype_action_args cparg;
		bool keep_decoding;

		cparg = *parg;
		cparg.father = parg->source;
		cparg.opaque = &rdata;
		do
		{
			g2_packet_t child_p;
			cparg.source = &child_p;
			child_p.more_bytes_needed = false;
			child_p.packet_decode = CHECK_CONTROLL_BYTE;
			keep_decoding = g2_packet_decode_from_packet(parg->source, &child_p, 0);
			if(!keep_decoding) {
				logg_packet(STDLF, "KHLR", "broken child");
				break;
			}
			if(likely(child_p.packet_decode == DECODE_FINISHED))
				ret_val |= g2_packet_decide_spec_int(&cparg, KHLR_packet_dict);
		} while(keep_decoding && parg->source->packet_decode != DECODE_FINISHED);

		/* punishment for broken packets: no answer */
		if(parg->source->packet_decode != DECODE_FINISHED)
			return ret_val;
	}

	/*
	 * ------======******** HINT HINT HINT ********======------
	 * <<<<(((({{{{{{[[[[  IMPORTANT NOTICE  ]]]]}}}}}}))))>>>>
	 *
	 * ! ! ! ! there is no query key for KHLR in the spec ! ! ! !
	 *
	 * But this is madness, someone not carefully read the comment
	 * about search security and did not understand why query keys
	 * are needed for UDP querys.
	 * (poisening the sender is a minor problem, harming unrelated
	 * internet nodes is (traffic amplification attack))
	 *
	 * Since we already have a query key infrastructure (and KHLRs
	 * are not supposed for UDP challenged nodes...), use it, to
	 * prevent flooding other/the wrong nodes.
	 *
	 * This is a deviation and so no client will get a KHLA from
	 * us, till they also see a need for this, but till then
	 * i wont be the one who sends unsolicied UDP to a sender
	 * address, which can be spoofed.
	 *
	 * ^+++EOM
	 */
	if(!rdata.query_key_valid)
		return ret_val;

	if(!g2_qk_check(parg->src_addr, rdata.query_key))
		return ret_val;
// TODO: maybe send a query key renewel...

		/* build package */
	khla   = g2_packet_calloc();
	ts     = g2_packet_calloc();
	yourip = g2_packet_calloc();
	url    = g2_packet_calloc();

	if(!(khla && ts))
		goto out_fail;

	khla->type = PT_KHL;
	ts->type   = PT_TS;
	if(g2_packet_steal_data_space(ts, sizeof(time_t)))
	{
		time_t now = local_time_now;
		put_unaligned(now, (time_t *)(buffer_start(ts->data_trunk)));
		ts->big_endian = HOST_IS_BIGENDIAN;
		list_add_tail(&ts->list, &khla->children);
	}
	else
		goto out_fail;

	if(yourip)
	{
		yourip->type = PT_YOURIP;
		if(write_na_to_packet(yourip, parg->src_addr))
			list_add_tail(&yourip->list, &khla->children);
		else
			g2_packet_free(yourip);
	}

	if(url)
	{
		const char *url_str;

		url_str = g2_khl_get_url();
		if(url_str && g2_packet_steal_data_space(url, strlen(url_str)))
		{
			url->type = PT_URL;
			my_memcpy(buffer_start(yourip->data_trunk), url_str, strlen(url_str));
			url->big_endian = HOST_IS_BIGENDIAN;
			list_add_tail(&url->list, &khla->children);
		}
		else
			g2_packet_free(url);
	}

	if(rdata.id)
	{
		g2_packet_t *ukhlid = g2_packet_calloc();
		if(ukhlid)
		{
			if(g2_packet_steal_data_space(ukhlid, 16))
			{
				ukhlid->type = PT_UKHLID;
				memcpy(buffer_start(ukhlid->data_trunk), rdata.id, 16);
				ukhlid->big_endian = HOST_IS_BIGENDIAN;
				list_add_tail(&ukhlid->list, &khla->children);
			}
			else
				g2_packet_free(ukhlid);
		}
	}

	res = g2_khl_fill_p(khle, anum(khle), parg->src_addr->s.fam);
	while(res--)
	{
		g2_packet_t *ch = g2_packet_calloc();

		if(!ch)
			break;
		ch->type = PT_CH;
		if(!write_nats_to_packet(ch, &khle[res].na, khle[res].when)) {
			g2_packet_free(ch);
			break;
		}
		list_add_tail(&ch->list, &khla->children);
	}
	khla->big_endian = HOST_IS_BIGENDIAN;

// TODO: fill in our neighbouring hubs

	/* only UDP, no need to lock */
	list_add_tail(&khla->list, parg->target);
	return true;
out_fail:
	g2_packet_free(ts);
	g2_packet_free(khla);
	g2_packet_free(yourip);
	g2_packet_free(url);
	return false;
}

static bool handle_KHLR_UKHLID(struct ptype_action_args *parg)
{
	struct KHLR_data *rdata = parg->opaque;

	if(unlikely(!skip_unexpected_child(parg->source, "/KHLR/UKHLID")))
		return false;

	if(16 == buffer_remaining(parg->source->data_trunk))
		rdata->id = buffer_start(parg->source->data_trunk);
	else
		logg_packet(STDLF, "/KHLR/UKHLID", "UKHLID not a valid ID");

	return false;
}

static bool handle_KHLR_QK(struct ptype_action_args *parg)
{
	g2_packet_t *source = parg->source;
	struct KHLR_data *rdata = parg->opaque;

	if(unlikely(!skip_unexpected_child(parg->source, "/KHLR/QK")))
		return false;

	if(4 != buffer_remaining(source->data_trunk)) {
		logg_packet(STDLF, "/KHLR/QK", "funny length");
		return false;
	}

	get_unaligned_endian(rdata->query_key, (uint32_t *)buffer_start(source->data_trunk), source->big_endian);
	rdata->query_key_valid = true;
	return false;
}

static intptr_t callback_KHL_NH(g2_connection_t *con, void *data)
{
	g2_packet_t *khl = data;
	g2_packet_t *nh, *gu = NULL, *v = NULL, *hs;

	nh = g2_packet_calloc();
	hs = g2_packet_calloc();
	if(!(nh && hs))
		return 0;

	nh->type = PT_NH;
	if(!write_na_to_packet(nh, &con->sent_addr))
		goto out_fail;
	if(g2_packet_steal_data_space(hs, 2))
	{
		uint16_t cons  = con->u.handler.leaf_count;
		put_unaligned(cons, (uint16_t *)buffer_start(hs->data_trunk));
		hs->type       = PT_HS;
		hs->big_endian = HOST_IS_BIGENDIAN;
	}
	else {
		g2_packet_free(hs);
		hs = NULL;
	}

	if(con->vendor_code[0] && (v = g2_packet_calloc()))
	{
		size_t v_len = strlen(con->vendor_code);
		if(g2_packet_steal_data_space(v, v_len))
		{
			memcpy(buffer_start(v->data_trunk), con->vendor_code, v_len);
			v->type       = PT_V;
			v->big_endian = HOST_IS_BIGENDIAN;
		}
		else {
			g2_packet_free(v);
			v = NULL;
		}
	}
	if(memcmp(con->guid, "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 16) != 0 &&
	   (gu = g2_packet_calloc()))
	{
		if(g2_packet_steal_data_space(gu, GUID_SIZE))
		{
			memcpy(buffer_start(gu->data_trunk), con->guid, GUID_SIZE);
			gu->type       = PT_GU;
			gu->big_endian = HOST_IS_BIGENDIAN;
		}
		else {
			g2_packet_free(gu);
			gu = NULL;
		}
	}

	if(hs)
		list_add_tail(&hs->list, &nh->children);
	if(v)
		list_add_tail(&v->list, &nh->children);
	if(gu)
		list_add_tail(&gu->list, &nh->children);
	list_add_tail(&nh->list, &khl->children);
	return 0;
out_fail:
	g2_packet_free(nh);
	g2_packet_free(hs);
	g2_packet_free(gu);
	g2_packet_free(v);
	return 0;
}

static bool handle_KHL(struct ptype_action_args *parg)
{
	struct khl_entry khle[16];
	struct ptype_action_args cparg;
	g2_packet_t *khl, *ts, *yourip;
	size_t res;
	bool ret_val = false, keep_decoding;

	cparg = *parg;
	cparg.father = parg->source;
	do
	{
		g2_packet_t child_p;
		cparg.source = &child_p;
		child_p.more_bytes_needed = false;
		child_p.packet_decode = CHECK_CONTROLL_BYTE;
		keep_decoding = g2_packet_decode_from_packet(parg->source, &child_p, 0);
		if(!keep_decoding) {
			logg_packet(STDLF, "KHL", "broken child");
			parg->connec->flags.dismissed = true;
			return ret_val;
		}
		if(likely(child_p.packet_decode == DECODE_FINISHED))
			ret_val |= g2_packet_decide_spec_int(&cparg, KHL_packet_dict);
	} while(keep_decoding && parg->source->packet_decode != DECODE_FINISHED);

	parg->connec->flags.last_data_active = true;

	/* time to send a packet again? */
	if(local_time_now <
	   (parg->connec->u.handler.send_stamps.KHL + (KHL_TIMEOUT * parg->connec->flags.upeer ? 1 : 3)))
		return ret_val;

	/* build package */
	khl    = g2_packet_calloc();
	ts     = g2_packet_calloc();
	yourip = g2_packet_calloc();

	if(!(khl && ts))
		goto out_fail;

	khl->type = PT_KHL;
	ts->type  = PT_TS;
	if(g2_packet_steal_data_space(ts, sizeof(time_t)))
	{
		time_t now = local_time_now;
		put_unaligned(now, (time_t *)(buffer_start(ts->data_trunk)));
		ts->big_endian = HOST_IS_BIGENDIAN;
		list_add_tail(&ts->list, &khl->children);
	}
	else
		goto out_fail;

	if(yourip)
	{
		yourip->type = PT_YOURIP;
		if(write_sna_to_packet(yourip, &parg->connec->remote_host))
			list_add_tail(&yourip->list, &khl->children);
		else
			g2_packet_free(yourip);
	}

	res = g2_khl_fill_p(khle, anum(khle), parg->connec->remote_host.s.fam);
	while(res--)
	{
		g2_packet_t *ch = g2_packet_calloc();

		if(!ch)
			break;
		ch->type = PT_CH;
		if(!write_nats_to_packet(ch, &khle[res].na, khle[res].when)) {
			g2_packet_free(ch);
			break;
		}
		list_add_tail(&ch->list, &khl->children);
	}
	khl->big_endian = HOST_IS_BIGENDIAN;

	g2_conreg_all_hub(NULL, callback_KHL_NH, khl);

	g2_packet_add2target(khl, parg->target, parg->target_lock);
	parg->connec->u.handler.send_stamps.KHL = local_time_now;
	return true;
out_fail:
	g2_packet_free(yourip);
	g2_packet_free(ts);
	g2_packet_free(khl);
	return false;
}

static bool handle_KHL_TS(struct ptype_action_args *parg)
{
	time_t foreign_time;
	time_t local_time;

	local_time = local_time_now;

	if(read_ts_from_packet(parg->source, &foreign_time, "/KHL/TS")) {
		logg_packet_old("/KHL/TS -> %lu\t%lu\n", (unsigned long)foreign_time, (unsigned long)local_time);
		parg->connec->time_diff = (long)local_time - (long)foreign_time;
	}

	return false;
}

struct KHL_NH_data
{
	uint8_t *guid;
	/*
	 * Vendor code
	 * Hub status
	 * Library statistics (ignore it, we are not in for casual talk...)
	 */
};

static bool handle_KHL_NH(struct ptype_action_args *parg)
{
	union combo_addr addr;
	struct KHL_NH_data rdata;
	g2_packet_t *source = parg->source;
	bool ret_val = false;

	rdata.guid = NULL;
	if(source->is_compound)
	{
		struct ptype_action_args cparg;
		bool keep_decoding;

		cparg = *parg;
		cparg.father = source;
		cparg.opaque = &rdata;
		do
		{
			g2_packet_t child_p;
			cparg.source = &child_p;
			child_p.more_bytes_needed = false;
			child_p.packet_decode = CHECK_CONTROLL_BYTE;
			keep_decoding = g2_packet_decode_from_packet(source, &child_p, 0);
			if(!keep_decoding) {
				logg_packet(STDLF, "KHL/NH", "broken child");
				parg->connec->flags.dismissed = true;
				break;
			}
			if(likely(child_p.packet_decode == DECODE_FINISHED))
				ret_val |= g2_packet_decide_spec_int(&cparg, KHL_NH_packet_dict);
		} while(keep_decoding && source->packet_decode != DECODE_FINISHED);
	}

// TODO: a neighbouring hub is different: cluster and routing and foo

	if(source->packet_decode == DECODE_FINISHED &&
	   read_na_from_packet(source, &addr, "/KHL/NH")) {
		if(rdata.guid)
			g2_guid_add(rdata.guid, &addr, local_time_now, GT_KHL_NEIGHBOUR);
		g2_khl_add(&addr, local_time_now, parg->connec->flags.upeer);
		/* only the NH of our connected hubs are in our cluster */
	}
	return ret_val;
}

static bool handle_KHL_NH_GU(struct ptype_action_args *parg)
{
	struct KHL_NH_data *rdata = parg->opaque;

	if(unlikely(!skip_unexpected_child(parg->source, "/KHL/NH/GU")))
		return false;

	if(16 == buffer_remaining(parg->source->data_trunk))
		rdata->guid = (uint8_t *)buffer_start(parg->source->data_trunk);
	else
		logg_packet(STDLF, "/KHL/NH/GU", "GU not a valid GUID");

	return false;
}

struct KHL_CH_data
{
	uint8_t *guid;
	/*
	 * Vendor code
	 * Hub status
	 * Library statistics (ignore it, we are not in for casual talk...)
	 */
};

static bool handle_KHL_CH(struct ptype_action_args *parg)
{
	struct KHL_CH_data rdata;
	g2_packet_t *source = parg->source;
	g2_connection_t *connec = parg->connec;
	size_t remaining;
	union combo_addr addr;
	time_t when;
	bool ret_val = false;

	rdata.guid = NULL;
	/* revalute unlikely with real network connection */
	if(unlikely(source->is_compound))
	{
		struct ptype_action_args cparg;
		bool keep_decoding;

		cparg = *parg;
		cparg.father = source;
		cparg.opaque = &rdata;
		do
		{
			g2_packet_t child_p;
			cparg.source = &child_p;
			child_p.more_bytes_needed = false;
			child_p.packet_decode = CHECK_CONTROLL_BYTE;
			keep_decoding = g2_packet_decode_from_packet(source, &child_p, 0);
			if(!keep_decoding) {
				logg_packet(STDLF, "KHL/NH/CH", "broken child");
				connec->flags.dismissed = true;
				break;
			}
			if(likely(child_p.packet_decode == DECODE_FINISHED))
				ret_val |= g2_packet_decide_spec_int(&cparg, KHL_CH_packet_dict);
		} while(keep_decoding && source->packet_decode != DECODE_FINISHED);
	}

	/* something wrong with the decoding? */
	if(source->packet_decode != DECODE_FINISHED)
		return ret_val; /* in that case we can not continue */

	/*
	 * who thought of that shit???
	 * "Hey, lets cram all kind of binary numbers which will /never/ change
	 * their size into one blob" yeah, maybe on winblow... IPv6? 64bit time_t?
	 *
	 *	IP	Port	TS
	 *	4	2	4	= 10 winblow
	 *	16	2	4	= 22 IPv6
	 *	16	2	8	= 26 IPv6 + 64bit time_t
	 *	4	2	8	= 14 64bit time_t
	 *
	 * and the docs say nothing about endianess...
	 * looks like ip in net byte order, rest in host byte order
	 */

	remaining = buffer_remaining(source->data_trunk);

	if(8 == sizeof(time_t))
		when = local_time_now & (time_t)0xFFFFFFFF00000000ULL;
	else
		when = 0;

	if(10 == remaining || /* IPv4 */
	   22 == remaining    /* IPv6 */)
	{
		char *data = buffer_start(source->data_trunk) + remaining - 4;
		uint32_t t;
		get_unaligned_endian(t, (uint32_t *)data, source->big_endian);
		source->data_trunk.limit -= 4;
		when |= (time_t)(t + connec->time_diff);
	}
	else if(26 == remaining || /* IPv6 + 64Bit time_t */
	        14 == remaining    /*        64Bit time_t */)
	{
		char *data = buffer_start(source->data_trunk) + remaining - 8;
		uint64_t t;
		get_unaligned_endian(t, (uint64_t *)data, source->big_endian);
		source->data_trunk.limit -= 8;
		when = (time_t)(t + connec->time_diff);
	} else {
		logg_packet(STDLF, "/KHL/CH", "funny length");
		goto out;
	}

	if(read_na_from_packet(source, &addr, "/KHL/CH")) {
		g2_khl_add(&addr, when, false);
		if(rdata.guid)
			g2_guid_add(rdata.guid, &addr, when, GT_KHL);
	}

out:
	return ret_val;
}

static bool handle_KHL_CH_GU(struct ptype_action_args *parg)
{
	struct KHL_CH_data *rdata = parg->opaque;

	if(unlikely(!skip_unexpected_child(parg->source, "/KHL/CH/GU")))
		return false;

	if(16 == buffer_remaining(parg->source->data_trunk))
		rdata->guid = (uint8_t *)buffer_start(parg->source->data_trunk);
	else
		logg_packet(STDLF, "/KHL/CH/GU", "GU not a valid GUID");

	return false;
}

struct LNI_data
{
	bool had_LNI_QK;
	bool had_LNI_FW;
	bool had_LNI_HS;
	bool had_LNI_HA;
	bool had_LNI_RTR;
	bool had_LNI_GU;
};

noinline bool g2_packet_add_LNI(g2_connection_t *connec)
{
	union combo_addr local_addr;
	g2_packet_t *lni, *na, *gu, *v, *hs, *qk;
	socklen_t sin_size = sizeof(local_addr);

	lni = g2_packet_calloc();
	na  = g2_packet_calloc();
	gu  = g2_packet_calloc();
	v   = g2_packet_calloc();
	hs  = likely(server.status.our_server_upeer) ? g2_packet_calloc() : NULL;
	qk  = likely(server.status.our_server_upeer) ? g2_packet_calloc() : NULL;

	if(!(lni && na))
		goto out_fail;

	lni->type = PT_LNI;
	na->type = PT_NA;

	casalen_ib(&local_addr);
	if(getsockname(connec->com_socket, casa(&local_addr), &sin_size))
		goto out_fail;
	if(!write_na_to_packet(na, &local_addr))
		goto out_fail;
	list_add_tail(&na->list, &lni->children);

	if(v)
	{
		v->type = PT_V;
		v->data_trunk.data     = (void *)(intptr_t)OWN_VENDOR_CODE;
		v->data_trunk.capacity = str_size(OWN_VENDOR_CODE);
		buffer_clear(v->data_trunk);
		list_add_tail(&v->list, &lni->children);
	}
	if(gu)
	{
		gu->type = PT_GU;
		gu->data_trunk.data     = (char *)server.settings.our_guid;
		gu->data_trunk.capacity = sizeof(server.settings.our_guid);
		buffer_clear(gu->data_trunk);
		list_add_tail(&gu->list, &lni->children);
	}
	if(hs)
	{
		hs->type = PT_HS;
		if(g2_packet_steal_data_space(hs, 4))
		{
			uint16_t cons     = (uint16_t)atomic_read(&server.status.act_connection_sum);
			uint16_t max_cons = server.settings.max_connection_sum;
			put_unaligned(cons, (uint16_t *)buffer_start(hs->data_trunk));
			put_unaligned(max_cons, (uint16_t *)(buffer_start(hs->data_trunk)+2));
			hs->big_endian = HOST_IS_BIGENDIAN;
			list_add_tail(&hs->list, &lni->children);
		}
		else
			g2_packet_free(hs);
	}
	if(qk) {
		qk->type = PT_QK;
		list_add_tail(&qk->list, &lni->children);
	}
	lni->big_endian = HOST_IS_BIGENDIAN;

	g2_packet_add2target(lni, &connec->packets_to_send, &connec->pts_lock);
	connec->u.handler.send_stamps.LNI = local_time_now;

	return true;
out_fail:
	g2_packet_free(lni);
	g2_packet_free(na);
	g2_packet_free(gu);
	g2_packet_free(v);
	g2_packet_free(hs);
	g2_packet_free(qk);
	return false;
}

static bool handle_LNI(struct ptype_action_args *parg)
{
	struct ptype_action_args cparg;
	g2_connection_t *connec = parg->connec;
	bool ret_val = false, keep_decoding;
	struct LNI_data rdata;

	memset(&rdata, 0, sizeof(rdata));
	cparg = *parg;
	cparg.father = parg->source;
	cparg.opaque = &rdata;
	do
	{
		g2_packet_t child_p;
		cparg.source = &child_p;
		child_p.more_bytes_needed = false;
		child_p.packet_decode = CHECK_CONTROLL_BYTE;
		keep_decoding = g2_packet_decode_from_packet(parg->source, &child_p, 0);
		if(!keep_decoding) {
			logg_packet(STDLF, "LNI", "broken child");
			connec->flags.dismissed = true;
			return ret_val;
		}
		if(likely(child_p.packet_decode == DECODE_FINISHED))
			ret_val |= g2_packet_decide_spec_int(&cparg, LNI_packet_dict);
	} while(keep_decoding && parg->source->packet_decode != DECODE_FINISHED);

	if(!rdata.had_LNI_HS && connec->flags.upeer)
	{
		/* demote connection from hub mode */
		connec->flags.upeer = false;
		/*
		 * if the connection isn't a hub any more, but has a
		 * compressed link, kick it, to prevent recource stealing
		 */
		if(connec->encoding_in != ENC_NONE || connec->encoding_out != ENC_NONE)
			connec->flags.dismissed = true;
		g2_conreg_demote_hub(connec);
		/* connection is no hub anymore, add to QHTs */
		g2_conreg_mark_dirty(connec);
		if(connec->sent_qht) {
			struct qhtable *t = connec->sent_qht;
			connec->sent_qht = NULL;
			g2_qht_put(t);
		}
	}
	/* demote other options */
	if(!rdata.had_LNI_QK && connec->flags.query_key_cache)
		connec->flags.query_key_cache = false;
	if(!rdata.had_LNI_FW && connec->flags.firewalled)
		connec->flags.firewalled = false;
	if(!rdata.had_LNI_RTR && connec->flags.router)
		connec->flags.router = false;
	if(!rdata.had_LNI_HA && connec->flags.hub_able)
		connec->flags.hub_able = false;

// TODO: update less often?
	/* conreg and guid update only in timeout intervals? */
	if(rdata.had_LNI_GU)
		g2_guid_add(connec->guid, &connec->remote_host, local_time_now,
		            connec->flags.upeer ? GT_NEIGHBOUR : GT_LEAF);
		/* using remote_host because we registered it with this in the registry */

	connec->flags.last_data_active = true;
	/* time to send a packet again? */
	if(unlikely(local_time_now < (connec->u.handler.send_stamps.LNI + (LNI_TIMEOUT))))
		return ret_val;

	return g2_packet_add_LNI(parg->connec);
}

static bool handle_LNI_HS(struct ptype_action_args *parg)
{
	g2_connection_t *connec = parg->connec;
	g2_packet_t *source = parg->source;
	uint16_t akt_leaf = 0, max_leaf = 0;
	size_t rem = buffer_remaining(source->data_trunk);

	/* we can not read any info in this case */
	if(likely(skip_unexpected_child(source, "/LNI/HS")))
	{
		/* sometimes Shareaza only sends 2 bytes, thats only the leaf count */
		if(2 <= rem)
			get_unaligned_endian(akt_leaf, (uint16_t *) buffer_start(source->data_trunk), source->big_endian);
		if(4 <= rem)
			get_unaligned_endian(max_leaf, (uint16_t *) (buffer_start(source->data_trunk)+2), source->big_endian);

		connec->u.handler.leaf_count = akt_leaf;
		logg_packet_old("/LNI/HS:\told: %s leaf: %u max: %u\n",
				connec->flags.upeer ? G2_TRUE : G2_FALSE, akt_leaf, max_leaf);
	}

	/* when we get a HS with 0 leafs, ignore it */
	if(!akt_leaf)
		return false;

	if(!connec->flags.upeer) {
		connec->flags.upeer = true;
		if(!g2_conreg_promote_hub(connec))
			connec->flags.dismissed = true;
		/* connection is now a hub, remove from QHTs */
		g2_conreg_mark_dirty(connec);
	}
	connec->flags.upeer = true;
	((struct LNI_data *)(parg->opaque))->had_LNI_HS = true;

	return false;
}

static bool handle_LNI_GU(struct ptype_action_args *parg)
{
	if(unlikely(!skip_unexpected_child(parg->source, "/LNI/GU")))
		return false;

	if(sizeof(parg->connec->guid) == buffer_remaining(parg->source->data_trunk)) {
		memcpy(parg->connec->guid, buffer_start(parg->source->data_trunk), sizeof(parg->connec->guid));
		((struct LNI_data *)(parg->opaque))->had_LNI_GU = true;
	}
	else
		logg_packet(STDLF, "/LNI/GU", "GU not a valid GUID");

	return false;
}

static bool handle_LNI_FW(struct ptype_action_args *parg)
{
	logg_packet_old("/LNI/FW\t\tlen: %zu\n", buffer_remaining(parg->source->data_trunk));
	parg->connec->flags.firewalled = true;
	((struct LNI_data *)(parg->opaque))->had_LNI_FW = true;
	return false;
}

static bool handle_LNI_QK(struct ptype_action_args *parg)
{
	logg_packet_old("/LNI/QK\t\tlen: %zu\n", buffer_remaining(parg->source->data_trunk));
	parg->connec->flags.query_key_cache = true;
	((struct LNI_data *)(parg->opaque))->had_LNI_QK = true;
	return false;
}

static bool handle_LNI_RTR(struct ptype_action_args *parg)
{
	logg_packet_old("/LNI/RTR\t\tlen: %zu\n", buffer_remaining(parg->source->data_trunk));
	parg->connec->flags.router = true;
	((struct LNI_data *)(parg->opaque))->had_LNI_RTR = true;
	return false;
}

static bool handle_LNI_HA(struct ptype_action_args *parg)
{
	logg_packet_old("/LNI/HA\t\tlen: %zu\n", buffer_remaining(parg->source->data_trunk));
	parg->connec->flags.hub_able = true;
	((struct LNI_data *)(parg->opaque))->had_LNI_HA = true;
	return false;
}

static bool handle_LNI_NA(struct ptype_action_args *parg)
{
	if(unlikely(!skip_unexpected_child(parg->source, "/LNI/NA")))
		return false;

	read_na_from_packet(parg->source, &parg->connec->sent_addr, "/LNI/NA");
	return false;
}

static bool handle_LNI_V(struct ptype_action_args *parg)
{
	g2_connection_t *connec = parg->connec;
	g2_packet_t *source = parg->source;
	size_t min_length;

	if(unlikely(!skip_unexpected_child(source, "/LNI/V")))
		return false;

	min_length =
		(buffer_remaining(source->data_trunk) < (sizeof(connec->vendor_code)-1) ?
		buffer_remaining(source->data_trunk) : sizeof(connec->vendor_code)-1);
	memcpy(connec->vendor_code, buffer_start(source->data_trunk), min_length);
	connec->vendor_code[min_length] = '\0';

	logg_packet_old(STDLF, "\t/LNI/V", connec->vendor_code);
	
	return false;
}

struct PI_data
{
	union combo_addr addr;
	bool addr_valid;
	bool relay;
};

static intptr_t PI_callback(g2_connection_t *con, void *carg)
{
	struct ptype_action_args *parg;
	struct PI_data *rdata;
	g2_packet_t *pi, *udp, *relay;

	parg = carg;
	rdata = parg->opaque;
	/*
	 * The connection is locked against removal inside this callback
	 * (but because of this we do not want to lock to long, we have
	 * a whole hash slot locked in the conreg...).
	 * But there may be further locking needed.
	 */

	/*
	 * we simply rebuild the packet, this way we can avoid
	 * to add a child packet to a raw packet. We may loose
	 * unknown/untypical childs by this.
	 */
	pi    = g2_packet_calloc();
	udp   = g2_packet_calloc();
	relay = g2_packet_calloc();

	if(!(pi && udp && relay))
		goto out_fail;

	udp->type = PT_UDP;
	/* buffers are now large enough, should not fail */
	if(!write_na_to_packet(udp, &rdata->addr))
		goto out_fail;

	relay->type = PT_RELAY;
	relay->big_endian = HOST_IS_BIGENDIAN;

	list_add_tail(&udp->list, &pi->children);
	list_add_tail(&relay->list, &pi->children);

	pi->type = PT_PI;
	pi->big_endian = HOST_IS_BIGENDIAN;

	/*
	 * MB:
	 * the spinlock in con_mark_write should barrier our doings
	 */
	g2_handler_con_mark_write(pi, con);
	return 0;

out_fail:
	g2_packet_free(pi);
	g2_packet_free(udp);
	g2_packet_free(relay);
	return 0;
}

static bool handle_PI(struct ptype_action_args *parg)
{
	struct PI_data rdata;
	g2_packet_t *source = parg->source;
	g2_connection_t *connec = parg->connec;
	bool ret_val = false;

	/* not simple /PI-packet? */
	rdata.addr_valid = false;
	rdata.relay = false;
	if(source->is_compound)
	{
		struct ptype_action_args cparg;
		bool keep_decoding;

		cparg = *parg;
		cparg.father = source;
		cparg.opaque = &rdata;
		do
		{
			g2_packet_t child_p;
			cparg.source = &child_p;
			child_p.more_bytes_needed = false;
			child_p.packet_decode = CHECK_CONTROLL_BYTE;
			keep_decoding = g2_packet_decode_from_packet(source, &child_p, 0);
			if(!keep_decoding) {
				logg_packet(STDLF, "PI", "broken child");
				if(connec)
					connec->flags.dismissed = true;
				break;
			}
			if(likely(child_p.packet_decode == DECODE_FINISHED))
				ret_val |= g2_packet_decide_spec_int(&cparg, PI_packet_dict);
		} while(keep_decoding && source->packet_decode != DECODE_FINISHED);

		if(source->packet_decode != DECODE_FINISHED)
			return ret_val;

		/* broken packet? punish sender */
		if(connec && rdata.relay && !rdata.addr_valid) {
			connec->flags.dismissed = true;
			return ret_val;
		}
	}

	/* tcp connection and not a relay request? */
	if(connec && !rdata.addr_valid) {
		/* check if time to send a packet again? */
		if(local_time_now < (connec->u.handler.send_stamps.PI + (PI_TIMEOUT)))
			goto out_ok;
	}

	/* from a tcp connection and a udp addr? */
	if(connec && rdata.addr_valid)
	{
		/* should we answer, or relay it */
		if(rdata.relay)
		{
			union combo_addr from_addr;
			struct list_head answer;
			g2_packet_t po, relay;
			socklen_t sin_size = sizeof(from_addr);

			casalen_ib(&from_addr);
			/* send the udp answer from the ip we received the request */
			if(unlikely(getsockname(connec->com_socket, casa(&from_addr), &sin_size))) {
				logg_errno(LOGF_DEBUG, "getting local addr of socket");
				/* this is really just a (broken) fallback, this should not happen */
				from_addr = AF_INET == connec->remote_host.s.fam ?
				            server.settings.bind.ip4.a[0] : server.settings.bind.ip6.a[0];
			}

			INIT_LIST_HEAD(&answer);
			g2_packet_init_on_stack(&po);
			g2_packet_init_on_stack(&relay);

			po.type = PT_PO;
			po.big_endian = HOST_IS_BIGENDIAN;
			relay.type = PT_RELAY;
			relay.big_endian = HOST_IS_BIGENDIAN;
			list_add_tail(&relay.list, &po.children);
			list_add_tail(&po.list, &answer);

// TODO: VALGRIND - uninitilaized? WTF? What?
			g2_udp_send(&rdata.addr, &from_addr, &answer);
		}
		else {
			parg->opaque = &rdata;
			ret_val |= !!g2_conreg_all_hub(&connec->remote_host, PI_callback, parg);
		}
	}
	else
	{
		g2_packet_t *po = g2_packet_calloc();
		if(!po) {
			logg_packet(STDLF, "\t/PI", "alloc failed");
			return ret_val;
		}
		po->type = PT_PO;
		po->big_endian = HOST_IS_BIGENDIAN;

		g2_packet_add2target(po, parg->target, parg->target_lock);
		if(connec) {
			connec->u.handler.z_flush = true; /* make sure the PO goes on the wire */
			connec->u.handler.send_stamps.PI = local_time_now;
		}
		ret_val = true;
	}

out_ok:
	if(connec)
		connec->flags.last_data_active = true;
	return ret_val;
}

static bool handle_PI_UDP(struct ptype_action_args *parg)
{
	struct PI_data *rdata = parg->opaque;

	logg_packet_old(STDSF, "/PI/UDP");
	if(unlikely(!skip_unexpected_child(parg->source, "/PI/UDP")))
		return false;

	rdata->addr_valid =
		read_na_from_packet(parg->source, &rdata->addr, "/PI/UDP");
	return false;
}

static bool handle_PI_RELAY(struct ptype_action_args *parg)
{
	struct PI_data *rdata = parg->opaque;

	logg_packet_old(STDSF, "/PI/RELAY");
	rdata->relay = true;
	return false;
}

static bool handle_PO(struct ptype_action_args *parg)
{
	parg->connec->flags.last_data_active = true;
	return false;
}

struct Q2_data
{
	union combo_addr udp_na;
	uint32_t qk;
	char *metadata;
	size_t metadata_len;
	char *dn;
	size_t dn_len;
	uint8_t *s_guid;
	g2_packet_t *qa;
	bool had_urn;
	bool had_hurn;
	bool udp_na_valid;
	bool qk_valid;
};

intptr_t g2_packet_leaf_qht_match(g2_connection_t *con, void *data)
{
	struct ptype_action_args *parg = data;
	g2_packet_t *t, *source = parg->source;

	t = g2_packet_clone(source);
	if(!t)
		return 0;

	/* if we have a datatrunk, inc refcnt */
	if(source->data_trunk_is_freeable) {
		struct packet_data_store *pds =
			container_of(source->data_trunk.data,
			             struct packet_data_store, data);
		atomic_inc(&pds->refcnt);
	} else {
		/* data in packet buffer? Adjust */
		if(source->data_trunk.data >= source->pd.out &&
		   source->data_trunk.data < &source->pd.out[sizeof(source->pd.out)]) {
			ptrdiff_t diff = source->data_trunk.data - source->pd.out;
			t->data_trunk.data = &t->pd.out[diff];
		}
		else
		{
			/*
			 * data still lingers in the recv buff, we have to copy it
			 * this should not happen, higher levels should have fixed things
			 */
			if(!g2_packet_steal_data_space_lit(t, buffer_remaining(source->data_trunk))) {
				g2_packet_free(t);
				return 0;
			}
			my_memcpy(buffer_start(t->data_trunk), buffer_start(source->data_trunk),
			          buffer_remaining(source->data_trunk));
		}
	}
	t->is_literal = true;
	/*
	 * MB:
	 * the spinlock in con_mark_write should barrier our doings
	 */
	g2_handler_con_mark_write(t, con);
	return 0;
}

intptr_t g2_packet_hub_qht_match(g2_connection_t *con, void *data)
{
	struct ptype_action_args *parg = data;
	g2_packet_t *t, *source = parg->source;

	t = g2_packet_clone(source);
	if(!t)
		goto out;

	/* if we have a datatrunk, inc refcnt */
	if(source->data_trunk_is_freeable) {
		struct packet_data_store *pds =
			container_of(source->data_trunk.data,
			             struct packet_data_store, data);
		atomic_inc(&pds->refcnt);
	} else {
		/* data in packet buffer? Adjust */
		if(source->data_trunk.data >= source->pd.out &&
		   source->data_trunk.data < &source->pd.out[sizeof(source->pd.out)]) {
			ptrdiff_t diff = source->data_trunk.data - source->pd.out;
			t->data_trunk.data = &t->pd.out[diff];
		}
		else
		{
			/*
			 * data still lingers in the recv buff, we have to copy it
			 * this should not happen, higher levels should have fixed things
			 */
			if(!g2_packet_steal_data_space_lit(t, buffer_remaining(source->data_trunk))) {
				g2_packet_free(t);
				goto out;
			}
			my_memcpy(buffer_start(t->data_trunk), buffer_start(source->data_trunk),
			          buffer_remaining(source->data_trunk));
		}
	}
	t->is_literal = true;
	/*
	 * MB:
	 * the spinlock in con_mark_write should barrier our doings
	 */
	g2_handler_con_mark_write(t, con);
out:
	return g2_packet_hub_qht_done(con, data);
}

intptr_t g2_packet_hub_qht_done(g2_connection_t *con, void *data)
{
	struct ptype_action_args *parg = data;
	struct Q2_data *rdata = parg->opaque;
	g2_packet_t *d = g2_packet_calloc();

	if(!d)
		return 0;

	if(fill_d_packet(d, &con->sent_addr, con->u.handler.leaf_count))
		list_add_tail(&d->list, &rdata->qa->children);
	else
		g2_packet_free(d);

	return 0;
}

bool g2_packet_search_finalize(uint32_t hashes[], size_t num, void *data, bool hubs)
{
	struct ptype_action_args *parg = data;
	struct Q2_data *rdata = parg->opaque;
	g2_packet_t *qa, *d, *ts, *source = parg->source;
	union combo_addr *our_addr = NULL, backup_addr;

	qa = g2_packet_calloc();
	d  = g2_packet_calloc();
	ts = g2_packet_calloc();

	if(!(qa && d && ts))
		goto out_fail_free_all;

	if(parg->connec)
	{
		socklen_t sin_size = sizeof(backup_addr);
		casalen_ib(&backup_addr);
		/*
		 * get our ip the remote host connected to from
		 * our socket handle
		 */
		if(unlikely(getsockname(parg->connec->com_socket, casa(&backup_addr), &sin_size))) {
			logg_errno(LOGF_DEBUG, "getting local addr of socket");
			/* this is really just a (broken) fallback, this should not happen */
			our_addr = AF_INET == parg->connec->remote_host.s.fam ?
			           &server.settings.bind.ip4.a[0] : &server.settings.bind.ip6.a[0];
		}
		else
			our_addr = &backup_addr;
	}
	else
		our_addr = parg->dst_addr;
	if(!our_addr)
		return false;

	if(source->data_trunk_is_freeable) {
	/*
	 * We already have a datatrunk, thats fine, but we have to
	 * remove it later from the source
	 */
	} else {
		if(source->data_trunk.data >= source->pd.out &&
		   source->data_trunk.data < &source->pd.out[sizeof(source->pd.out)]) {
			/* the data is in the packet buffer, thats also fine */
		}
		else
		{
			struct pointer_buff pb = source->data_trunk;
			/* data still lingers in the recv buff, we have to copy it */
			if(!g2_packet_steal_data_space_lit(source, buffer_remaining(pb)))
				goto out_fail_free_all;
			my_memcpy(buffer_start(source->data_trunk), buffer_start(pb),
			          buffer_remaining(pb));
		}
	}

	if(!fill_d_packet(d, our_addr, atomic_read(&server.status.act_connection_sum)))
		goto out_fail_free_all;

	ts->type   = PT_TS;
	/* should not fail, we should have enough space */
	if(likely(g2_packet_steal_data_space(ts, sizeof(time_t))))
	{
		time_t now = local_time_now;
		put_unaligned(now, (time_t *)(buffer_start(ts->data_trunk)));
		ts->big_endian = HOST_IS_BIGENDIAN;
	}
	else
		goto out_fail_free_all;

	if(!g2_packet_steal_data_space(qa, 16))
		goto out_fail_free_all;

	list_add_tail(&ts->list, &qa->children);
	list_add_tail(&d->list, &qa->children);
	qa->type = PT_QA;
	qa->big_endian = HOST_IS_BIGENDIAN;
	memcpy(buffer_start(qa->data_trunk), rdata->s_guid, 16);

	/*
	 * Do the search!
	 */
	rdata->qa = qa;
	if(hubs)
		g2_qht_match_hubs(hashes, num, data);
	g2_qht_match_leafs(hashes, num, data);

	{
		struct khl_entry khle[6];
		size_t res;

		/* start by adding a truck load of KHL */
		res = g2_khl_fill_p(khle, anum(khle), parg->connec ?
		                    parg->connec->remote_host.s.fam : parg->src_addr->s.fam);
		while(res--)
		{
			g2_packet_t *s = g2_packet_calloc();

			if(!s)
				break;
			s->type = PT_S;
			if(!write_nats_to_packet(s, &khle[res].na, khle[res].when)) {
				g2_packet_free(s);
				break;
			}
			list_add_tail(&s->list, &qa->children);
		}
// TODO: add some cluster hubs
	}

	/* if our source had a buffer, remove it now */
	if(source->data_trunk_is_freeable) {
		struct packet_data_store *pds =
			container_of(source->data_trunk.data,
			             struct packet_data_store, data);
		source->data_trunk.data = NULL;
		source->data_trunk.pos = source->data_trunk.limit = source->data_trunk.capacity = 0;
		source->data_trunk_is_freeable = false;
		if(atomic_dec_test(&pds->refcnt))
			free(pds);
	}

	if(parg->connec)
	{
		if(rdata->udp_na_valid &&
		   !combo_addr_eq_ip(&rdata->udp_na, &parg->connec->remote_host))
		{
			union combo_addr from_addr;
			struct list_head answer;
			socklen_t sin_size = sizeof(from_addr);

			casalen_ib(&from_addr);
			/* send the udp answer from the ip we received the request */
			if(unlikely(getsockname(parg->connec->com_socket, casa(&from_addr), &sin_size))) {
				logg_errno(LOGF_DEBUG, "getting local addr of socket");
				/* this is really just a (broken) fallback, this should not happen */
				from_addr = AF_INET == parg->connec->remote_host.s.fam ?
				            server.settings.bind.ip4.a[0] : server.settings.bind.ip6.a[0];
			}
			INIT_LIST_HEAD(&answer);
			list_add_tail(&qa->list, &answer);
			g2_udp_send(&rdata->udp_na, &from_addr, &answer);
			return false;
		}
		else
			g2_packet_add2target(qa, parg->target, parg->target_lock);
	}
	else
	{
		if(!combo_addr_eq(&rdata->udp_na, parg->src_addr))
		{
			struct list_head answer;
			INIT_LIST_HEAD(&answer);
			list_add_tail(&qa->list, &answer);
			g2_udp_send(&rdata->udp_na, parg->dst_addr, &answer);
			return false;
		}
		else
			g2_packet_add2target(qa, parg->target, parg->target_lock);
	}
	return true;

out_fail_free_all:
	g2_packet_free(d);
	g2_packet_free(ts);
	g2_packet_free(qa);
	return false;
}

static bool handle_Q2(struct ptype_action_args *parg)
{
	struct Q2_data rdata;
	struct ptype_action_args cparg;
	size_t old_pos = parg->source->data_trunk.pos;
	bool ret_val = false, keep_decoding;

	if(!parg->source->is_compound)
		return ret_val;

	if(parg->connec)
	{
		time_t old_stamp = parg->connec->u.handler.recv_stamps.Q2;
		parg->connec->u.handler.recv_stamps.Q2 = local_time_now;
		/* query limit non ultrapeers */
		if(!parg->connec->flags.upeer)
		{
			/*
			 * this timeout should be _very_ short, we are OK with
			 * beeing queried, but we do not want to get flooded.
			 * 1 query per second is still a lot, but prevents to pump
			 * queries at full line speed
			 */
			if(old_stamp >= (local_time_now - Q2_T_TIMEOUT))
				return ret_val;
		}
		else
		{
			/* maybe not more than 100 queries per second? */
		}
	}

	if(!g2_qht_search_prepare())
		return ret_val;

	memset(&rdata.metadata, 0, sizeof(struct Q2_data) - offsetof(struct Q2_data, metadata));
	cparg = *parg;
	cparg.father = parg->source;
	cparg.opaque = &rdata;
	do
	{
		g2_packet_t child_p;
		cparg.source = &child_p;
		child_p.more_bytes_needed = false;
		child_p.packet_decode = CHECK_CONTROLL_BYTE;
		keep_decoding = g2_packet_decode_from_packet(parg->source, &child_p, 0);
		if(!keep_decoding) {
			logg_packet(STDLF, "Q2", "broken child");
			if(parg->connec)
				parg->connec->flags.dismissed = true;
			return ret_val;
		}
		if(child_p.packet_decode == DECODE_FINISHED)
			ret_val |= g2_packet_decide_spec_int(&cparg, Q2_packet_dict);
	} while(keep_decoding && parg->source->packet_decode != DECODE_FINISHED);

	if(16 < buffer_remaining(parg->source->data_trunk)) {
		logg_packet(STDLF, "Q2", "no guid?");
		return ret_val;
	}

	rdata.s_guid = (uint8_t *)buffer_start(parg->source->data_trunk);
	if(parg->connec)
	{
		parg->connec->flags.last_data_active = true;

		if(!parg->connec->flags.upeer && rdata.udp_na_valid &&
		   !combo_addr_eq_ip(&parg->connec->remote_host, &rdata.udp_na))
			return ret_val;
		if(rdata.udp_na_valid && !combo_addr_is_public(&rdata.udp_na))
			return ret_val;

		if(g2_guid_add(rdata.s_guid,
		               rdata.udp_na_valid ? &rdata.udp_na : &parg->connec->remote_host,
		               local_time_now, GT_QUERY))
			return ret_val;

		/* rewind buffer for forwarding */
		parg->source->data_trunk.pos = old_pos;
		parg->opaque = &rdata;
		ret_val =
			g2_qht_search_drive(rdata.metadata, rdata.metadata_len, rdata.dn,
			                    rdata.dn_len, parg, rdata.had_urn,
			                    !parg->connec->flags.upeer); /* leafs only or hubs & leafs */
	}
	else
	{
		if(!(rdata.udp_na_valid && rdata.qk_valid && combo_addr_is_public(&rdata.udp_na)))
			return ret_val;

		if(!g2_qk_check(&rdata.udp_na, rdata.qk)) {
// TODO: prevent UDP query flooding from single IP
			g2_packet_send_qka(&rdata.udp_na, parg->src_addr, parg->dst_addr);
			return ret_val;
		}
// TODO: prevent UDP query flooding from single IP
		/*
		 * To prevent getting flooded and flood other, we need to
		 * filter to many queries from the same IP by UDP.
		 * The problem is: G2CD is better off with processing them
		 * then building some expensive, unbounded, lock contended
		 * filter.
		 * This is UDP, everyone with a valid querykey can query us.
		 * So the filter has scale with the whole IP space.
		 *
		 * And in the end this is all mood, some idiot with a botnet
		 * could still run amok...
		 */

		if(g2_guid_add(rdata.s_guid, &rdata.udp_na, local_time_now, GT_QUERY))
		{
			/* already in the cache */
			g2_packet_t qa, d;
			struct list_head answer;
			union combo_addr *our_addr;

			our_addr = parg->dst_addr;
			if(!our_addr)
				return ret_val;

			g2_packet_init_on_stack(&d);
			if(!fill_d_packet(&d, our_addr, 0))
				return ret_val;

			g2_packet_init_on_stack(&qa);
			if(!g2_packet_steal_data_space(&qa, 16)) {
				g2_packet_free(&d);
				return ret_val;
			}

			list_add_tail(&d.list, &qa.children);
			qa.type = PT_QA;
			qa.big_endian = HOST_IS_BIGENDIAN;
			memcpy(buffer_start(qa.data_trunk),
			       buffer_start(parg->source->data_trunk), 16);

			INIT_LIST_HEAD(&answer);
			list_add_tail(&qa.list, &answer);
			g2_udp_send(&rdata.udp_na, parg->dst_addr, &answer);
			return ret_val;
		}

		/* rewind buffer for forwarding */
		parg->source->data_trunk.pos = old_pos;
		parg->opaque = &rdata;
		ret_val =
			g2_qht_search_drive(rdata.metadata, rdata.metadata_len, rdata.dn,
			                    rdata.dn_len, parg, rdata.had_urn, true); /* hubs & leafs */
	}

	return ret_val;
}

static bool handle_Q2_UDP(struct ptype_action_args *parg)
{
	struct Q2_data *rdata = parg->opaque;
	g2_packet_t *source = parg->source;
	char *data;
	size_t remaining;

	if(unlikely(!skip_unexpected_child(source, "/Q2/UDP")))
		return false;

	remaining = buffer_remaining(source->data_trunk);

	if( 6 != remaining && /* IPv4 */
	   10 != remaining && /* IPv4 + key */
	   18 != remaining && /* IPv6 */
	   22 != remaining    /* IPv6 + key */) {
	   logg_packet("/Q2/UDP -> funny length! len: %zu\n", remaining);
		return false;
	}

	if(10 == remaining ||
	   22 == remaining) {
		data = buffer_start(source->data_trunk) + remaining - 4;
		get_unaligned_endian(rdata->qk, (uint32_t *)data, source->big_endian);
		source->data_trunk.limit -= 4;
		rdata->qk_valid = true;
	}

	rdata->udp_na_valid =
		read_na_from_packet(source, &rdata->udp_na, "/Q2/UDP");
	if(rdata->udp_na_valid && combo_addr_eq_any(&rdata->udp_na)) {
		if(parg->src_addr)
			memcpy(&rdata->udp_na, parg->src_addr, sizeof(rdata->udp_na));
		else
			rdata->udp_na_valid = false;
	}
	return false;
}

static bool handle_Q2_QKY(struct ptype_action_args *parg)
{
	struct Q2_data *rdata = parg->opaque;
	g2_packet_t *source = parg->source;

	if(unlikely(!skip_unexpected_child(source, "/Q2/QKY")))
		return false;

	if(4 != buffer_remaining(source->data_trunk)) {
		logg_packet(STDLF, "/Q2/QKY", "funny length");
		return false;
	}

	get_unaligned_endian(rdata->qk, (uint32_t *)buffer_start(source->data_trunk), source->big_endian);
	rdata->qk_valid = true;

	if(!rdata->udp_na_valid) {
		if(parg->src_addr) {
			memcpy(&rdata->udp_na, parg->src_addr, sizeof(rdata->udp_na));
			rdata->udp_na_valid = true;
		}
	}
	else if(combo_addr_eq_any(&rdata->udp_na)) {
		if(parg->src_addr)
			memcpy(&rdata->udp_na, parg->src_addr, sizeof(rdata->udp_na));
		else
			rdata->udp_na_valid = false;
	}
	return false;
}

static bool handle_Q2_URN(struct ptype_action_args *parg)
{
	struct Q2_data *rdata = parg->opaque;
	g2_packet_t *source = parg->source;
	char *urn = buffer_start(source->data_trunk);
	unsigned char *hash;
	size_t remaining = buffer_remaining(source->data_trunk);
	size_t len;

	/* disregard if we already had a hashed urn */
	if(rdata->had_hurn)
		return false;
	/*
	 * even if we had an urn we do not understand, no
	 * dn && md processing
	 */
	rdata->had_urn = true;

	/*
	 * We have a zero terminated string which describes the URN type
	 * and the binary data representing the urn, split it.
	 */
	len = strnlen(urn, remaining);
	if(unlikely(len < 2 || len + 1 >= remaining))
		return false;

	source->data_trunk.pos += len + 1;
	remaining = buffer_remaining(source->data_trunk);
	if(unlikely(20 != remaining && /* sha1 && btih */
	            44 != remaining && /* bp */
	            24 != remaining && /* ttr */
	            16 != remaining))  /* md5 && ed2k */
		return false;

	hash = (unsigned char *)buffer_start(source->data_trunk);
	if(likely(len <= 4))
	{
		/*
		 * All the short URN type names are wastefull to test with
		 * a chain of strcmp's, do a little magic.
		 */
		uint32_t type = 0;

		/*
		 * Now it gets tricky...
		 * We create the URN type strings with a macro to
		 * get a 32 Bit number. This way we can compare full
		 * 4 bytes at a time. We already switch to native
		 * endianess. This should create a nice compile
		 * time constant.
		 */
#define MAKE_TYPE(a, b, c, d) \
	ntohl((((uint32_t)(a)) << 24) | \
	      (((uint32_t)(b)) << 16) | \
	      (((uint32_t)(c)) <<  8) | \
	      (((uint32_t)(d)) <<  0))
		/*
		 * The test is a little "freaky"...
		 * We first check that our type-to-test does
		 * not introduce additional bits, then we test
		 * that if we use our type-to-test as mask, we
		 * do not have bits missing.
		 * This should give equallity, while masking out
		 * excess info (check only for 2 or 3 bytes matching
		 * in 4 bytes, thanks to 0 in the MAKE_TYPE).
		 * These should be all simple opertions with constants.
		 */
#define MAKE_TEST(a, b, c, d, t) \
	(((MAKE_TYPE(a, b, c, d) | t) == t) && ((MAKE_TYPE(a, b, c, d) & t) == MAKE_TYPE(a, b, c, d)))

		/* Get complete 4 bytes at the beginning */
		type = get_unaligned((uint32_t *)urn);
		/* Mask out any info behind the type */
		if(HOST_IS_BIGENDIAN)
			type &= (uint32_t)0xFFFFFFFF << ((4 - len) * 8);
		else
			type &= (uint32_t)0xFFFFFFFF >> ((4 - len) * 8);

		/* if type and total length matches, add it */
		if(MAKE_TEST('s', 'h', 'a', '1', type) && 20 == remaining)
			g2_qht_search_add_sha1(hash);
		else if(MAKE_TEST('b', 'p',  0 ,  0 , type) && 44 == remaining)
		{
handle_bitprint:
			g2_qht_search_add_sha1(hash);
			hash += 20;
			g2_qht_search_add_ttr(hash);
		}
		else if(MAKE_TEST('t', 't', 'r',  0 , type) && 24 == remaining)
			g2_qht_search_add_ttr(hash);
		else if(MAKE_TEST('e', 'd', '2', 'k', type) && 16 == remaining)
			g2_qht_search_add_ed2k(hash);
		else if(MAKE_TEST('b', 't', 'i', 'h', type) && 20 == remaining)
			g2_qht_search_add_bth(hash);
		else if(MAKE_TEST('m', 'd', '5',  0 , type) && 16 == remaining)
			g2_qht_search_add_md5(hash);
#undef MAKE_TYPE
	}
	else
	{
		/* the long names are few and simply tested */
		if(44 == remaining && !strlitcmp(urn, "bitprint"))
			goto handle_bitprint;
		else if(24 == remaining && !strlitcmp(urn, "tree:tiger/"))
			g2_qht_search_add_ttr(hash);
	}

	return false;
}

static bool handle_Q2_DN(struct ptype_action_args *parg)
{
	struct Q2_data *rdata = parg->opaque;
	g2_packet_t *source = parg->source;

	if(unlikely(!skip_unexpected_child(source, "/Q2/DN")))
		return false;

	rdata->dn_len = buffer_remaining(source->data_trunk);
	rdata->dn     = buffer_start(source->data_trunk);
	logg_develd_old("/Q2/DN - %zu \"%.*s\"\n", rdata->dn_len, (int)rdata->dn_len, rdata->dn);
	return false;
}

static bool handle_Q2_MD(struct ptype_action_args *parg)
{
	struct Q2_data *rdata = parg->opaque;
	g2_packet_t *source = parg->source;

	if(unlikely(!skip_unexpected_child(source, "/Q2/MD")))
		return false;

	rdata->metadata_len = buffer_remaining(source->data_trunk);
	rdata->metadata     = buffer_start(source->data_trunk);
	return false;
}

static bool handle_Q2_HURN(struct ptype_action_args *parg)
{
	struct Q2_data *rdata = parg->opaque;
	g2_packet_t *source = parg->source;
	char *hptr;
	size_t len;
	uint32_t hurn;

	/*
	 * a hashed URN, the client already has done the "hash
	 * the hash" dance for us, we can add this directly to
	 * our list
	 */
	/*
	 * even if we had an urn we do not understand, no
	 * dn && md processing
	 */
	rdata->had_urn = true;
	if(unlikely(!skip_unexpected_child(source, "/Q2/HURN")))
		return false;
	len = buffer_remaining(source->data_trunk);
	if(!(len / 4))
		return false;
	rdata->had_hurn = true; /* prevent URNs from being processed */
	hptr = buffer_start(source->data_trunk);
	for(len /= 4; len; len--, hptr += 4) {
		get_unaligned_endian(hurn, (uint32_t *)hptr, source->big_endian);
		g2_qht_search_add_hash(hurn);
	}
	return false;
}

static bool handle_Q2_HKEY(struct ptype_action_args *parg)
{
	struct Q2_data *rdata = parg->opaque;
	g2_packet_t *source = parg->source;
	char *hptr;
	size_t len;
	uint32_t hkey;

	/*
	 * hashed keywords, the client already has done the "hash
	 * the search text" dance for us, we can add this directly
	 * to our list
	 */
	if(unlikely(!skip_unexpected_child(source, "/Q2/HKEY")))
		return false;
	len = buffer_remaining(source->data_trunk);
	if(!(len / 4))
		return false;
	/* with this we prevent processing of DN & MD */
	rdata->had_urn = true;
	hptr = buffer_start(source->data_trunk);
	for(len /= 4; len; len--, hptr += 4) {
		get_unaligned_endian(hkey, (uint32_t *)hptr, source->big_endian);
		g2_qht_search_add_hash(hkey);
	}
	return false;
}

struct QA_data
{
	struct ptype_action_args *parg;
	long td;
	bool td_valid;
	bool had_from;
};

static intptr_t forward_inject_fr(g2_connection_t *con, void *carg)
{
	struct QA_data *rdata = carg;
	struct ptype_action_args *parg = rdata->parg;
	g2_packet_t fr, *source = parg->source;
	struct pointer_buff o_buf;
	size_t len, o_pos, o_limit;
	ssize_t result;

	/*
	 * Till now i didn't see a QA with a from, but if it's there, it may be
	 * some grand sheme of packet routing/NATed bullshit going on.
	 * This means that the FR may be bogus, but we can do nothing about it.
	 * And changing it makes things for ligit use horrible.
	 * Simply keep it.
	 */
	if(unlikely(rdata->had_from))
		return forward_lit_callback_ignore(con, rdata->parg);

	/*
	 * Now we have a problem, we have to inject an additional packet
	 * into an already existing packet for forwarding.
	 * This is a nightmare for g2cd, since we do not take apart all
	 * packets and childs and subchilds and etc., if we don't know
	 * or need them.
	 * This is by purpose!
	 * And we do not tmp. store packets in a general "all"-parsed state.
	 * This is also by purpose!
	 * Packets which should be replicated simply get "reinjected". We
	 * reconstruct the outer most packet (which we had to touch anyway
	 * to wade through the packet stream) from our info, the rest
	 * (childs, payload) is literate data.
	 *
	 * So dirty hacks, here we go...
	 * In the case of an QA, we know it has childs, we can simply
	 * encode another packet in front of the binary blob of QA data.
	 */
	g2_packet_init_on_stack(&fr);
	if(parg->connec) /* did it come from TCP? */
		link_sna_to_packet(&fr, &parg->connec->remote_host);
	else { /* use write to set port */
		/* make sure we use the source packets endianess, Shareaza only uses the root packets bit */
		if(!write_sna_to_packet_endian(&fr, parg->src_addr, source->big_endian))
			return forward_lit_callback_ignore(con, rdata->parg); /* if we couldn't get the space, forward anyway */
	}
	fr.type = PT_FR;
	result = g2_packet_serialize_prep_min(&fr);
	if(-1 == result)
		goto out;

	/* now it gets hairy, we have to take the orig data and add our fr */
	len = buffer_remaining(source->data_trunk);
	/*
	 * we already made sure there is a child packet, no need to inject a
	 * child seperator by hand or set is_compound
	 */
	len += result;
	/* copy the original buffer stuff */
	o_buf = source->data_trunk;
	if(unlikely(source->data_trunk_is_freeable)) /* is it an allocated buffer? */
	{
		struct packet_data_store *pds =
			container_of(o_buf.data, struct packet_data_store, data);

		if(!g2_packet_steal_data_space(source, len))
			goto out;

		my_memcpy(buffer_start(source->data_trunk) + result, buffer_start(o_buf),
		          buffer_remaining(o_buf));
		if(atomic_dec_test(&pds->refcnt))
			free(pds);
	}
	else
	{
		/* would the new data fit in the packet buffer and is the old data already there? Adjust */
		if(unlikely(len <= sizeof(source->pd.out) &&
		            source->data_trunk.data >= source->pd.out &&
		            source->data_trunk.data < &source->pd.out[sizeof(source->pd.out)])) {
			if(!g2_packet_steal_data_space(source, len))
				goto out;
			my_memmove(buffer_start(source->data_trunk) + result, buffer_start(o_buf),
			           buffer_remaining(o_buf));
		} else { /* data still lingers in the recv buff, we have to copy it */
			if(!g2_packet_steal_data_space(source, len))
				goto out;
			my_memcpy(buffer_start(source->data_trunk) + result, buffer_start(o_buf),
			          buffer_remaining(o_buf));
		}
	}
	o_pos = source->data_trunk.pos;
	o_limit = source->data_trunk.limit;
	source->data_trunk.limit = source->data_trunk.pos + result;
	/* we have made room for the fr, now we can put it there */
	g2_packet_serialize_to_buff_p(&fr, &source->data_trunk);
	source->data_trunk.pos = o_pos;
	source->data_trunk.limit = o_limit;
out:
	g2_packet_free(&fr);
	return forward_lit_callback_ignore(con, parg);
}

static bool handle_QA(struct ptype_action_args *parg)
{
	struct QA_data rdata;
	struct ptype_action_args cparg;
	union combo_addr dest;
	g2_packet_t *source = parg->source;
	uint8_t *guid;
	size_t old_pos;
	bool ret_val = false, keep_decoding;

	if(!source->is_compound)
		return ret_val;

	/*
	 * Kamikaze!
	 * We try to fish for the GUID which is the payload somewhere
	 * behind any childs, so we can match it to our cache, see if
	 * we want to parse the packet and trust its content.
	 */
	/* guid + 0 byte + shortest packet */
	if(GUID_SIZE + 1 + 3 > buffer_remaining(source->data_trunk)) {
		logg_packet(STDLF, "/QA", "to short");
		return ret_val;
	}

	guid = (uint8_t *)buffer_start(source->data_trunk) + (buffer_remaining(source->data_trunk) - GUID_SIZE);
	if(!g2_guid_lookup(guid, GT_QUERY, &dest)) {
		logg_develd_old("couldn't find guid %p#G from %p#I\n", guid, parg->connec ? &parg->connec->remote_host : parg->src_addr);
		return ret_val;
	}
	/* now we have established the packet is legit (with a high prop.) */

	old_pos = source->data_trunk.pos;
	rdata.td_valid = false;
	rdata.had_from = false;
	cparg = *parg;
	cparg.father = source;
	cparg.opaque = &rdata;
	do
	{
		g2_packet_t child_p;
		cparg.source = &child_p;
		child_p.more_bytes_needed = false;
		child_p.packet_decode = CHECK_CONTROLL_BYTE;
		keep_decoding = g2_packet_decode_from_packet(parg->source, &child_p, 0);
		if(!keep_decoding) {
			logg_packet(STDLF, "QA", "broken child");
			if(parg->connec)
				parg->connec->flags.dismissed = true;
			return ret_val;
		}
		if(child_p.packet_decode == DECODE_FINISHED)
			ret_val |= g2_packet_decide_spec_int(&cparg, QA_packet_dict);
	} while(keep_decoding && parg->source->packet_decode != DECODE_FINISHED);

	/*
	 * this should not happen, if it happens, someone
	 * had a funny plan, faking a guid and then creating
	 * some broken packet.
	 */
	if(16 != buffer_remaining(source->data_trunk))
		return ret_val;

	/* rewind buffer */
	source->data_trunk.pos = old_pos;

	if(parg->connec)
		parg->connec->flags.last_data_active = true;

	rdata.parg = parg;
	/* either target is connected or nothing */
	return (!!g2_conreg_for_addr(&dest, forward_inject_fr, &rdata)) | ret_val;
}

static bool handle_QA_FR(struct ptype_action_args *parg)
{
	struct QA_data *rdata = parg->opaque;

// TODO: check for length/private address? and drop complete QA if invalid
	rdata->had_from = true;
	return false;
}

static bool handle_QA_TS(struct ptype_action_args *parg)
{
	struct QA_data *rdata = parg->opaque;
	time_t foreign_time;
	time_t local_time;

	if(unlikely(!skip_unexpected_child(parg->source, "/QA/TS")))
		return false;

	local_time = local_time_now;

	if(read_ts_from_packet(parg->source, &foreign_time, "/QA/TS")) {
		logg_packet_old("/QA/TS -> %lu\t%lu\n", (unsigned long)foreign_time, (unsigned long)local_time);
		rdata->td = (long)local_time - (long)foreign_time;
		rdata->td_valid = true;
	}

	return false;
}

static bool handle_QA_D(struct ptype_action_args *parg)
{
	union combo_addr addr;
	size_t remaining = buffer_remaining(parg->source->data_trunk);

	if(unlikely(!skip_unexpected_child(parg->source, "/QA/D")))
		return false;

	/*
	 * some idiot thought it would be funny to cram data in
	 * here "on demand"...
	 * SAY NO TO WACKY BINARY PROTOCOLS!
	 * So we maybe only have an ip, ip + port, ip + port + leafs.
	 * Now mix in IPv6...
	 * Thank god we do not have a time stamp here...
	 */

	if( 6 + 2 != remaining &&
	   18 + 2 != remaining &&
	    6     != remaining &&
	   18     != remaining)
		return false;

	if( 6 + 2 == remaining ||
	   18 + 2 == remaining)
		parg->source->data_trunk.limit -= 2;

	if(read_na_from_packet(parg->source, &addr, "/QA/D"))
		g2_khl_add(&addr, local_time_now, false);

	return false;
}

static bool handle_QA_S(struct ptype_action_args *parg)
{
	union combo_addr addr;
	g2_packet_t *source = parg->source;
	size_t remaining = buffer_remaining(source->data_trunk);
	time_t when;
	struct QA_data *rdata = parg->opaque;

	if(unlikely(!skip_unexpected_child(parg->source, "/QA/S")))
		return false;

	if( 6     != remaining &&
	   18     != remaining &&
	    6 + 4 != remaining &&
	   18 + 4 != remaining &&
	    6 + 8 != remaining &&
	   18 + 8 != remaining)
		return false;

	when = local_time_now;
	if( 6  == remaining ||
	   18  == remaining) {
		if(!read_na_from_packet(source, &addr, "/QA/S"))
			return false;
	}
	else
	{
		if(!rdata->td_valid)
			return false;

		if(8 == sizeof(time_t))
			when &= (time_t)0xFFFFFFFF00000000ULL;
		else
			when  = 0;

		if( 6 + 4 == remaining || /* IPv4 */
		   18 + 4 == remaining    /* IPv6 */)
		{
			char *data = buffer_start(source->data_trunk) + remaining - 4;
			uint32_t t;
			get_unaligned_endian(t, (uint32_t *)data, source->big_endian);
			source->data_trunk.limit -= 4;
			when |= (time_t)(t + rdata->td);
		}
		else if(18 + 8 == remaining || /* IPv6 + 64Bit time_t */
		         6 + 8 == remaining    /*        64Bit time_t */)
		{
			char *data = buffer_start(source->data_trunk) + remaining - 8;
			uint64_t t;
			get_unaligned_endian(t, (uint64_t *)data, source->big_endian);
			source->data_trunk.limit -= 8;
			when = (time_t)(t + rdata->td);
		}

		if(!read_na_from_packet(source, &addr, "/QA/S"))
			return false;
	}

	g2_khl_add(&addr, when, false);
	return false;
}

struct QH2_data
{
	union combo_addr na;
	uint8_t *guid;
	bool na_valid;
};


static bool handle_QH2(struct ptype_action_args *parg)
{
	struct QH2_data rdata;
	struct ptype_action_args cparg;
	union combo_addr dest;
	g2_packet_t *source = parg->source;
	uint8_t *hop_count, *guid;
	size_t old_pos;
	bool ret_val = false, keep_decoding;

	if(!source->is_compound)
		return ret_val;

	/*
	 * Kamikaze!
	 * We try to fish for the GUID which is the payload somewhere
	 * behind any childs, so we can match it to our cache, see if
	 * we want to parse the packet and trust its content.
	 */
	/* hopcnt & guid + 0 byte + GU */
	if(1 + GUID_SIZE + 1 + 4 + 16 > buffer_remaining(source->data_trunk)) {
		logg_packet(STDLF, "/QH2", "to short");
		return ret_val;
	}

	guid = (uint8_t *)buffer_start(source->data_trunk) + buffer_remaining(source->data_trunk) - GUID_SIZE;
	if(!g2_guid_lookup(guid, GT_QUERY, &dest))
		return ret_val;
	/* now we have established the packet is legit (with a high prop.) */

	old_pos = source->data_trunk.pos;
	rdata.guid = NULL;
	rdata.na_valid = false;
	cparg = *parg;
	cparg.father = source;
	cparg.opaque = &rdata;
	do
	{
		g2_packet_t child_p;
		cparg.source = &child_p;
		child_p.more_bytes_needed = false;
		child_p.packet_decode = CHECK_CONTROLL_BYTE;
		keep_decoding = g2_packet_decode_from_packet(parg->source, &child_p, 0);
		if(!keep_decoding) {
			logg_packet(STDLF, "QH2", "broken child");
			if(parg->connec)
				parg->connec->flags.dismissed = true;
			return ret_val;
		}
		if(child_p.packet_decode == DECODE_FINISHED)
			ret_val |= g2_packet_decide_spec_int(&cparg, QH2_packet_dict);
	} while(keep_decoding && parg->source->packet_decode != DECODE_FINISHED);

	/*
	 * this should not happen, if it happens, someone
	 * had a funny plan, faking a guid and then creating
	 * some broken packet.
	 */
	if(17 != buffer_remaining(source->data_trunk) || !rdata.guid)
		return ret_val;

	if(!parg->connec)
	{
		/* for UDP they better send their address along */
		if(!rdata.na_valid)
			return ret_val;

		/* and it has to be valid */
		if(!combo_addr_is_public(&rdata.na) || !combo_addr_eq(&rdata.na, parg->src_addr))
			return ret_val;
	}

	hop_count = (uint8_t *)buffer_start(source->data_trunk);
	if(*hop_count >= 254)
		return ret_val;

	/* increment hop count */
	*hop_count += 1;

	/*
	 * We normaly would have to tear apart a fucking lot
	 * of this package to understand it.
	 * But we do not search, we do not need those infos.
	 *
	 * Only thing thats left is to decide if the packet
	 * is "good" or "bad".
	 *
	 * This includes parsing and frobnicating XML (ahhhh),
	 * looking over all Hits/HitGroups (alloc galore), only
	 * to have a glimpse idea that the packet is not uterly
	 * crap.
	 *
	 * When it is "good", we can use the guid, na, etc...
	 *
	 * At least all this checking would be beneficial not
	 * to forward junk.
	 */

	if(parg->connec)
		parg->connec->flags.last_data_active = true;

	/* rewind buffer */
	source->data_trunk.pos = old_pos;

	if(!g2_conreg_for_addr(&dest, forward_lit_callback_found, parg))
	{
		union combo_addr *from_addr, backup_addr;
		struct list_head answer, orig_list;
		bool orig_freeable, orig_dt_freeable;

		if(parg->connec)
		{
			socklen_t sin_size = sizeof(backup_addr);

			casalen_ib(&backup_addr);
			/* send the udp answer from the ip we received the request */
			if(unlikely(getsockname(parg->connec->com_socket, casa(&backup_addr), &sin_size))) {
				logg_errno(LOGF_DEBUG, "getting local addr of socket");
				/* this is really just a (broken) fallback, this should not happen */
				from_addr = AF_INET == parg->connec->remote_host.s.fam ?
				            &server.settings.bind.ip4.a[0] : &server.settings.bind.ip6.a[0];
			}
			else
				from_addr = &backup_addr;
		}
		else
			from_addr = parg->dst_addr;

		/* the source packet is only borrowed, do not free it... */
		orig_freeable = source->is_freeable;
		orig_dt_freeable = source->data_trunk_is_freeable;
		source->is_freeable = false;
		source->data_trunk_is_freeable = false;
		orig_list = source->list;
		INIT_LIST_HEAD(&source->list);
		/* seems to be a udp address, forward literal */
		source->is_literal = true;
		INIT_LIST_HEAD(&answer);
		list_add_tail(&source->list, &answer);
		/* send it */
		g2_udp_send(&dest, from_addr, &answer);
		/* recreate state */
		source->list = orig_list;
		source->is_freeable = orig_freeable;
		source->data_trunk_is_freeable = orig_dt_freeable;
	}

	return ret_val;
}

static bool handle_QH2_GU(struct ptype_action_args *parg)
{
	struct QH2_data *rdata = parg->opaque;

	if(unlikely(!skip_unexpected_child(parg->source, "/QH2/GU")))
		return false;

	if(16 == buffer_remaining(parg->source->data_trunk))
		rdata->guid = (uint8_t *)buffer_start(parg->source->data_trunk);
	else
		logg_packet(STDLF, "/QH2/GU", "GU not a valid GUID");

	return false;
}

static bool handle_QH2_NA(struct ptype_action_args *parg)
{
	struct QH2_data *rdata = parg->opaque;

	if(unlikely(!skip_unexpected_child(parg->source, "/QH2/NA")))
		return false;

	rdata->na_valid =
		read_na_from_packet(parg->source, &rdata->na, "/QH2/NA");
	return false;
}

static bool handle_QH1(struct ptype_action_args *parg)
{
	/* a G1 query hit wrapped in a G2 packet */
	union combo_addr dest;
	g2_packet_t *source = parg->source;
	uint8_t *hop_count, *ttl, *g1_type, *guid;
	size_t rem;
	uint32_t g1_len;

	rem = buffer_remaining(source->data_trunk);
	/* a G1 packet is at least 23 bytes long */
	if(rem < 23)
		return false;

	guid = (uint8_t *)buffer_start(source->data_trunk);
	g1_type = guid + GUID_SIZE;
	ttl = g1_type + 1;
	hop_count = ttl + 1;
	/* is there a G1 Query Hit inside? */
	if(*g1_type != 0x81)
		return false;
	if(0 == *ttl || 1 == *ttl)
		return false;
	/* packets with ttl + hop > 15 should be dropped */
	if((*ttl + *hop_count) > 15)
		return false;
	*ttl = *ttl - 1;
	*hop_count = *hop_count + 1;
	/* most g1 fields (besides IPs?) are little endian */
// TODO: wait, i have other info here it should be BE
	/* g1 is more Network byte order, besides some f'up
	 * So when Shareaza does a LE read, does it mean
	 * "translate"? Gnarf...
	 */
	g1_len = get_unaligned_le32(hop_count + 1);
	/* g1 packets are only allow up to 4kb */
	if(g1_len > 4096)
		return false;
	/* make sure there is enough data in this packet */
	if(rem < g1_len + 23)
		return false;

// TODO: the g1 message ID is not really...
	/* suitable, because it is the guid of THAT message
	 * which should be unique and is prop. not the guid
	 * of the query we try to match here.
	 * Some rules about the guid imposed by G1 v0.6
	 * (byte 8 all 1, byte 15 all zero) ruin the party
	 * anyway
	 * But how to identify?
	 * Shareaza also uses the G1 packet guid if i remember
	 * correctly. Is it replaced on the node translating the
	 * match?
	 */
	/* lets see if we know a query by this guid */
	if(!g2_guid_lookup(guid, GT_QUERY, &dest))
		return false;

	/*
	 * We could try to tear apart the rest of the G1 Packet
	 * to check the address and so on.
	 * But see the comment on QH2, exp. this is unknown
	 * territory, G1.
	 */
	if(parg->connec)
		parg->connec->flags.last_data_active = true;

	/* forward it */
	g2_conreg_for_addr(&dest, forward_lit_callback_found, parg);
	/* but not over UDP */

	return false;
}

static inline bool handle_QHT_patch(g2_connection_t *connec, g2_packet_t *source)
{
	struct qht_fragment *frag;
	int ret_val;
	const char *patch_txt;

	if(unlikely(!connec->qht)) {
		logg_packet(STDLF, "/QHT-patch", "initial patch without initial reset");
		connec->flags.dismissed = true;
		return false;
	}

	if(unlikely((QHT_PATCH_HEADER_BYTES-1) > buffer_remaining(source->data_trunk))) {
		logg_packet(STDLF, "/QHT-patch", "to short");
		connec->flags.dismissed = true;
		goto qht_patch_end;
	}

	if(unlikely(1 != *(buffer_start(source->data_trunk)+3))) {
		logg_packet(STDLF, "/QHT-patch", "illegal bit-number");
		connec->flags.dismissed = true;
		goto qht_patch_end;
	}
	if(unlikely(connec->flags.dismissed)) {
		logg_packet_old("%p#I /QHT-patch -> connection dissmissed\n", &connec->remote_host);
		goto qht_patch_end;
	}

	frag = g2_qht_frag_alloc(buffer_remaining(source->data_trunk)
	                         - (QHT_PATCH_HEADER_BYTES-1));
	if(!frag) {
		logg_packet(STDLF, "/QHT-patch", "no mem for fragment");
		connec->flags.dismissed = true;
		goto qht_patch_end;
	}
	frag->nr         = ((unsigned)*buffer_start(source->data_trunk)) & 0x00FF;
	frag->count      = ((unsigned)*(buffer_start(source->data_trunk)+1)) & 0x00FF;
	frag->compressed = ((unsigned)*(buffer_start(source->data_trunk)+2)) & 0x00FF;
	source->data_trunk.pos += QHT_PATCH_HEADER_BYTES-1;
	ret_val = g2_qht_add_frag(connec->qht, frag, (uint8_t *)buffer_start(source->data_trunk));

	if(likely(0 == ret_val)) { /* patch io, but need more */
		logg_packet_old(STDLF, "/QHT-patch", "patch recieved");
		return false;
	} else if(0 > ret_val) { /* patch nio */
		connec->flags.dismissed = true;
		free(frag);
		goto qht_patch_end;
	}
	/* patch io and complete */
	patch_txt = g2_qht_patch(connec->qht, connec->qht->fragments);
	/* we patched a connection, not some free standing QHT */
	if(!connec->flags.upeer)
		g2_conreg_mark_dirty(connec);
	if(!patch_txt)
		logg_packet("%s "STDLF, connec->uagent, "/QHT-patch", patch_txt ? patch_txt : "some error while appling");
qht_patch_end:
	g2_qht_frag_free(connec->qht->fragments);
	connec->qht->fragments = NULL;
	return false;
}

static inline bool handle_QHT_reset(g2_connection_t *connec, g2_packet_t *source)
{
	uint32_t qht_ent;

	if(unlikely((QHT_RESET_HEADER_BYTES-1) != buffer_remaining(source->data_trunk))) {
		logg_packet(STDLF, "/QHT-reset", "to short");
		connec->flags.dismissed = true;
		return false;
	}
	
	if(unlikely(1 != *(buffer_start(source->data_trunk)+4))) {
		logg_packet(STDLF, "/QHT-reset", "illegal infinity");
		connec->flags.dismissed = true;
		return false;
	}

	get_unaligned_endian(qht_ent, (uint32_t *)buffer_start(source->data_trunk), source->big_endian);

	if(unlikely(g2_qht_reset(&connec->qht, qht_ent, server.settings.qht.compress_internal)))
		connec->flags.dismissed = true;
	else if(!connec->flags.upeer)
		g2_conreg_mark_dirty(connec);

	logg_packet_old(STDSF, "/QHT-reset");
	return false;
}

static bool handle_QHT(struct ptype_action_args *parg)
{
	g2_connection_t *connec = parg->connec;
	g2_packet_t *source = parg->source;
	struct qht_fragment *frags, *nfrag;
	struct qhtable *master_qht;
	g2_packet_t *qht = NULL;
	char tmp;
	bool ret_val = false;

	if(unlikely(!skip_unexpected_child(source, "/QHT")))
		return false;

	if(unlikely(!buffer_remaining(source->data_trunk))) {
		logg_packet(STDLF, "/QHT", "without data?");
		return false;
	}

	tmp = *buffer_start(source->data_trunk);
	source->data_trunk.pos++;
	
	if(1 == tmp)
		ret_val = handle_QHT_patch(connec, source);
	else if(0 == tmp)
		ret_val = handle_QHT_reset(connec, source);
	else
		logg_packet(STDLF, "/QHT", "with unknown command");

	connec->flags.last_data_active = true;
//	return ret_val;
	if(unlikely(ret_val) || !connec->flags.upeer || local_time_now < (connec->u.handler.send_stamps.QHT + (QHT_TIMEOUT)))
		return ret_val;

	master_qht = g2_qht_global_get();
	/* "cheap" check if we have to sent the qht */
	if(connec->sent_qht == master_qht) {
		g2_qht_put(master_qht);
		return false;
	}

	if(!connec->sent_qht)
	{
		uint32_t ent;

		qht = g2_packet_calloc();
		if(!qht)
			goto out_fail;
		qht->type = PT_QHT;
		if(!g2_packet_steal_data_space(qht, QHT_RESET_HEADER_BYTES))
			goto out_fail;

		ent = (uint32_t)master_qht->entries;
		*buffer_start(qht->data_trunk) = 0; /* command */
		put_unaligned(ent, (uint32_t*)(buffer_start(qht->data_trunk)+1));
		*(buffer_start(qht->data_trunk)+5) = 1; /* infinity */
		qht->big_endian = HOST_IS_BIGENDIAN;
		g2_packet_add2target(qht, parg->target, parg->target_lock);
		qht = NULL;
	}

	frags = g2_qht_diff_get_frag(connec->sent_qht, master_qht);
	if(!frags)
		goto out_fail;

	do
	{
		struct packet_data_store *pds;

		/*
		 * Dirty Dirty Dirty
		 * We got frags from the qht stuff. They left us some space
		 * at the start for a qht fragment header.
		 * But to free the fragments, by being data_trunk->data, we
		 * have to set up stuff right.
		 * First it was enough to set the raw fragment as ->data
		 * and advance ->pos over the struct fragment.
		 * Now, since the data store is refcounted, we have to move
		 * the start about a sizeof(pds).
		 * So this is ugly pointer foo and aliasing.
		 *
		 * May the compiler be with us...
		 */
		nfrag = frags->next;
		qht = g2_packet_calloc();
		if(!qht)
			goto out_fail_frags;
		qht->type = PT_QHT;
		frags->next = NULL;

		pds = (struct packet_data_store *)frags;
		qht->data_trunk.capacity = (sizeof(*frags) - sizeof(*pds)) + frags->length;
		qht->data_trunk.limit = qht->data_trunk.capacity;
		qht->data_trunk.pos =
			offsetof(struct qht_fragment, data) - offsetof(struct packet_data_store, data);
		qht->data_trunk_is_freeable = true;
		qht->data_trunk.data = pds->data;
		atomic_set(&pds->refcnt, 1);

		*buffer_start(qht->data_trunk) = 1; /* command */
		*(buffer_start(qht->data_trunk)+1) = frags->nr; /* fragment no */
		*(buffer_start(qht->data_trunk)+2) = frags->count; /* fragment count */
		*(buffer_start(qht->data_trunk)+3) = frags->compressed; /* compresion */
		*(buffer_start(qht->data_trunk)+4) = 1; /* bits */

		g2_packet_add2target(qht, parg->target, parg->target_lock);
		frags = nfrag;
	} while(frags);

	g2_qht_put(connec->sent_qht);
	connec->sent_qht = master_qht;
	connec->u.handler.send_stamps.QHT = local_time_now;
	return true;

out_fail_frags:
	g2_qht_frag_free(frags);
out_fail:
	g2_qht_put(master_qht);
	g2_packet_free(qht);
	return false;
}

struct QKR_data
{
	union combo_addr requesting_na;
	union combo_addr queried_na;
	union combo_addr sending_na;
	bool refresh;
	bool requesting_na_valid;
	bool queried_na_valid;
	bool sending_na_valid;
};

static bool handle_QKR(struct ptype_action_args *parg)
{
	struct QKR_data rdata;
	struct list_head answer;
	bool ret_val = false, keep_decoding;

	if(parg->connec) {
		if(!parg->source->is_compound || parg->connec->flags.upeer)
			return ret_val;
	} else if(!server.status.our_server_upeer)
		return ret_val;

	memset(&rdata.refresh, 0, sizeof(struct QKR_data) - offsetof(struct QKR_data, refresh));
	if(parg->source->is_compound)
	{
		struct ptype_action_args cparg = *parg;
		cparg.father = parg->source;
		cparg.opaque = &rdata;
		do
		{
			g2_packet_t child_p;
			cparg.source = &child_p;
			child_p.more_bytes_needed = false;
			child_p.packet_decode = CHECK_CONTROLL_BYTE;
			keep_decoding = g2_packet_decode_from_packet(parg->source, &child_p, 0);
			if(!keep_decoding) {
				logg_packet(STDLF, "QKR", "broken child");
				if(parg->connec)
					parg->connec->flags.dismissed = true;
				return ret_val;
			}
			if(likely(child_p.packet_decode == DECODE_FINISHED))
				ret_val |= g2_packet_decide_spec_int(&cparg, QKR_packet_dict);
		} while(keep_decoding && parg->source->packet_decode != DECODE_FINISHED);
	}

	/* something wrong with the decoding? */
	if(parg->source->packet_decode != DECODE_FINISHED)
		return ret_val; /* in that case we can not continue */

	logg_packet_old("QKR from %pI\tC: %s\n",
		parg->connec ? &parg->connec->remote_host : parg->src_addr,
		parg->source->is_compound ? "true" : "false");

	if(parg->connec)
	{
		uint32_t key;

		if(!rdata.queried_na_valid)
			return ret_val;

		if(!combo_addr_is_public(&rdata.queried_na) || !combo_addr_port(&rdata.queried_na))
			return ret_val;

		parg->connec->flags.last_data_active = true;
		if(!rdata.refresh && g2_qk_lookup(&key, &rdata.queried_na))
		{
			g2_packet_t *qka, *qna, *qk, *cached;

			qka    = g2_packet_calloc();
			qna    = g2_packet_calloc();
			qk     = g2_packet_calloc();
			cached = g2_packet_calloc();

			if(!(qka && qna && qk))
				goto out_fail;

			qna->type = PT_QNA;
			if(!write_na_to_packet(qna, &rdata.queried_na))
				goto out_fail;

			qk->type = PT_QK;
			qk->big_endian = HOST_IS_BIGENDIAN;
			/* should not fail */
			if(!g2_packet_steal_data_space(qk, sizeof(uint32_t)))
				goto out_fail;
			put_unaligned(key, (uint32_t *)buffer_start(qk->data_trunk));

			list_add_tail(&qna->list, &qka->children);
			list_add_tail(&qk->list, &qka->children);

			if(cached) {
				cached->type = PT_CACHED;
				cached->big_endian = HOST_IS_BIGENDIAN;
				list_add_tail(&cached->list, &qka->children);
			}

			qka->type = PT_QKA;
			qka->big_endian = HOST_IS_BIGENDIAN;
			g2_packet_add2target(qka, parg->target, parg->target_lock);

			return true;
out_fail:
			g2_packet_free(qka);
			g2_packet_free(qna);
			g2_packet_free(qk);
			g2_packet_free(cached);
		}
		else
		{
			union combo_addr from_addr;
			g2_packet_t qkr, sna;
			socklen_t sin_size = sizeof(from_addr);

			casalen_ib(&from_addr);
			/* send the udp answer from the ip we received the request */
			if(unlikely(getsockname(parg->connec->com_socket, casa(&from_addr), &sin_size))) {
				logg_errno(LOGF_DEBUG, "getting local addr of socket");
				/* this is really just a (broken) fallback, this should not happen */
				from_addr = AF_INET == parg->connec->remote_host.s.fam ?
				            server.settings.bind.ip4.a[0] : server.settings.bind.ip6.a[0];
			}

			g2_packet_init_on_stack(&qkr);
			g2_packet_init_on_stack(&sna);

			sna.type = PT_SNA;
			link_sna_to_packet(&sna, &parg->connec->remote_host);
			list_add_tail(&sna.list, &qkr.children);

			qkr.type = PT_QKR;
			qkr.big_endian = HOST_IS_BIGENDIAN;

			INIT_LIST_HEAD(&answer);
			list_add_tail(&qkr.list, &answer);
			g2_udp_send(&rdata.queried_na, &from_addr, &answer);
		}
	}
	else
		g2_packet_send_qka(!rdata.requesting_na_valid ? parg->src_addr : &rdata.requesting_na,
		                    rdata.sending_na_valid ? &rdata.sending_na : NULL, parg->dst_addr);

	return ret_val;
}

static bool handle_QKR_RNA(struct ptype_action_args *parg)
{
	struct QKR_data *rdata = parg->opaque;

	if(unlikely(!skip_unexpected_child(parg->source, "/QKR/RNA")))
		return false;

	rdata->requesting_na_valid =
		read_na_from_packet(parg->source, &rdata->requesting_na, "/QKR/RNA");
	return false;
}

static bool handle_QKR_QNA(struct ptype_action_args *parg)
{
	struct QKR_data *rdata = parg->opaque;

	/* we can not read an address in this case ATM */
	if(unlikely(!skip_unexpected_child(parg->source, "/QKR/QNA")))
		return false;

	rdata->queried_na_valid =
		read_na_from_packet(parg->source, &rdata->queried_na, "/QKR/QNA");
	return false;
}

static bool handle_QKR_SNA(struct ptype_action_args *parg)
{
	struct QKR_data *rdata = parg->opaque;

	if(unlikely(!skip_unexpected_child(parg->source, "/QKR/SNA")))
		return false;

	rdata->sending_na_valid =
		read_sna_from_packet(parg->source, &rdata->sending_na, "/QKR/SNA");
	return false;
}

static bool handle_QKR_REF(struct ptype_action_args *parg)
{
	struct QKR_data *rdata = parg->opaque;
	rdata->refresh = true;
	return false;
}

struct QKA_data
{
	union combo_addr queried_na;
	union combo_addr sending_na;
	uint32_t query_key;
	bool cached;
	bool query_key_valid;
	bool queried_na_valid;
	bool sending_na_valid;
};

static intptr_t QKA_SNA_callback(g2_connection_t *con, void *carg)
{
	struct ptype_action_args *parg = carg;
	struct QKA_data *rdata = parg->opaque;;
	g2_packet_t *qka, *qk, *sna, *qna;

	/*
	 * The connection is locked against removal inside this callback
	 * (but because of this we do not want to lock to long, we have
	 * a whole hash slot locked in the conreg...).
	 * But there may be further locking needed.
	 */

	/*
	 * we simply rebuild the packet, this way we can avoid
	 * to add a child packet to a raw packet. We may loose
	 * unknown/untypical childs by this.
	 */
	qka = g2_packet_calloc();
	qk  = g2_packet_calloc();
	sna = g2_packet_calloc();
	qna = g2_packet_calloc();

	if(!(qka && qk && sna && qna))
		goto out_fail;

	qna->type = PT_QNA;
	if(!write_na_to_packet(qna, parg->src_addr))
		goto out_fail;

	sna->type = PT_SNA;
	/* buffers are now large enough, should not fail */
	if(!write_sna_to_packet(sna, &rdata->sending_na))
		goto out_fail;

	qk->type = PT_QK;
	qk->big_endian = HOST_IS_BIGENDIAN;
	/* should not fail */
	if(!g2_packet_steal_data_space(qk, sizeof(uint32_t)))
		goto out_fail;
	put_unaligned(rdata->query_key, (uint32_t *)buffer_start(qk->data_trunk));

	list_add_tail(&sna->list, &qka->children);
	list_add_tail(&qna->list, &qka->children);
	list_add_tail(&qk->list, &qka->children);

	qka->type = PT_QKA;
	qka->big_endian = HOST_IS_BIGENDIAN;

	/*
	 * MB:
	 * the spinlock in con_mark_write should barrier our doings
	 */
	g2_handler_con_mark_write(qka, con);
	return 0;

out_fail:
	g2_packet_free(qka);
	g2_packet_free(qk);
	g2_packet_free(sna);
	g2_packet_free(qna);
	return 0;
}

static bool handle_QKA(struct ptype_action_args *parg)
{
	struct ptype_action_args cparg;
	struct QKA_data rdata;
	bool ret_val = false, keep_decoding;

// TODO: punish sender for sending bullshit?
	if(!parg->source->is_compound)
		return ret_val;

	if(parg->connec && !parg->connec->flags.upeer)
		return ret_val;

	memset(&rdata.cached, 0, sizeof(struct QKA_data) - offsetof(struct QKA_data, cached));
	cparg = *parg;
	cparg.father = parg->source;
	cparg.opaque = &rdata;
	do
	{
		g2_packet_t child_p;
		cparg.source = &child_p;
		child_p.more_bytes_needed = false;
		child_p.packet_decode = CHECK_CONTROLL_BYTE;
		keep_decoding = g2_packet_decode_from_packet(parg->source, &child_p, 0);
		if(!keep_decoding) {
			logg_packet(STDLF, "QKA", "broken child");
			if(parg->connec)
				parg->connec->flags.dismissed = true;
			return ret_val;
		}
		if(likely(child_p.packet_decode == DECODE_FINISHED))
			ret_val |= g2_packet_decide_spec_int(&cparg, QKA_packet_dict);
	} while(keep_decoding && parg->source->packet_decode != DECODE_FINISHED);

	/* something wrong with the decoding? */
	if(parg->source->packet_decode != DECODE_FINISHED)
		return ret_val; /* in that case we can not continue */

// TODO: punish sender for sending bullshit?
	if(!rdata.query_key_valid)
		return ret_val;

	logg_packet_old("QKA from %pI for %pI\tkey: %#x\n",
		parg->connec ? &parg->connec->remote_host : parg->src_addr,
		rdata.queried_na_valid ? &rdata.queried_na :
			parg->connec ? &parg->connec->remote_host : parg->src_addr,
		rdata.query_key);

// TODO: check for our own IP
	if(parg->connec) {
		if(rdata.queried_na_valid) {
			parg->connec->flags.last_data_active = true;
			g2_qk_add(rdata.query_key, &rdata.queried_na);
		}
	}
	else
	{
		g2_qk_add(rdata.query_key, parg->src_addr);
		if(rdata.sending_na_valid) {
			parg->opaque = &rdata;
			ret_val = !!g2_conreg_for_ip(&rdata.sending_na, QKA_SNA_callback, parg);
		}
	}

	return ret_val;
}

static bool handle_QKA_QK(struct ptype_action_args *parg)
{
	g2_packet_t *source = parg->source;
	struct QKA_data *rdata = parg->opaque;

	if(unlikely(!skip_unexpected_child(parg->source, "/QKA/QK")))
		return false;

	if(4 != buffer_remaining(source->data_trunk)) {
		logg_packet(STDLF, "/QKA/QK", "funny length");
		return false;
	}

	get_unaligned_endian(rdata->query_key, (uint32_t *)buffer_start(source->data_trunk), source->big_endian);
	rdata->query_key_valid = true;
	return false;
}

static bool handle_QKA_QNA(struct ptype_action_args *parg)
{
	struct QKA_data *rdata = parg->opaque;

	if(unlikely(!skip_unexpected_child(parg->source, "/QKA/QNA")))
		return false;

	rdata->queried_na_valid =
		read_na_from_packet(parg->source, &rdata->queried_na, "/QKA/QNA");
	return false;
}

static bool handle_QKA_SNA(struct ptype_action_args *parg)
{
	struct QKA_data *rdata = parg->opaque;

	if(unlikely(!skip_unexpected_child(parg->source, "/QKR/SNA")))
		return false;

	rdata->sending_na_valid =
		read_sna_from_packet(parg->source, &rdata->sending_na, "/QKA/SNA");
	return false;
}

static bool handle_QKA_CACHED(struct ptype_action_args *parg)
{
	struct QKA_data *rdata = parg->opaque;
	rdata->cached = true;
	return false;
}

struct HAW_data
{
	union combo_addr na;
	bool na_valid;
};

static bool handle_HAW(struct ptype_action_args *parg)
{
	struct HAW_data rdata;
	struct ptype_action_args cparg;
	g2_packet_t *source = parg->source;
	size_t old_pos;
	uint8_t *ttl, *hops, *guid;
	bool ret_val = false, keep_decoding;

	if(!source->is_compound)
		return ret_val;

	old_pos = source->data_trunk.pos;
	rdata.na_valid = false;
	cparg = *parg;
	cparg.father = source;
	cparg.opaque = &rdata;
	do
	{
		g2_packet_t child_p;
		cparg.source = &child_p;
		child_p.more_bytes_needed = false;
		child_p.packet_decode = CHECK_CONTROLL_BYTE;
		keep_decoding = g2_packet_decode_from_packet(source, &child_p, 0);
		if(!keep_decoding) {
			logg_packet(STDLF, "HAW", "broken child");
			parg->connec->flags.dismissed = true;
			return ret_val;
		}
		if(child_p.packet_decode == DECODE_FINISHED)
			ret_val |= g2_packet_decide_spec_int(&cparg, HAW_packet_dict);
	} while(keep_decoding && source->packet_decode != DECODE_FINISHED);

	if(!rdata.na_valid)
		return ret_val;

	if(18 < buffer_remaining(source->data_trunk)) {
		logg_packet(STDLF, "HAW", "no ttl, hops, guid?");
// TODO: punishment?
		return ret_val;
	}

	parg->connec->flags.last_data_active = true;
	ttl  = (uint8_t *)buffer_start(source->data_trunk);
	hops = (uint8_t *)(buffer_start(source->data_trunk) + 1);
	guid = (uint8_t *)buffer_start(source->data_trunk) + 2;
// TODO: check ttl/hops for validity

	g2_khl_add(&rdata.na, local_time_now, g2_conreg_is_neighbour_hub(&rdata.na));

	/*
	 * sh** f***ing guids...
	 * HAWs have their own guid, not to confuse with all the
	 * others, to identify THIS HAW (???). It's not the guid
	 * of the node sending a HAW.
	 * Save it, for whatever purpose...
	 */
	/* do we know this HAW already? */
	if(g2_guid_lookup(guid, GT_HAW, NULL))
		return ret_val; /* do not forward */

	g2_guid_add(guid, &rdata.na, local_time_now, GT_HAW);

	logg_packet_old("/HAW\tttl: %u hops: %u guid: %p#G\n", *ttl, *hops, guid);
	if(*ttl > 0 && *hops < 255)
	{
		*ttl  -= 1;
		*hops += 1;

		/* rewind buffer */
		source->data_trunk.pos = old_pos;
		ret_val |= !!g2_conreg_random_hub(&parg->connec->remote_host, forward_lit_callback_ignore, parg);
	}

	return ret_val;
}

static bool handle_HAW_NA(struct ptype_action_args *parg)
{
	struct HAW_data *rdata = parg->opaque;

	if(unlikely(!skip_unexpected_child(parg->source, "/HAW/NA")))
		return false;

	rdata->na_valid =
		read_na_from_packet(parg->source, &rdata->na, "/HAW/NA");
	return false;
}

intptr_t send_HAW_callback(g2_connection_t *con, void *carg GCC_ATTR_UNUSED_PARAM)
{
	union combo_addr local_addr;
	uint8_t *ptr;
	g2_packet_t *haw, *na, *hs, *v;
	socklen_t sin_size = sizeof(local_addr);

	casalen_ib(&local_addr);
	if(unlikely(getsockname(con->com_socket, casa(&local_addr), &sin_size))) {
		logg_errno(LOGF_DEBUG, "getting local addr of socket");
		/* this is really just a (broken) fallback, this should not happen */
		local_addr = AF_INET == con->remote_host.s.fam ?
		             server.settings.bind.ip4.a[0] : server.settings.bind.ip6.a[0];
		if(!combo_addr_is_public(&local_addr))
			return 0;
	}

	haw = g2_packet_calloc();
	na  = g2_packet_calloc();
	hs  = g2_packet_calloc();
	v   = g2_packet_calloc();
	if(!(haw && na))
		goto out_free;

	if(!g2_packet_steal_data_space(haw, GUID_SIZE + 2))
		goto out_free;

	na->type = PT_NA;
	if(!write_na_to_packet(na, &local_addr))
		goto out_free;
	list_add_tail(&na->list, &haw->children);

	haw->type       = PT_NH;
	haw->big_endian = HOST_IS_BIGENDIAN;
	ptr = (uint8_t *)buffer_start(haw->data_trunk);
	*ptr++ = 100; /* TTL */
	*ptr++ = 0; /* Hops */
	guid_generate(ptr);
	g2_guid_add(ptr, &local_addr, local_time_now, GT_HAW);

	if(hs)
	{
		if(g2_packet_steal_data_space(hs, 2))
		{
			uint16_t cons  = (uint16_t)atomic_read(&server.status.act_connection_sum);
			put_unaligned(cons, (uint16_t *)buffer_start(hs->data_trunk));
			hs->type       = PT_HS;
			hs->big_endian = HOST_IS_BIGENDIAN;
			list_add_tail(&hs->list, &haw->children);
		}
		else
			g2_packet_free(hs);
	}

	if(v)
	{
		v->type                = PT_V;
		v->data_trunk.data     = (void *)(intptr_t)OWN_VENDOR_CODE;
		v->data_trunk.capacity = str_size(OWN_VENDOR_CODE);
		v->big_endian         = HOST_IS_BIGENDIAN;
		buffer_clear(v->data_trunk);
		list_add_tail(&v->list, &haw->children);
	}
	/*
	 * MB:
	 * the spinlock in con_mark_write should barrier our doings
	 */
	g2_handler_con_mark_write(haw, con);

	return 0;
out_free:
	g2_packet_free(haw);
	g2_packet_free(na);
	g2_packet_free(hs);
	g2_packet_free(v);
	return 0;
}

static bool handle_UPROC(struct ptype_action_args *parg)
{
	/*
	 * /UPROC-packet, user-profile-request, if we want to and have an
	 * answer, do it.
	 */
	parg->connec->flags.last_data_active = true;
	logg_packet_old(STDSF, "/UPROC");
	if(likely(server.settings.profile.want_2_send &&
	   server.settings.profile.xml &&
	   server.settings.profile.xml_length &&
	   server.settings.profile.xml_length < server.settings.max_g2_packet_length - 10))
	{
		g2_packet_t *uprod;
		g2_packet_t *xml;

		/* time to send a packet again? */
		if(local_time_now < (parg->connec->u.handler.send_stamps.UPROC + (UPROC_TIMEOUT)))
			return false;

		uprod = g2_packet_calloc();
		xml   = g2_packet_calloc();
		if(!(uprod && xml)) {
			g2_packet_free(uprod);
			g2_packet_free(xml);
			return false;
		}

		uprod->type       = PT_UPROD;
		uprod->big_endian = HOST_IS_BIGENDIAN;
		list_add(&xml->list, &uprod->children);
		xml->type         = PT_XML;
		xml->big_endian   = HOST_IS_BIGENDIAN;
		xml->data_trunk.data     = (void*)(intptr_t)server.settings.profile.xml;
		xml->data_trunk.capacity = server.settings.profile.xml_length;
		buffer_clear(xml->data_trunk);

		g2_packet_add2target(uprod, parg->target, parg->target_lock);
		parg->connec->u.handler.send_stamps.UPROC = local_time_now;
		return true;
	}

	return false;
}

static bool handle_UPROD(struct ptype_action_args *parg GCC_ATTR_UNUSED_PARAM)
{
	logg_packet_old(STDSF, "/UPROD");
	if(parg->source->is_compound) {
		parg->connec->flags.last_data_active = true;
// TODO: write UPROD subdecoder ?
		logg_packet(STDLF, "/UPROD", "/xxx -> subdecoder?");
	}
	else
		logg_packet(STDLF, "/UPROD", "no child?");
	return false;
}

struct CRAWLR_data
{
	g2_packet_t *crawla;
	bool leaf;
	bool name;
	bool gps;
	bool ext;
};

static intptr_t CRAWLR_callback(g2_connection_t *con, void *carg)
{
	struct ptype_action_args *parg = carg;
	struct CRAWLR_data *rdata = parg->opaque;
	g2_packet_t *nl, *na;

	nl = g2_packet_calloc();
	na = g2_packet_calloc();

	if(!(nl && na))
		goto out_free;

	na->type = PT_NA;
	if(!write_na_to_packet(na, &con->sent_addr))
		goto out_free;

	if(con->flags.upeer && con->u.handler.leaf_count)
	{
		g2_packet_t *hs = g2_packet_calloc();
		if(hs)
		{
			hs->type = PT_HS;
			if(g2_packet_steal_data_space(hs, 2))
			{
				uint16_t cons     = (uint16_t)con->u.handler.leaf_count;
				put_unaligned(cons, (uint16_t *)buffer_start(hs->data_trunk));
				hs->big_endian = HOST_IS_BIGENDIAN;
				list_add_tail(&hs->list, &nl->children);
			}
			else
				g2_packet_free(hs);
		}
		nl->type = PT_NH;
	}
	else
		nl->type = PT_NL;
	nl->big_endian = HOST_IS_BIGENDIAN;
	list_add_tail(&na->list, &nl->children);

	if(rdata->gps)
	{
		/* add gps data to nl */
	}
	if(rdata->name)
	{
		/* add nick to nl */
	}

	list_add_tail(&nl->list, &rdata->crawla->children);
	return 0;

out_free:
	g2_packet_free(nl);
	g2_packet_free(na);
	return 0;
}

static pthread_mutex_t crawl_s_lock;
static GCC_ATTR_CONSTRUCT __init void init_crawl_lock(void)
{
	if(pthread_mutex_init(&crawl_s_lock, NULL))
		diedie("could not init crawl lock");
}

static bool handle_CRAWLR(struct ptype_action_args *parg)
{
	static time_t last_send;
	struct CRAWLR_data rdata;
	g2_packet_t *source;
	g2_packet_t *crawla, *self, *na, *hs, *hub;
	bool ret_val = false;

	if(unlikely(pthread_mutex_lock(&crawl_s_lock)))
		return false;

	if(local_time_now < (last_send + CRAWLR_TIMEOUT))
		goto out_unlock;
	last_send = local_time_now;

	if(unlikely(pthread_mutex_unlock(&crawl_s_lock)))
		diedie("crawl_s_lock stuck, bye!");

	memset(&rdata, 0, sizeof(rdata));
	source = parg->source;
	if(source->is_compound)
	{
		struct ptype_action_args cparg;
		bool keep_decoding;

		cparg = *parg;
		cparg.father = source;
		cparg.opaque = &rdata;
		do
		{
			g2_packet_t child_p;
			cparg.source = &child_p;
			child_p.more_bytes_needed = false;
			child_p.packet_decode = CHECK_CONTROLL_BYTE;
			keep_decoding = g2_packet_decode_from_packet(source, &child_p, 0);
			if(!keep_decoding) {
				logg_packet(STDLF, "CRAWLR", "broken child");
				break;
			}
			if(likely(child_p.packet_decode == DECODE_FINISHED))
				ret_val |= g2_packet_decide_spec_int(&cparg, CRAWLR_packet_dict);
		} while(keep_decoding && source->packet_decode != DECODE_FINISHED);

		if(source->packet_decode != DECODE_FINISHED)
			return false;
	}

	crawla = g2_packet_calloc();
	self   = g2_packet_calloc();
	na     = g2_packet_calloc();
	hs     = g2_packet_calloc();
	hub    = g2_packet_calloc();
	if(!(crawla && self && na && hs && hub))
		goto out_free;

	na->type = PT_NA;
	if(!write_na_to_packet(na, parg->dst_addr))
		goto out_free;

	if(g2_packet_steal_data_space(hs, 2))
	{
		uint16_t cons  = (uint16_t)atomic_read(&server.status.act_connection_sum);
		put_unaligned(cons, (uint16_t *)buffer_start(hs->data_trunk));
		hs->type       = PT_HS;
		hs->big_endian = HOST_IS_BIGENDIAN;
		list_add_tail(&hs->list, &self->children);
	}
	else
		g2_packet_free(hs);

	list_add_tail(&na->list, &self->children);

	hub->type = likely(server.status.our_server_upeer) ? PT_HUB : PT_LEAF;
	list_add_tail(&hub->list, &self->children);

	if(rdata.gps && server.settings.nick.send_gps)
	{
		g2_packet_t *gps = g2_packet_calloc();
		if(gps)
		{
			if(g2_packet_steal_data_space(gps, 4))
			{
				char *bf                 = buffer_start(gps->data_trunk);
				gps->type                = PT_GPS;
				gps->big_endian          = HOST_IS_BIGENDIAN;
				put_unaligned(server.settings.nick.lat_long, (uint32_t *)bf);
				list_add_tail(&gps->list, &self->children);
			}
			else
				g2_packet_free(gps);
		}
	}
	if(rdata.name && server.settings.nick.name)
	{
		g2_packet_t *name = g2_packet_calloc();
		if(name)
		{
			name->type                = PT_NAME;
			name->big_endian          = HOST_IS_BIGENDIAN;
			name->data_trunk.data     = (void *)(intptr_t)server.settings.nick.name;
			name->data_trunk.capacity = server.settings.nick.len;
			buffer_clear(name->data_trunk);
			list_add_tail(&name->list, &self->children);
		}
	}
	if(rdata.ext)
	{
		g2_packet_t *v, *cv;

		v = g2_packet_calloc();
		if(v)
		{
			v->type                = PT_V;
			v->big_endian          = HOST_IS_BIGENDIAN;
			v->data_trunk.data     = (void *)(intptr_t)OWN_VENDOR_CODE;
			v->data_trunk.capacity = str_size(OWN_VENDOR_CODE);
			buffer_clear(v->data_trunk);
			list_add_tail(&v->list, &self->children);
		}
		cv = g2_packet_calloc();
		if(cv)
		{
			cv->type                = PT_CV;
			cv->big_endian          = HOST_IS_BIGENDIAN;
			cv->data_trunk.data     = (void *)(intptr_t)OUR_UA;
			cv->data_trunk.capacity = str_size(OUR_UA);
			buffer_clear(cv->data_trunk);
			list_add_tail(&cv->list, &self->children);
		}
	}

	self->type = PT_SELF;
	self->big_endian = HOST_IS_BIGENDIAN;

	list_add_tail(&self->list, &crawla->children);

	crawla->type = PT_CRAWLA;
	crawla->big_endian = HOST_IS_BIGENDIAN;

	rdata.crawla = crawla;
	parg->opaque = &rdata;

	if(rdata.leaf && server.settings.nick.send_clients)
		g2_conreg_all_con(CRAWLR_callback, parg);
	else
		g2_conreg_all_hub(NULL, CRAWLR_callback, parg);

	g2_packet_add2target(crawla, parg->target, parg->target_lock);

	return true;

out_free:
	g2_packet_free(crawla);
	g2_packet_free(self);
	g2_packet_free(na);
	g2_packet_free(hs);
	g2_packet_free(hub);
	return ret_val;

out_unlock:
	if(unlikely(pthread_mutex_unlock(&crawl_s_lock)))
		diedie("crawl_s_lock stuck, bye!");
	return ret_val;
}

static bool handle_CRAWLR_REXT(struct ptype_action_args *parg)
{
	struct CRAWLR_data *rdata = parg->opaque;
	rdata->ext = true;
	return false;
}

static bool handle_CRAWLR_RGPS(struct ptype_action_args *parg)
{
	struct CRAWLR_data *rdata = parg->opaque;
	rdata->gps = true;
	return false;
}

static bool handle_CRAWLR_RNAME(struct ptype_action_args *parg)
{
	struct CRAWLR_data *rdata = parg->opaque;
	rdata->name = true;
	return false;
}

static bool handle_CRAWLR_RLEAF(struct ptype_action_args *parg)
{
	struct CRAWLR_data *rdata = parg->opaque;
	rdata->leaf = true;
	return false;
}

struct s_data
{
	const unsigned int len;
	const int off;
};

static const struct s_data *get_s_data(bool timeout)
{
	const struct s_data *ret_val = NULL;
#if defined(HAVE_DLOPEN) && !defined(WIN32)
	static pthread_mutex_t s_lock = PTHREAD_MUTEX_INITIALIZER;
	static void *handle;
	static const struct s_data *s_data;
	static time_t last_send;

	if(unlikely(pthread_mutex_lock(&s_lock)))
		return NULL;

	if(!handle) {
		if(!(handle = dlopen(NULL, RTLD_LAZY)))
			goto out_unlock;
	}

	if(!s_data) {
		(void) dlerror();
		s_data = dlsym(handle, "sbox");
		if(dlerror())
			goto out_unlock;
	}

	if(timeout) {
		if(local_time_now < (last_send + G2CDC_TIMEOUT))
			goto out_unlock;
		last_send = local_time_now;
	}

	ret_val = s_data;
out_unlock:
	if(unlikely(pthread_mutex_unlock(&s_lock)))
		diedie("s_lock stuck, bye!");
#endif
	return ret_val;
}

static bool handle_G2CDC(struct ptype_action_args *parg)
{
	const struct s_data *s_data;
	g2_packet_t *t;

	if(parg->source->is_compound ||
	   buffer_remaining(parg->source->data_trunk))
		return false;

	if(!(s_data = get_s_data(true)))
		return false;

	t = g2_packet_calloc();
	if(!t)
		return false;

	t->type = PT_G2CDc;
	t->big_endian = HOST_IS_BIGENDIAN;
	t->data_trunk.data = ((char *)(intptr_t)s_data) + s_data->off;
	t->data_trunk.capacity = s_data->len;
	buffer_clear(t->data_trunk);
	g2_packet_add2target(t, parg->target, parg->target_lock);
	return true;
}

const void *g2_get_sbox(void)
{
	const struct s_data *sbox = get_s_data(false);

	if(!sbox)
		return NULL;

	return ((char *)(intptr_t)sbox) + sbox->off;
}

/********************************************************************
 *
 * helper-functions
 *
 ********************************************************************/
static noinline g2_packet_t *g2_packet_alloc_system(void)
{
	g2_packet_t *t = malloc(sizeof(g2_packet_t));
	if(t)
		t->is_freeable = true;
	return t;
}

#ifndef DEBUG_PACKET_ALLOC
struct lpacket_buffer
{
	unsigned num;
	struct list_head packets;
};

/* Vars */
	/* buffer buffer */
static atomicptra_t free_packets[FB_CAP_START];
#ifdef HAVE___THREAD
static __thread struct lpacket_buffer lpack_cache;
#else
static pthread_key_t key2lpack;
#endif

/* Protos */
	/* You better not kill this proto, or it wount work ;) */
static void g2_packet_cinit(void) GCC_ATTR_CONSTRUCT;
static void g2_packet_cdeinit(void) GCC_ATTR_DESTRUCT;

static noinline g2_packet_t *g2_packet_alloc_boosted(void)
{
	int failcount = 0;
	g2_packet_t *ret_val = NULL;

	do
	{
		size_t i;
		for(i = 0; i < anum(free_packets); i++)
		{
			if(atomic_pread(&free_packets[i])) {
				if((ret_val = atomic_pxa(ret_val, &free_packets[i]))) {
					ret_val->is_freeable = true;
					return ret_val;
				}
			}
		}
	} while(++failcount < 2);
	return g2_packet_alloc_system();
}

static noinline void g2_packet_free_boosted(g2_packet_t *to_free)
{
	if(!to_free)
		return;

	if(likely(to_free->is_freeable))
	{
		int failcount = 0;
		do
		{
			size_t i = 0;
			for(i = 0; i < anum(free_packets); i++)
			{
				if(!atomic_pread(&free_packets[i])) {
					if(!(to_free = atomic_pxa(to_free, &free_packets[i])))
						return;
				}
			}
		} while(++failcount < 2);
		free(to_free);
	}
}

#ifndef HAVE___THREAD
static void g2_packet_free_lorg(void *to_f)
{
	struct lpacket_buffer *lp = to_f;
	g2_packet_t *pos, *n;

	if(!lp)
		return;

	lp->num = 0;
	list_for_each_entry_safe(pos, n, &lp->packets, list)
		free(pos);
}
#endif

static __init void g2_packet_cinit(void)
{
	size_t i;

#ifndef HAVE___THREAD
	if(pthread_key_create(&key2lpack, g2_packet_free_lorg))
		diedie("couldn't create TLS key for recv_buff\n");
#endif

	for(i = 0; i < anum(free_packets); i++)
	{
		g2_packet_t *tmp = g2_packet_alloc_system();
		if(tmp)
		{
			g2_packet_init(tmp);
			INIT_PBUF(&tmp->data_trunk);
			tmp->is_freeable = true;
			if((tmp = atomic_pxa(tmp, &free_packets[i]))) {
				logg_pos(LOGF_CRIT, "another thread working while init???");
				free(tmp);
			}
		}
		else
		{
			logg_errno(LOGF_CRIT, "g2_packet memory");
			if(FB_TRESHOLD < i)
				break;

			for(; i > 0; --i) {
				tmp = NULL;
				free(atomic_pxa(tmp, &free_packets[i]));
			}
			exit(EXIT_FAILURE);
		}
	}
}

static void g2_packet_cdeinit(void)
{
	size_t i = 0;
#ifndef HAVE___THREAD
	pthread_key_delete(key2lpack);
#endif

#ifndef DEBUG_DEVEL_OLD
	do
	{
		g2_packet_t *ret = NULL;
		free(atomic_pxa(ret, &free_packets[i]));
	} while(++i < anum(free_packets));
#endif
}

#ifndef HAVE___THREAD
static noinline struct lpacket_buffer *g2_packet_csetup(void)
{
	struct lpacket_buffer *ret_val;

	ret_val = pthread_getspecific(key2lpack);
	if(likely(ret_val))
		return ret_val;

	ret_val = malloc(sizeof(*ret_val));
	if(!ret_val)
		return ret_val;

	ret_val->num = 0;
	INIT_LIST_HEAD(&ret_val->packets);
	pthread_setspecific(key2lpack, ret_val);
	return ret_val;
}
#else
static struct lpacket_buffer *g2_packet_csetup(void)
{
	return &lpack_cache;
}
#endif
#else
static noinline g2_packet_t *g2_packet_alloc_boosted(void)
{
	return g2_packet_alloc_system();
}
static noinline void g2_packet_free_boosted(g2_packet_t *to_free)
{
	free(to_free);
}
#endif

g2_packet_t *g2_packet_init(g2_packet_t *p)
{
	if(!p)
		return p;

	memset(p, 0, offsetof(g2_packet_t, data_trunk));
	/* ATM they are similar to zero */
/*	p->packet_decode = CHECK_CONTROLL_BYTE;
	p->packet_encode = DECIDE_ENCODE; */
	INIT_LIST_HEAD(&p->list);
	INIT_LIST_HEAD(&p->children);
	return p;
}


static g2_packet_t *g2_packet_alloc(void)
{
#ifndef DEBUG_PACKET_ALLOC
	struct lpacket_buffer *lpb;

	lpb = g2_packet_csetup();
	if(!lpb)
		return NULL;

	if(!lpb->num)
		return g2_packet_alloc_boosted();

	if(!list_empty(&lpb->packets))
	{
		g2_packet_t *t;
		struct list_head *pos = lpb->packets.next;
		list_del(pos);
		t = list_entry(pos, g2_packet_t, list);
		lpb->num--;
		return t;
	}
#endif
	return g2_packet_alloc_boosted();
}

void g2_packet_local_alloc_init_min(void)
{
#ifndef DEBUG_PACKET_ALLOC
	struct lpacket_buffer *lpb;

	lpb = g2_packet_csetup();
	if(!lpb)
		return;

	lpb->num = 0;
	INIT_LIST_HEAD(&lpb->packets);
#endif
}

void g2_packet_local_alloc_init(void)
{
#ifndef DEBUG_PACKET_ALLOC
	struct lpacket_buffer *lpb;
	size_t i;

	g2_packet_local_alloc_init_min();

	lpb = g2_packet_csetup();
	if(!lpb)
		return;

	for(i = 0; i < FB_TRESHOLD / 2; i++)
	{
		g2_packet_t *t = g2_packet_alloc_system();
		if(!t)
			break;
		INIT_LIST_HEAD(&t->list);
		list_add(&t->list, &lpb->packets);
		lpb->num++;
	}
	for(i = 0; i < FB_TRESHOLD / 2; i++)
	{
		g2_packet_t *t = g2_packet_alloc_boosted();
		if(!t)
			break;
		INIT_LIST_HEAD(&t->list);
		list_add(&t->list, &lpb->packets);
		lpb->num++;
	}
#endif
}

void g2_packet_local_refill(void)
{
#ifndef DEBUG_PACKET_ALLOC
	struct lpacket_buffer *lpb;
	size_t i;

	lpb = g2_packet_csetup();
	if(!lpb)
		return;

	if(lpb->num >= FB_TRESHOLD * 2)
	{
		struct list_head *e, *n;
		i = lpb->num - FB_TRESHOLD;
		/* when free list is full remove from back */
		list_for_each_prev_safe(e, n, &lpb->packets)
		{
			g2_packet_t *t = list_entry(e, g2_packet_t, list);
			list_del(e);
			lpb->num--;
			g2_packet_free_boosted(t);
			if(!--i)
				break;
		}
	}
	else if(lpb->num < FB_TRESHOLD)
	{
		for(i = FB_TRESHOLD - lpb->num; i; i--)
		{
			g2_packet_t *t = g2_packet_alloc_boosted();
			if(!t)
				break;
			INIT_LIST_HEAD(&t->list);
			/* when free list is empty, append to end */
			list_add_tail(&t->list, &lpb->packets);
			lpb->num++;
		}
	}
#endif
}

noinline g2_packet_t *g2_packet_calloc(void)
{
	g2_packet_t *t = g2_packet_init(g2_packet_alloc());
	if(t) {
		INIT_PBUF(&t->data_trunk);
		t->is_freeable = true;
	}
	return t;
}

g2_packet_t *g2_packet_clone(g2_packet_t *p)
{
	g2_packet_t *t;
	if(!p)
		return p;
	t = g2_packet_alloc();
	if(!t)
		return t;
	*t = *p;
	INIT_LIST_HEAD(&t->list);
	INIT_LIST_HEAD(&t->children);
	t->is_freeable = true;
	return t;
}

void noinline g2_packet_free(g2_packet_t *to_free)
{
	struct list_head *e, *n;

	if(!to_free)
		return;

	list_for_each_safe(e, n, &to_free->children) {
		g2_packet_t *entry = list_entry(e, g2_packet_t, list);
		list_del(e);
		g2_packet_free(entry);
	}

	if(unlikely(to_free->data_trunk_is_freeable && to_free->data_trunk.data))
	{
		struct packet_data_store *pds =
			container_of(to_free->data_trunk.data,
			             struct packet_data_store, data);
		if(atomic_dec_test(&pds->refcnt))
			free(pds);
	}

	if(likely(to_free->is_freeable))
	{
#ifndef DEBUG_PACKET_ALLOC
		struct lpacket_buffer *lpb = g2_packet_csetup();
		if(lpb)
		{
			INIT_LIST_HEAD(&to_free->list);
			/* fresh packet, add to front */
			list_add(&to_free->list, &lpb->packets);
			lpb->num++;
		}
		else
#endif
			g2_packet_free_boosted(to_free);
	}
}

void noinline g2_packet_free_glob(g2_packet_t *to_free)
{
	struct list_head *e, *n;

	if(!to_free)
		return;

	list_for_each_safe(e, n, &to_free->children) {
		g2_packet_t *entry = list_entry(e, g2_packet_t, list);
		list_del(e);
		g2_packet_free_glob(entry);
	}

	if(unlikely(to_free->data_trunk_is_freeable && to_free->data_trunk.data))
	{
		struct packet_data_store *pds =
			container_of(to_free->data_trunk.data,
			             struct packet_data_store, data);
		if(atomic_dec_test(&pds->refcnt))
			free(pds);
	}

	if(likely(to_free->is_freeable))
		g2_packet_free_boosted(to_free);
}

void g2_packet_clean(g2_packet_t *to_clean)
{
	bool tmp_info = to_clean->data_trunk_is_freeable;
	bool tmp_free = to_clean->is_freeable;
	struct list_head *e, *n;

	list_for_each_safe(e, n, &to_clean->children) {
		g2_packet_t *entry = list_entry(e, g2_packet_t, list);
		list_del(e);
		g2_packet_free(entry);
	}

	g2_packet_init(to_clean);
	buffer_clear(to_clean->data_trunk);
	to_clean->data_trunk_is_freeable = tmp_info;
	to_clean->is_freeable = tmp_free;
}

static noinline bool g2_packet_steal_data_space(g2_packet_t *p, size_t bytes)
{
	struct packet_data_store *pds;

	if(sizeof(p->pd.out) < bytes)
		goto must_malloc;

	p->data_trunk.data  = p->pd.out;
	p->data_trunk.limit = p->data_trunk.capacity = sizeof(p->pd.out);
	p->data_trunk.pos   = sizeof(p->pd.out) - bytes;
	p->data_trunk_is_freeable = false;

	return true;

must_malloc:
	pds = malloc(sizeof(*pds) + bytes);
	if(!pds)
		return false;
	atomic_set(&pds->refcnt, 1);
	p->data_trunk.data = pds->data;
	p->data_trunk.capacity = bytes;
	buffer_clear(p->data_trunk);
	p->data_trunk_is_freeable = true;
	return true;
}

static noinline bool g2_packet_steal_data_space_lit(g2_packet_t *p, size_t bytes)
{
	struct packet_data_store *pds;
	size_t have_bytes;
	char *buf_start;

	if(likely(PT_UNKNOWN != p->type)) {
		have_bytes = sizeof(p->pd.out);
		buf_start  = p->pd.out;
	} else {
		have_bytes = sizeof(p->pd.out) - p->type_length;
		buf_start  = &p->pd.out[p->type_length];
	}
	if(have_bytes < bytes)
		goto must_malloc;

	p->data_trunk.data  = buf_start;
	p->data_trunk.limit = p->data_trunk.capacity = have_bytes;
	p->data_trunk.pos   = have_bytes - bytes;
	p->data_trunk_is_freeable = false;

	return true;

must_malloc:
	pds = malloc(sizeof(*pds) + bytes);
	if(!pds)
		return false;
	atomic_set(&pds->refcnt, 1);
	p->data_trunk.data = pds->data;
	p->data_trunk.capacity = bytes;
	buffer_clear(p->data_trunk);
	p->data_trunk_is_freeable = true;
	return true;
}

#ifdef PACKET_STATS
static atomic_t packet_type_stats[PT_MAXIMUM];
static void g2_packet_stat_print(void) GCC_ATTR_DESTRUCT;
static void g2_packet_stat_print(void)
{
	unsigned i;
	for(i = 0; i < PT_MAXIMUM; i++)
		logg(LOGF_DEVEL, "%s\tcount: %u\n", g2_ptype_names[i], atomic_read(&packet_type_stats[i]));
}

static void packet_stats_inc(enum g2_ptype type)
{
	atomic_inc(&packet_type_stats[type]);
}
#else
# define packet_stats_inc(x) do { } while(0)
#endif

static bool g2_packet_decide_spec_int(struct ptype_action_args *parg, g2_ptype_action_func const *work_type)
{
	g2_packet_t *packs = parg->source;
	prefetch(&work_type[packs->type]);
	if(unlikely(PT_MAXIMUM <= packs->type)) {
		logg_develd("packet with broken type: %u\n", (unsigned)packs->type);
		return false;
	}

	packet_stats_inc(packs->type);

	if(work_type[packs->type])
	{
		prefetch(*work_type[packs->type]);
		if(PT_CRAWLR == packs->type) {
			if(parg->connec)
				logg_packet("C: %p#I\t*/%s\tC: %s\n", &parg->connec->remote_host, g2_ptype_names[packs->type], packs->is_compound ? "true" : "false");
			else if(parg->src_addr)
				logg_packet("S: %p#I\t*/%s\tC: %s\n", parg->src_addr, g2_ptype_names[packs->type], packs->is_compound ? "true" : "false");
			else
				logg_packet("*/%s\tC: %s\n", g2_ptype_names[packs->type], packs->is_compound ? "true" : "false");
#if 0
		if(likely(empty_action_p != work_type[packs->type] && unimpl_action_p != work_type[packs->type]) &&
			PT_CH != packs->type)
#endif
		}
		return work_type[packs->type](parg);
	}

	logg_packet("%s/%s\tC: %s -> No action\n", parg->father ? g2_ptype_names[parg->father->type] : "", g2_ptype_names[packs->type], packs->is_compound ? "true" : "false");
	return false;
}

static bool magic_route(struct ptype_action_args *parg, uint8_t *guid)
{
	union combo_addr na;

	/* connected? */
	if(parg->connec)
	{
		/* tcp */
		if(parg->connec->flags.upeer) {
			/* forward from connected hubs to our leafs only */
			if(!g2_guid_lookup(guid, GT_LEAF, &na))
				return false;
		}
		else
		{
			if(!g2_guid_lookup(guid, GT_LEAF, &na)) {
				if(!g2_guid_lookup(guid, GT_NEIGHBOUR, &na))
					return false;
				else {
// TODO: udp forwards to "anything"
					/*
					 * our leafes can forward to "anyone", by udp,
					 * which is fucking broken, IMHO...
					 */
				}
			}
		}
	}
	else
	{
		/* udp, only forward to connected nodes, by falltrhough */
		if(!g2_guid_lookup(guid, GT_LEAF, &na)) {
			if(!g2_guid_lookup(guid, GT_NEIGHBOUR, &na))
				return false;
		}
	}

	return !!g2_conreg_for_addr(&na, forward_lit_callback_ignore, parg);
}

bool g2_packet_decide_spec(struct ptype_action_args *parg, g2_ptype_action_func const *work_type)
{
	uint8_t *guid;
	/* if we are called from external (for a root packet), check for routing */
	if(g2_packet_needs_routing(parg->source, &guid))
		return magic_route(parg, guid);

	return g2_packet_decide_spec_int(parg, work_type);
}

/*inline bool g2_packet_decide(g2_connection_t *connec, struct list_head *target, const g2_p_type_t *work_type)
{
	return g2_packet_decide_spec(connec, target, work_type, connec->akt_packet);
}*/

static char const rcsid_p[] GCC_ATTR_USED_VAR = "$Id: G2Packet.c,v 1.12 2004/12/18 18:06:13 redbully Exp redbully $";
/* EOF */
