/*
 * G2Packet.c
 * helper-functions for G2-packets
 *
 * Copyright (c) 2004 - 2009 Jan Seiffert
 *
 * This file is part of g2cd.
 *
 * g2cd is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version
 * 2 as published by the Free Software Foundation.
 *
 * g2cd is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public
 * License along with g2cd; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
 * MA  02111-1307  USA
 *
 * $Id: G2Packet.c,v 1.12 2004/12/18 18:06:13 redbully Exp redbully $
 */

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
/* System includes */
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <stdbool.h>
#include <time.h>
#ifdef HAVE_DLOPEN
# include <dlfcn.h>
#endif
/* other */
#include "lib/other.h"
/* own includes */
#define _G2PACKET_C
#define _NEED_G2_P_TYPE
#include "G2Packet.h"
#include "G2PacketSerializer.h"
#include "G2QHT.h"
#include "G2KHL.h"
#include "G2GUIDCache.h"
#include "G2UDP.h"
#include "G2MainServer.h"
#include "G2ConRegistry.h"
#include "G2QueryKey.h"
#include "lib/sec_buffer.h"
#include "lib/log_facility.h"

/* minutes to seconds */
#define PI_TIMEOUT    (   30)
#define LNI_TIMEOUT   ( 1*60)
#define KHL_TIMEOUT   ( 2*60)
#define QHT_TIMEOUT   ( 5*60)
#define UPROC_TIMEOUT (15*60)
#define G2CDC_TIMEOUT (30*60)

/*
 * Autogenerated packet typer table
 * include NO where else!!
 */
#include "G2PacketTyper.h"

/*
 * Internal Prototypes
 */
static inline bool g2_packet_steal_data_space(g2_packet_t *, size_t);
static bool g2_packet_decide_spec_int(struct ptype_action_args *, g2_ptype_action_func const *);
/* packet handler */
static bool empty_action_p(struct ptype_action_args *);
static bool unimpl_action_p(struct ptype_action_args *);
static bool handle_KHLR(struct ptype_action_args *);
static bool handle_KHLR_UKHLID(struct ptype_action_args *);
static bool handle_KHLR_QK(struct ptype_action_args *);
static bool handle_KHL(struct ptype_action_args *);
static bool handle_KHL_TS(struct ptype_action_args *);
static bool handle_KHL_NH(struct ptype_action_args *);
static bool handle_KHL_NH_GU(struct ptype_action_args *);
static bool handle_KHL_CH(struct ptype_action_args *);
static bool handle_KHL_CH_GU(struct ptype_action_args *);
static bool handle_LNI(struct ptype_action_args *);
static bool handle_LNI_FW(struct ptype_action_args *);
static bool handle_LNI_HS(struct ptype_action_args *);
static bool handle_LNI_NA(struct ptype_action_args *);
static bool handle_LNI_GU(struct ptype_action_args *);
static bool handle_LNI_QK(struct ptype_action_args *);
static bool handle_LNI_V(struct ptype_action_args *);
static bool handle_PI(struct ptype_action_args *);
static bool handle_PI_UDP(struct ptype_action_args *);
static bool handle_PI_RELAY(struct ptype_action_args *);
static bool handle_Q2(struct ptype_action_args *);
static bool handle_QHT(struct ptype_action_args *);
static bool handle_QKR(struct ptype_action_args *);
static bool handle_QKR_RNA(struct ptype_action_args *parg);
static bool handle_QKR_QNA(struct ptype_action_args *parg);
static bool handle_QKR_SNA(struct ptype_action_args *parg);
static bool handle_QKR_REF(struct ptype_action_args *parg);
static bool handle_QKA(struct ptype_action_args *);
static bool handle_QKA_QK(struct ptype_action_args *);
static bool handle_QKA_SNA(struct ptype_action_args *);
static bool handle_QKA_QNA(struct ptype_action_args *);
static bool handle_QKA_CACHED(struct ptype_action_args *);
static bool handle_HAW(struct ptype_action_args *);
static bool handle_UPROC(struct ptype_action_args *);
static bool handle_UPROD(struct ptype_action_args *);
static bool handle_G2CDC(struct ptype_action_args *);

/*
 * Packet dicts
 */
/* main dict */
const g2_ptype_action_func g2_packet_dict[PT_MAXIMUM] GCC_ATTR_VIS("hidden") =
{
	[PT_G2CDc ] = handle_G2CDC,
	[PT_KHL   ] = handle_KHL,
	[PT_LNI   ] = handle_LNI,
	[PT_HAW   ] = handle_HAW,
	[PT_PI    ] = handle_PI,
	[PT_PO    ] = unimpl_action_p,
	[PT_PUSH  ] = empty_action_p, /* we do not push */
	[PT_Q2    ] = handle_Q2,
	[PT_QA    ] = unimpl_action_p,
	[PT_QHT   ] = handle_QHT,
	[PT_QKR   ] = handle_QKR,
	[PT_QKA   ] = handle_QKA,
	[PT_UPROC ] = handle_UPROC,
	[PT_UPROD ] = handle_UPROD,
};

const g2_ptype_action_func g2_packet_dict_udp[PT_MAXIMUM] GCC_ATTR_VIS("hidden") =
{
	[PT_CRAWLA] = empty_action_p, /* we don't request crawls */
	[PT_CRAWLR] = unimpl_action_p,
	[PT_KHLA  ] = empty_action_p, /* we don't request khls by udp */
	[PT_KHLR  ] = handle_KHLR,
	[PT_PI    ] = handle_PI,
	[PT_JCT   ] = empty_action_p, /* no answer needed, it's ACKed */
	[PT_Q2    ] = unimpl_action_p,
	[PT_QKR   ] = handle_QKR,
	[PT_QKA   ] = handle_QKA,
	[PT_PUSH  ] = empty_action_p, /* we do not push */
};

/* PI-childs */
static const g2_ptype_action_func PI_packet_dict[PT_MAXIMUM] =
{
	[PT_TO    ] = empty_action_p,
	[PT_UDP   ] = handle_PI_UDP,
	[PT_RELAY ] = handle_PI_RELAY,
};

/* LNI-childs */
static const g2_ptype_action_func LNI_packet_dict[PT_MAXIMUM] =
{
	[PT_TO] = empty_action_p,
	[PT_FW] = handle_LNI_FW,
	[PT_GU] = handle_LNI_GU,
	[PT_HS] = handle_LNI_HS,
	[PT_LS] = empty_action_p,
	[PT_NA] = handle_LNI_NA,
	[PT_QK] = handle_LNI_QK,
	[PT_V ] = handle_LNI_V,
};

/* KHLR-childs */
/*
 * This is speculation, this packet is not documented, only
 * the answer...
 */
static const g2_ptype_action_func KHLR_packet_dict[PT_MAXIMUM] =
{
	[PT_TO    ] = empty_action_p,
	[PT_UKHLID] = handle_KHLR_UKHLID,
	[PT_QK    ] = handle_KHLR_QK,
};

/* KHL-childs */
static const g2_ptype_action_func KHL_packet_dict[PT_MAXIMUM] =
{
	[PT_TO] = empty_action_p,
	[PT_TS] = handle_KHL_TS,
	[PT_NH] = handle_KHL_NH,
	[PT_CH] = handle_KHL_CH,
};

/* KHL/NH-childs */
static const g2_ptype_action_func KHL_NH_packet_dict[PT_MAXIMUM] =
{
	[PT_GU] = handle_KHL_NH_GU,
	[PT_V ] = empty_action_p,
	[PT_LS] = empty_action_p,
	[PT_HS] = empty_action_p,
};

/* KHL/CH-childs */
static const g2_ptype_action_func KHL_CH_packet_dict[PT_MAXIMUM] =
{
	[PT_GU] = handle_KHL_CH_GU,
	[PT_V ] = empty_action_p,
	[PT_LS] = empty_action_p,
	[PT_HS] = empty_action_p,
};

/* Q2-childs */
static const g2_ptype_action_func Q2_packet_dict[PT_MAXIMUM] =
{
	[PT_TO ] = empty_action_p,
	[PT_UDP] = unimpl_action_p,
	[PT_URN] = unimpl_action_p,
	[PT_DN ] = unimpl_action_p,
	[PT_MD ] = unimpl_action_p,
	[PT_SZR] = unimpl_action_p,
	[PT_I  ] = unimpl_action_p,
};

/* QA-childs */
static const g2_ptype_action_func QA_packet_dict[PT_MAXIMUM] =
{
	[PT_TO] = empty_action_p,
	[PT_TS] = unimpl_action_p,
	[PT_D ] = unimpl_action_p,
	[PT_S ] = unimpl_action_p,
	[PT_RA] = unimpl_action_p,
	[PT_FR] = unimpl_action_p,
};

/* QH2-childs */
static const g2_ptype_action_func QH2_packet_dict[PT_MAXIMUM] =
{
	[PT_TO  ] = empty_action_p,
	[PT_GU  ] = unimpl_action_p,
	[PT_NA  ] = unimpl_action_p,
	[PT_NH  ] = unimpl_action_p,
	[PT_V   ] = unimpl_action_p,
	[PT_BUP ] = unimpl_action_p,
	[PT_PCH ] = unimpl_action_p,
	[PT_HG  ] = unimpl_action_p,
	[PT_H   ] = unimpl_action_p,
	[PT_MD  ] = unimpl_action_p,
	[PT_UPRO] = unimpl_action_p,
};

/* QKR-childs */
static const g2_ptype_action_func QKR_packet_dict[PT_MAXIMUM] =
{
	[PT_TO ] = empty_action_p,
	[PT_RNA] = handle_QKR_RNA,
	[PT_QNA] = handle_QKR_QNA,
	[PT_SNA] = handle_QKR_SNA,
	[PT_REF] = handle_QKR_REF,
};

/* QKA-childs */
static const g2_ptype_action_func QKA_packet_dict[PT_MAXIMUM] =
{
	[PT_TO    ] = empty_action_p,
	[PT_QK    ] = handle_QKA_QK,
	[PT_QNA   ] = handle_QKA_QNA,
	[PT_SNA   ] = handle_QKA_SNA,
	[PT_CACHED] = handle_QKA_CACHED,
};

/* CRAWLR-childs */
static const g2_ptype_action_func CRAWLR_packet_dict[PT_MAXIMUM] =
{
	[PT_TO   ] = empty_action_p,
	[PT_REXT ] = unimpl_action_p,
	[PT_RGPS ] = unimpl_action_p,
	[PT_RLEAF] = unimpl_action_p,
	[PT_RNAME] = unimpl_action_p,
};

/* HAW-childs */
static const g2_ptype_action_func HAW_packet_dict[PT_MAXIMUM] =
{
	[PT_TO] = empty_action_p,
	[PT_HS] = unimpl_action_p,
	[PT_NA] = unimpl_action_p,
	[PT_V ] = unimpl_action_p,
};

#define ENUM_CMD(x, y) str_it(x)
const char const g2_ptype_names[][8] GCC_ATTR_VIS("hidden") =
{
	G2_PACKET_TYPES
};
#undef ENUM_CMD

#define ENUM_CMD(x, y) str_size(str_it(x))
const uint8_t const g2_ptype_names_length[] GCC_ATTR_VIS("hidden") =
{
	G2_PACKET_TYPES
};
#undef ENUM_CMD

/*
 * Packet typer function
 *
 */
void g2_packet_find_type(g2_packet_t *packet, const char type_str[16])
{
	unsigned i = g2_ptype_dict_table[(unsigned char)type_str[0]] << 1;
	unsigned j = 1;

	prefetch(&g2_ptype_state_table[i]);
	packet->type = PT_UNKNOWN;
	if(unlikely((unsigned char)-1 == i))
		goto out;

	do
	{
		const unsigned char x = g2_ptype_state_table[i].c;
		const char match = T_GET_CHAR(x);
		logg_develd_old("\tp x: 0x%02X m: 0x%02X, '%c', %i, %i\n", x, match ? : '0',
			type_str[j] ? : '0', i, g2_ptype_state_table[i].u.d);
		if(likely(type_str[j] == match))
		{
			if(likely(T_IS_LAST(x))) {
				if(likely(type_str[j+1] == '\0')) {
					packet->type = T_GET_TYPE(g2_ptype_state_table[i].u.t);
					break;;
				}
			} else {
				i += T_GET_DELTA(g2_ptype_state_table[i].u.d);
				j++;
				continue;
			}
		}
		if(unlikely(T_IS_END(g2_ptype_state_table[i].u.d)))
			break;
		i++;
	} while(j < 16);

out:
	if(unlikely(PT_UNKNOWN == packet->type))
		logg_posd(LOGF_DEBUG, "Unknown packet type \"%s\"\tC: %s\n", type_str, packet->is_compound ? "true" : "false");
}

/*
 * prebuild packets
 */
static const char packet_po[]    = { 0x08, 'P', 'O', };
static const char packet_uproc[] = { 0x20, 'U', 'P', 'R', 'O', 'C' };

#define logg_packet(x, ...) logg_develd("\t"x, __VA_ARGS__)
#define logg_packet_old(x, ...) logg_develd_old("\t"x, __VA_ARGS__)
#define STDSF	"%s\n"
#define STDLF	"%s -> /%s\n"

/*
 * Packet handler helper
 *
 */
static bool read_na_from_packet(g2_packet_t *source, union combo_addr *target, const char *name)
{
	size_t rem = buffer_remaining(source->data_trunk);
	uint16_t tmp_port;

	if(6 != rem && 18 != rem) {
		logg_packet(STDLF, name, "NA not an IPv4 or IPv6 address");
		return false;
	}

	memset(target, 0, sizeof(*target));
	/* We Assume network byte order for the IP */
	if(6 == rem) {
		target->s_fam = AF_INET;
		get_unaligned(target->in.sin_addr.s_addr, (uint32_t *) buffer_start(source->data_trunk));
		source->data_trunk.pos += sizeof(uint32_t);
	} else {
		target->s_fam = AF_INET6;
		memcpy(&target->in6.sin6_addr.s6_addr, buffer_start(source->data_trunk), INET6_ADDRLEN);
		source->data_trunk.pos += INET6_ADDRLEN;
	}

	/* load port and fix it for those, who sent it the wrong way round */
	get_unaligned(tmp_port, (uint16_t *) buffer_start(source->data_trunk));
	if(!source->big_endian)
		tmp_port = (tmp_port >> 8) | (tmp_port << 8);
	combo_addr_set_port(target, tmp_port);

	logg_packet("%s:\t%p#I\n", name, target);
	return true;
}

/*
 * sna are na without port
 */
static bool read_sna_from_packet(g2_packet_t *source, union combo_addr *target, const char *name)
{
	size_t rem = buffer_remaining(source->data_trunk);

	if(4 != rem && INET6_ADDRLEN != rem) {
		logg_packet(STDLF, name, "SNA not an IPv4 or IPv6 address");
		return false;
	}

	memset(target, 0, sizeof(*target));
	/* We Assume network byte order for the IP */
	if(4 == rem) {
		target->s_fam = AF_INET;
		get_unaligned(target->in.sin_addr.s_addr, (uint32_t *) buffer_start(source->data_trunk));
		source->data_trunk.pos += sizeof(uint32_t);
	} else {
		target->s_fam = AF_INET6;
		memcpy(&target->in6.sin6_addr.s6_addr, buffer_start(source->data_trunk), INET6_ADDRLEN);
		source->data_trunk.pos += INET6_ADDRLEN;
	}

	logg_packet("%s:\t%p#I\n", name, target);
	return true;
}

static bool write_na_to_packet(g2_packet_t *target, union combo_addr *source)
{
	uint16_t port;
	size_t len, old_pos;

	len  = AF_INET == source->s_fam ? sizeof(uint32_t) : INET6_ADDRLEN;
	len += sizeof(port);

	if(!g2_packet_steal_data_space(target, len))
		return false;

	old_pos = target->data_trunk.pos;
	/* We Assume network byte order for the IP */
	if(AF_INET == source->s_fam) {
		put_unaligned(source->in.sin_addr.s_addr,
		              (uint32_t *)buffer_start(target->data_trunk));
		target->data_trunk.pos += sizeof(uint32_t);
	} else {
		memcpy(buffer_start(target->data_trunk),
		       &source->in6.sin6_addr.s6_addr, INET6_ADDRLEN);
		target->data_trunk.pos += INET6_ADDRLEN;
	}

	/*  and use host byte order for the port */
	port = combo_addr_port(source);
	port = ntohs(port);
	put_unaligned(port, (uint16_t *)(buffer_start(target->data_trunk)));

	target->data_trunk.pos = old_pos;
	target->big_endian = HOST_IS_BIGENDIAN;
	return true;
}

static bool write_nats_to_packet(g2_packet_t *target, union combo_addr *source, time_t when)
{
	size_t len, old_pos;
	uint16_t port;

	len  = AF_INET == source->s_fam ? sizeof(uint32_t) : INET6_ADDRLEN;
	len += sizeof(time_t) + sizeof(uint16_t);

	if(!g2_packet_steal_data_space(target, len))
		return false;

	old_pos = target->data_trunk.pos;
	/* We Assume network byte order for the IP */
	if(AF_INET == source->s_fam) {
		put_unaligned(source->in.sin_addr.s_addr,
		              (uint32_t *)buffer_start(target->data_trunk));
		target->data_trunk.pos += sizeof(uint32_t);
	} else {
		memcpy(buffer_start(target->data_trunk),
		       &source->in6.sin6_addr.s6_addr, INET6_ADDRLEN);
		target->data_trunk.pos += INET6_ADDRLEN;
	}

	/*  and use host byte order for the port */
	port = combo_addr_port(source);
	port = ntohs(port);
	put_unaligned(port, (uint16_t *)(buffer_start(target->data_trunk)));
	target->data_trunk.pos += sizeof(uint16_t);

	/* now the time stamp */
	put_unaligned(when, (time_t *)buffer_start(target->data_trunk));

	target->data_trunk.pos = old_pos;
	target->big_endian = HOST_IS_BIGENDIAN;
	return true;
}

static void link_sna_to_packet(g2_packet_t *target, union combo_addr *source)
{
	/* We Assume network byte order for the IP */
	if(AF_INET == source->s_fam){
		target->data_trunk.data = (void *)&source->in.sin_addr.s_addr;
		target->data_trunk.capacity = sizeof(uint32_t);
	} else {
		target->data_trunk.data = (void *)source->in6.sin6_addr.s6_addr;
		target->data_trunk.capacity = INET6_ADDRLEN;
	}
	buffer_clear(target->data_trunk);
	target->big_endian = HOST_IS_BIGENDIAN;
}

static noinline bool skip_child(g2_packet_t *s, const char *name)
{
	bool ret_val = false;

	do
	{
		g2_packet_t child_p;
		child_p.more_bytes_needed = false;
		child_p.packet_decode = CHECK_CONTROLL_BYTE;
		ret_val = g2_packet_decode_from_packet(s, &child_p, 0);
		if(!ret_val) {
			logg_packet(STDLF, name, "broken child");
			break;
		}
		logg_packet("%s -> */%s additinaly found\n", name, g2_ptype_names[child_p.type]);
	} while(ret_val && s->packet_decode != DECODE_FINISHED);

//TODO: handle "reserverd" (important even if unknown) packets?

	return ret_val;
}

static bool skip_unexpected_child(g2_packet_t *s, const char *name)
{
	if(unlikely(s->is_compound))
		return skip_child(s, name);
	return true;
}

static inline bool unexpected_child(g2_packet_t *s, const char *name)
{
	if(s->is_compound) {
		logg_packet("%s\twith child! len: %zu\n", name, buffer_remaining(s->data_trunk));
		return true;
	}
	return false;
}

static bool g2_packet_has_TO(g2_packet_t *src, uint8_t **guid)
{
	char *data;

	/*
	 * This is a utterly dirty Hack
	 * we skim the start of the packet buffer for a TO packet,
	 * without proper decoding.
	 * This allows us to decide to route on a generic level, without
	 * going into the details of all packets, and without repeating
	 * code over and over again.
	 * Shareaza does the same (maybe with a little more checking
	 * hidden in C++ fluff).
	 * Thats also the reason why the TO packet has to be the first
	 * child packet.
	 */

	/* child packets? */
	if(!src->is_compound)
		return false;

	/* enough space for TO packet + guid? */
	if(buffer_remaining(src->data_trunk) < 4 + 16)
		return false;

	/* TO signature? */
	data = buffer_start(src->data_trunk);
	if(data[0] != 0x48)
		return false;
	if(data[1] != 0x10)
		return false;
	if(data[2] != 'T')
		return false;
	if(data[3] != 'O')
		return false;

	*guid = (uint8_t *)&data[4];
	return true;
}

static bool g2_packet_needs_routing(g2_packet_t *src, uint8_t **guid)
{
	/* do we have a to? */
	if(!g2_packet_has_TO(src, guid))
		return false;

	/* is it addressed to us? */
	if(0 == memcmp(server.settings.our_guid, *guid, 16))
		return false; /* handle localy */

	return true;
}

/*
 * Packet handler functions
 *
 *
 */
static bool empty_action_p(struct ptype_action_args *parg GCC_ATTR_UNUSED_PARAM)
{
	/* packet is not useful for us */
	logg_packet("*/%s\tC: %s -> ignored\n", g2_ptype_names[parg->source->type], parg->source->is_compound ? "true" : "false");
	return false;
}

static bool unimpl_action_p(struct ptype_action_args *parg GCC_ATTR_UNUSED_PARAM)
{
	/* packet should be handled,  */
	logg_packet("*/%s\tC: %s -> unimplemented\n", g2_ptype_names[parg->source->type], parg->source->is_compound ? "true" : "false");
	return false;
}

struct KHLR_data
{
	char *id;
	uint32_t query_key;
	bool query_key_valid;
};

static bool handle_KHLR(struct ptype_action_args *parg)
{
	struct khl_entry khle[8];
	struct KHLR_data rdata;
	g2_packet_t *khla, *ts, *yourip, *url;
	size_t res;
	bool ret_val = false;

	rdata.id = NULL;
	rdata.query_key_valid = false;
	if(parg->source->is_compound)
	{
		struct ptype_action_args cparg;
		bool keep_decoding;

		cparg = *parg;
		cparg.opaque = &rdata;
		do
		{
			g2_packet_t child_p;
			cparg.source = &child_p;
			child_p.more_bytes_needed = false;
			child_p.packet_decode = CHECK_CONTROLL_BYTE;
			keep_decoding = g2_packet_decode_from_packet(parg->source, &child_p, 0);
			if(!keep_decoding) {
				logg_packet(STDLF, "KHLR", "broken child");
				break;
			}
			if(likely(child_p.packet_decode == DECODE_FINISHED))
				ret_val |= g2_packet_decide_spec_int(&cparg, KHLR_packet_dict);
		} while(keep_decoding && parg->source->packet_decode != DECODE_FINISHED);

		/* punishment for broken packets: no answer */
		if(parg->source->packet_decode != DECODE_FINISHED)
			return ret_val;
	}

	/*
	 * ------======******** HINT HINT HINT ********======------
	 * <<<<(((({{{{{{[[[[  IMPORTANT NOTICE  ]]]]}}}}}}))))>>>>
	 *
	 * ! ! ! ! there is no query key for KHLR in the spec ! ! ! !
	 *
	 * But this is madness, someone not carefully read the comment
	 * about search security and did not understand why query keys
	 * are needed for UDP querys.
	 * (poisening the sender is a minor problem, harming unrelated
	 * internet nodes is (traffic amplification attack))
	 *
	 * Since we already have a query key infrastructure (and KHLRs
	 * are not supposed for UDP challenged nodes...), use it, to
	 * prevent flooding other/the wrong nodes.
	 *
	 * This is a deviation and so no client will get a KHLA from
	 * us, till they also see a need for this, but till then
	 * i wont be the one who sends unsolicied UDP to a sender
	 * address, which can be spoofed.
	 *
	 * ^+++EOM
	 */
	if(!rdata.query_key_valid)
		return ret_val;

	if(!g2_qk_check(parg->src_addr, rdata.query_key))
		return ret_val;
// TODO: maybe send a query key renewel...

		/* build package */
	khla   = g2_packet_calloc();
	ts     = g2_packet_calloc();
	yourip = g2_packet_calloc();
	url    = g2_packet_calloc();

	if(!(khla && ts))
		goto out_fail;

	khla->type = PT_KHL;
	ts->type   = PT_TS;
	if(g2_packet_steal_data_space(ts, sizeof(time_t)))
	{
		time_t now = local_time_now;
		put_unaligned(now, (time_t *)(buffer_start(ts->data_trunk)));
		ts->big_endian = HOST_IS_BIGENDIAN;
		list_add_tail(&ts->list, &khla->children);
	}
	else
		goto out_fail;

	if(yourip)
	{
		yourip->type = PT_YOURIP;
		if(write_na_to_packet(yourip, parg->src_addr))
			list_add_tail(&yourip->list, &khla->children);
		else
			g2_packet_free(yourip);
	}

	if(url)
	{
		const char *url_str;

		url_str = g2_khl_get_url();
		if(url_str && g2_packet_steal_data_space(url, strlen(url_str)))
		{
			url->type = PT_URL;
			memcpy(buffer_start(yourip->data_trunk), url_str, strlen(url_str));
			url->big_endian = HOST_IS_BIGENDIAN;
			list_add_tail(&url->list, &khla->children);
		}
		else
			g2_packet_free(url);
	}

	if(rdata.id)
	{
		g2_packet_t *ukhlid = g2_packet_calloc();
		if(ukhlid)
		{
			if(g2_packet_steal_data_space(yourip, 16))
			{
				ukhlid->type = PT_UKHLID;
				memcpy(buffer_start(ukhlid->data_trunk), rdata.id, 16);
				ukhlid->big_endian = HOST_IS_BIGENDIAN;
				list_add_tail(&ukhlid->list, &khla->children);
			}
			else
				g2_packet_free(ukhlid);
		}
	}

	res = g2_khl_fill_p(khle, anum(khle), parg->src_addr->s_fam);
	while(res--)
	{
		g2_packet_t *ch = g2_packet_calloc();

		if(!ch)
			break;
		ch->type = PT_CH;
		if(!write_nats_to_packet(ch, &khle[res].na, khle[res].when)) {
			g2_packet_free(ch);
			break;
		}
		list_add_tail(&ch->list, &khla->children);
	}
	khla->big_endian = HOST_IS_BIGENDIAN;

// TODO: fill in our neighbouring hubs

	list_add_tail(&khla->list, parg->target);
	return true;
out_fail:
	g2_packet_free(ts);
	g2_packet_free(khla);
	g2_packet_free(yourip);
	g2_packet_free(url);
	return false;
}

static bool handle_KHLR_UKHLID(struct ptype_action_args *parg)
{
	struct KHLR_data *rdata = parg->opaque;

	if(unlikely(!skip_unexpected_child(parg->source, "/KHLR/UKHLID")))
		return false;

	if(16 == buffer_remaining(parg->source->data_trunk))
		rdata->id = buffer_start(parg->source->data_trunk);
	else
		logg_packet(STDLF, "/KHLR/UKHLID", "UKHLID not a valid ID");

	return false;
}

static bool handle_KHLR_QK(struct ptype_action_args *parg)
{
	g2_packet_t *source = parg->source;
	struct KHLR_data *rdata = parg->opaque;

	if(unlikely(!skip_unexpected_child(parg->source, "/KHLR/QK")))
		return false;

	if(4 != buffer_remaining(source->data_trunk)) {
		logg_packet(STDLF, "/KHLR/QK", "funny length");
		return false;
	}

	get_unaligned_endian(rdata->query_key, (uint32_t *)buffer_start(source->data_trunk), source->big_endian);
	rdata->query_key_valid = true;
	return false;
}

static bool handle_KHL(struct ptype_action_args *parg)
{
	struct khl_entry khle[16];
	struct ptype_action_args cparg;
	g2_packet_t *khl, *ts;
	size_t res;
	bool ret_val = false, keep_decoding;

	cparg = *parg;
	do
	{
		g2_packet_t child_p;
		cparg.source = &child_p;
		child_p.more_bytes_needed = false;
		child_p.packet_decode = CHECK_CONTROLL_BYTE;
		keep_decoding = g2_packet_decode_from_packet(parg->source, &child_p, 0);
		if(!keep_decoding) {
			logg_packet(STDLF, "KHL", "broken child");
			parg->connec->flags.dismissed = true;
			break;
		}
		if(likely(child_p.packet_decode == DECODE_FINISHED))
			ret_val |= g2_packet_decide_spec_int(&cparg, KHL_packet_dict);
	} while(keep_decoding && parg->source->packet_decode != DECODE_FINISHED);

	/* time to send a packet again? */
	if(local_time_now < (parg->connec->u.send_stamps.KHL + (KHL_TIMEOUT)))
		return ret_val;

	/* build package */
	khl = g2_packet_calloc();
	ts  = g2_packet_calloc();

	if(!(khl && ts))
		goto out_fail;

	khl->type = PT_KHL;
	ts->type  = PT_TS;
	if(g2_packet_steal_data_space(ts, sizeof(time_t)))
	{
		time_t now = local_time_now;
		put_unaligned(now, (time_t *)(buffer_start(ts->data_trunk)));
		ts->big_endian = HOST_IS_BIGENDIAN;
		list_add_tail(&ts->list, &khl->children);
	}
	else
		goto out_fail;

	res = g2_khl_fill_p(khle, anum(khle), parg->connec->remote_host.s_fam);
	while(res--)
	{
		g2_packet_t *ch = g2_packet_calloc();

		if(!ch)
			break;
		ch->type = PT_CH;
		if(!write_nats_to_packet(ch, &khle[res].na, khle[res].when)) {
			g2_packet_free(ch);
			break;
		}
		list_add_tail(&ch->list, &khl->children);
	}
	khl->big_endian = HOST_IS_BIGENDIAN;

// TODO: fill in our neighbouring hubs

	list_add_tail(&khl->list, parg->target);
	parg->connec->u.send_stamps.KHL = local_time_now;
	return true;
out_fail:
	g2_packet_free(ts);
	g2_packet_free(khl);
	return false;
}

static bool handle_KHL_TS(struct ptype_action_args *parg)
{
	g2_packet_t *source = parg->source;
	time_t foreign_time;
	time_t local_time;
	foreign_time = local_time = local_time_now;

	if(unlikely(!skip_unexpected_child(source, "/KHL/TS")))
		goto out;

	if(unlikely(4 != buffer_remaining(source->data_trunk) &&
	            8 != buffer_remaining(source->data_trunk))) {
		logg_packet(STDLF, "/KHL/TS", "TS not 4 or 8 byte");
		goto out;
	}

	/* fill the upper bit of time_t if we need more than the recvd 32 bit */
	if(8 == sizeof(time_t))
		foreign_time &= (time_t)0xFFFFFFFF00000000;
	else
		foreign_time = 0;

	/* the most commen case 32-bit time_t and little endian (all the Win-Clients) */
	if(likely(4 == buffer_remaining(source->data_trunk)))
	{
		uint32_t t;
		get_unaligned_endian(t, (uint32_t *)buffer_start(source->data_trunk),
		                     source->big_endian);
		foreign_time |= (time_t)t;
	}
	else
	{
		uint64_t t;
		logg_packet(STDLF, "/KHL", "TS with 8 byte! Ola, a 64-bit OS?");
		/*
		 * Lets try too cludge it together, if we also have a 64-bit OS,
		 * everything will be fine, if not, we hopefully get the lower 32 bit,
		 * and if we don't test at the moment of overflow in 2013 (or when ever)
		 * it should work
		 */
		get_unaligned_endian(t, (uint64_t *)buffer_start(source->data_trunk),
		                     source->big_endian);
		foreign_time = (time_t)t;
	}
	logg_packet("/KHL/TS -> %lu\t%lu\n", (unsigned long)foreign_time, (unsigned long)local_time);

out:
	parg->connec->time_diff = (long)local_time - (long)foreign_time;
	return false;
}

struct KHL_NH_data
{
	uint8_t *guid;
	/*
	 * Vendor code
	 * Hub status
	 * Library statistics (ignore it, we are not in for casual talk...)
	 */
};

static bool handle_KHL_NH(struct ptype_action_args *parg)
{
	union combo_addr addr;
	struct KHL_NH_data rdata;
	g2_packet_t *source = parg->source;
	bool ret_val = false;

	rdata.guid = NULL;
	if(source->is_compound)
	{
		struct ptype_action_args cparg;
		bool keep_decoding;

		cparg = *parg;
		cparg.opaque = &rdata;
		do
		{
			g2_packet_t child_p;
			cparg.source = &child_p;
			child_p.more_bytes_needed = false;
			child_p.packet_decode = CHECK_CONTROLL_BYTE;
			keep_decoding = g2_packet_decode_from_packet(source, &child_p, 0);
			if(!keep_decoding) {
				logg_packet(STDLF, "KHL/NH", "broken child");
				parg->connec->flags.dismissed = true;
				break;
			}
			if(likely(child_p.packet_decode == DECODE_FINISHED))
				ret_val |= g2_packet_decide_spec_int(&cparg, KHL_NH_packet_dict);
		} while(keep_decoding && source->packet_decode != DECODE_FINISHED);
	}

// TODO: a neighbouring hub is different: cluster and routing and foo

	if(source->packet_decode == DECODE_FINISHED &&
	   read_na_from_packet(source, &addr, "/KHL/NH")) {
		if(rdata.guid)
			g2_guid_add(rdata.guid, &addr, local_time_now);
		g2_khl_add(&addr, local_time_now, parg->connec->flags.upeer);
		/* only the NH of our connected hubs are in our cluster */
	}
	return ret_val;
}

static bool handle_KHL_NH_GU(struct ptype_action_args *parg)
{
	struct KHL_NH_data *rdata = parg->opaque;

	if(unlikely(!skip_unexpected_child(parg->source, "/KHL/NH/GU")))
		return false;

	if(16 == buffer_remaining(parg->source->data_trunk))
		rdata->guid = (uint8_t *)buffer_start(parg->source->data_trunk);
	else
		logg_packet(STDLF, "/KHL/NH/GU", "GU not a valid GUID");

	return false;
}

struct KHL_CH_data
{
	uint8_t *guid;
	/*
	 * Vendor code
	 * Hub status
	 * Library statistics (ignore it, we are not in for casual talk...)
	 */
};

static bool handle_KHL_CH(struct ptype_action_args *parg)
{
	struct KHL_CH_data rdata;
	g2_packet_t *source = parg->source;
	g2_connection_t *connec = parg->connec;
	char *src = buffer_start(source->data_trunk);
	size_t remaining = buffer_remaining(source->data_trunk);
	union combo_addr addr;
	time_t when;
	uint16_t tmp_port;
	bool ret_val = false;

	rdata.guid = NULL;
	if(source->is_compound)
	{
		struct ptype_action_args cparg;
		bool keep_decoding;

		cparg = *parg;
		cparg.opaque = &rdata;
		do
		{
			g2_packet_t child_p;
			cparg.source = &child_p;
			child_p.more_bytes_needed = false;
			child_p.packet_decode = CHECK_CONTROLL_BYTE;
			keep_decoding = g2_packet_decode_from_packet(source, &child_p, 0);
			if(!keep_decoding) {
				logg_packet(STDLF, "KHL/NH/CH", "broken child");
				connec->flags.dismissed = true;
				break;
			}
			if(likely(child_p.packet_decode == DECODE_FINISHED))
				ret_val |= g2_packet_decide_spec_int(&cparg, KHL_CH_packet_dict);
		} while(keep_decoding && source->packet_decode != DECODE_FINISHED);
	}

	/* something wrong with the decoding? */
	if(source->packet_decode != DECODE_FINISHED)
		return ret_val; /* in that case we can not continue */

	/*
	 * who thought of that shit???
	 * "Hey, lets cram all kind of binary numbers which will /never/ change
	 * their size into one blob" yeah, maybe on winblow... IPv6? 64bit time_t?
	 *
	 *	IP	Port	TS
	 *	4	2	4	= 10 winblow
	 *	16	2	4	= 20 IPv6
	 *	16	2	8	= 24 IPv6 + 64bit time_t
	 *	4	2	8	= 14 64bit time_t
	 *
	 * and the docs say nothing about endianess...
	 * looks like ip in net byte order, rest in host byte order
	 */

	memset(&addr, 0, sizeof(addr));
	if(8 == sizeof(time_t))
		when = local_time_now & (time_t)0xFFFFFFFF00000000;
	else
		when = 0;
	if(likely(10 == remaining))
	{
		uint32_t t;
		addr.s_fam = AF_INET;
		get_unaligned(addr.in.sin_addr.s_addr, (uint32_t *) src);
		src += sizeof(uint32_t);
		get_unaligned(tmp_port, (uint16_t *) src);
		src += sizeof(uint16_t);
		get_unaligned_endian(t, (uint32_t *) src, source->big_endian);
		when |= (time_t)(t + connec->time_diff);
	}
	else if(20 == remaining)
	{
		uint32_t t;
		addr.s_fam = AF_INET6;
		memcpy(&addr.in6.sin6_addr.s6_addr, src, INET6_ADDRLEN);
		src += INET6_ADDRLEN;
		get_unaligned(tmp_port, (uint16_t *) src);
		src += sizeof(uint16_t);
		get_unaligned_endian(t, (uint32_t *) src, source->big_endian);
		when |= (time_t)(t + connec->time_diff);
	}
	else if(24 == remaining)
	{
		uint64_t t;
		addr.s_fam = AF_INET6;
		memcpy(&addr.in6.sin6_addr.s6_addr, src, INET6_ADDRLEN);
		src += INET6_ADDRLEN;
		get_unaligned(tmp_port, (uint16_t *) src);
		src += sizeof(uint16_t);
		get_unaligned_endian(t, (uint64_t *) src, source->big_endian);
		when = (time_t)(t + connec->time_diff);
	}
	else if(14 == remaining)
	{
		uint64_t t;
		addr.s_fam = AF_INET;
		get_unaligned(addr.in.sin_addr.s_addr, (uint32_t *) src);
		src += sizeof(uint32_t);
		get_unaligned(tmp_port, (uint16_t *) src);
		src += sizeof(uint16_t);
		get_unaligned_endian(t, (uint64_t *) src, source->big_endian);
		when = (time_t)(t + connec->time_diff);
	} else
		goto out;

	if(likely(!source->big_endian))
		tmp_port = (tmp_port >> 8) | (tmp_port << 8);
	combo_addr_set_port(&addr, tmp_port);
	g2_khl_add(&addr, when, false);
	if(rdata.guid)
		g2_guid_add(rdata.guid, &addr, when);
out:
	return ret_val;
}

static bool handle_KHL_CH_GU(struct ptype_action_args *parg)
{
	struct KHL_CH_data *rdata = parg->opaque;

	if(unlikely(!skip_unexpected_child(parg->source, "/KHL/CH/GU")))
		return false;

	if(16 == buffer_remaining(parg->source->data_trunk))
		rdata->guid = (uint8_t *)buffer_start(parg->source->data_trunk);
	else
		logg_packet(STDLF, "/KHL/CH/GU", "GU not a valid GUID");

	return false;
}

struct LNI_data
{
	bool had_LNI_HS;
	bool had_LNI_GU;
};

static bool handle_LNI(struct ptype_action_args *parg)
{
	union combo_addr local_addr;
	struct ptype_action_args cparg;
	g2_packet_t *lni, *na, *gu, *v, *hs;
	g2_connection_t *connec = parg->connec;
	socklen_t sin_size = sizeof(local_addr);
	bool ret_val = false, keep_decoding;
	struct LNI_data rdata;

	rdata.had_LNI_HS = false;
	rdata.had_LNI_GU = false;
	cparg = *parg;
	cparg.opaque = &rdata;
	do
	{
		g2_packet_t child_p;
		cparg.source = &child_p;
		child_p.more_bytes_needed = false;
		child_p.packet_decode = CHECK_CONTROLL_BYTE;
		keep_decoding = g2_packet_decode_from_packet(parg->source, &child_p, 0);
		if(!keep_decoding) {
			logg_packet(STDLF, "LNI", "broken child");
			connec->flags.dismissed = true;
			break;
		}
		if(likely(child_p.packet_decode == DECODE_FINISHED))
			ret_val |= g2_packet_decide_spec_int(&cparg, LNI_packet_dict);
	} while(keep_decoding && parg->source->packet_decode != DECODE_FINISHED);

	if(!rdata.had_LNI_HS && connec->flags.upeer)
	{
		/* demote connection from hub mode */
		connec->flags.upeer = false;
// TODO: remove from hub connections
		/* connection is no hub anymore, add to QHTs */
		g2_conreg_mark_dirty(connec);
		if(connec->sent_qht) {
			struct qhtable *t = connec->sent_qht;
			connec->sent_qht = NULL;
			g2_qht_put(t);
		}
	}

// TODO: update less often?
	/* conreg and guid update only in timeout intervals? */
	if(rdata.had_LNI_GU)
		g2_guid_add(connec->guid, &connec->remote_host, local_time_now);
		/* using remote_host because we registered it with this in the registry */

	/* time to send a packet again? */
	if(unlikely(local_time_now < (connec->u.send_stamps.LNI + (LNI_TIMEOUT))))
		return ret_val;

	/* build package */
	lni = g2_packet_calloc();
	na  = g2_packet_calloc();
	gu  = g2_packet_calloc();
	v   = g2_packet_calloc();
	hs  = likely(server.status.our_server_upeer) ? g2_packet_calloc() : NULL;

	if(!(lni && na))
		goto out_fail;

	lni->type = PT_LNI;
	na->type = PT_NA;

	if(getsockname(connec->com_socket, casa(&local_addr), &sin_size))
		goto out_fail;
	if(!write_na_to_packet(na, &local_addr))
		goto out_fail;
	list_add_tail(&na->list, &lni->children);

	if(v)
	{
		v->type = PT_V;
		v->data_trunk.data     = (void*)(intptr_t)OWN_VENDOR_CODE;
		v->data_trunk.capacity = str_size(OWN_VENDOR_CODE);
		buffer_clear(v->data_trunk);
		list_add_tail(&v->list, &lni->children);
	}
	if(gu)
	{
		gu->type = PT_GU;
		gu->data_trunk.data     = (char *)server.settings.our_guid;
		gu->data_trunk.capacity = sizeof(server.settings.our_guid);
		buffer_clear(gu->data_trunk);
		list_add_tail(&gu->list, &lni->children);
	}
	if(hs)
	{
		hs->type = PT_HS;
		if(g2_packet_steal_data_space(hs, 4))
		{
			uint16_t cons     = (uint16_t)atomic_read(&server.status.act_connection_sum);
			uint16_t max_cons = server.settings.max_connection_sum;
			put_unaligned(cons, (uint16_t *)buffer_start(hs->data_trunk));
			put_unaligned(max_cons, (uint16_t *)(buffer_start(hs->data_trunk)+2));
			hs->big_endian = HOST_IS_BIGENDIAN;
			list_add_tail(&hs->list, &lni->children);
		}
		else
			g2_packet_free(hs);
	}
	lni->big_endian = HOST_IS_BIGENDIAN;
	list_add_tail(&lni->list, parg->target);
	parg->connec->u.send_stamps.LNI = local_time_now;

	return true;
out_fail:
	g2_packet_free(lni);
	g2_packet_free(na);
	g2_packet_free(gu);
	g2_packet_free(v);
	g2_packet_free(hs);
	return false;
}

static bool handle_LNI_FW(struct ptype_action_args *parg)
{
	logg_packet_old("/LNI/FW\n");
	parg->connec->flags.firewalled = true;
// TODO: reset this state if a LNI without FW comes in
	return false;
}

static bool handle_LNI_HS(struct ptype_action_args *parg)
{
	g2_connection_t *connec = parg->connec;
	g2_packet_t *source = parg->source;
	uint16_t akt_leaf = 0, max_leaf = 0;
	size_t rem = buffer_remaining(source->data_trunk);

	/* we can not read any info in this case */
	if(likely(skip_unexpected_child(source, "/LNI/HS")))
	{
		/* sometimes Shareaza only sends 2 bytes, thats only the leaf count */
		if(2 <= rem)
			get_unaligned_endian(akt_leaf, (uint16_t *) buffer_start(source->data_trunk), source->big_endian);
		if(4 <= rem)
			get_unaligned_endian(max_leaf, (uint16_t *) (buffer_start(source->data_trunk)+2), source->big_endian);

		logg_packet("/LNI/HS:\told: %s leaf: %u max: %u\n",
				connec->flags.upeer ? G2_TRUE : G2_FALSE, akt_leaf, max_leaf);
	}

	if(!connec->flags.upeer) {
// TODO: now this connection is a hub connection, add it there
		connec->flags.upeer = true;
		/* connection is now a hub, remove from QHTs */
		g2_conreg_mark_dirty(connec);
	}
	connec->flags.upeer = true;
	((struct LNI_data *)(parg->opaque))->had_LNI_HS = true;

	return false;
}

static bool handle_LNI_GU(struct ptype_action_args *parg)
{
	if(unlikely(!skip_unexpected_child(parg->source, "/LNI/GU")))
		return false;

	if(sizeof(parg->connec->guid) == buffer_remaining(parg->source->data_trunk)) {
		memcpy(parg->connec->guid, buffer_start(parg->source->data_trunk), sizeof(parg->connec->guid));
		((struct LNI_data *)(parg->opaque))->had_LNI_GU = true;
	}
	else
		logg_packet(STDLF, "/LNI/GU", "GU not a valid GUID");

	return false;
}

static bool handle_LNI_QK(struct ptype_action_args *parg)
{
	logg_packet_old("/LNI/QK\t\tlen: %zu\n", buffer_remaining(parg->source->data_trunk));
	parg->connec->flags.query_key_cache = true;
	return false;
}

static bool handle_LNI_NA(struct ptype_action_args *parg)
{
	if(unlikely(!skip_unexpected_child(parg->source, "/LNI/NA")))
		return false;

	read_na_from_packet(parg->source, &parg->connec->sent_addr, "/LNI/NA");
	return false;
}

static bool handle_LNI_V(struct ptype_action_args *parg)
{
	g2_connection_t *connec = parg->connec;
	g2_packet_t *source = parg->source;
	size_t min_length;

	if(unlikely(!skip_unexpected_child(source, "/LNI/V")))
		return false;

	min_length =
		(buffer_remaining(source->data_trunk) < (sizeof(connec->vendor_code)-1) ?
		buffer_remaining(source->data_trunk) : sizeof(connec->vendor_code)-1);
	memcpy(connec->vendor_code, buffer_start(source->data_trunk), min_length);
	connec->vendor_code[min_length] = '\0';

	logg_packet_old(STDLF, "\t/LNI/V", connec->vendor_code);
	
	return false;
}

struct PI_data
{
	union combo_addr addr;
	bool addr_valid;
	bool relay;
};

static bool handle_PI(struct ptype_action_args *parg)
{
	struct PI_data rdata;
	g2_packet_t *source = parg->source;
	g2_connection_t *connec = parg->connec;
	bool ret_val = false;

	/* not simple /PI-packet? */
	rdata.addr_valid = false;
	rdata.relay = false;
	if(source->is_compound)
	{
		struct ptype_action_args cparg;
		bool keep_decoding;

		cparg = *parg;
		cparg.opaque = &rdata;
		do
		{
			g2_packet_t child_p;
			cparg.source = &child_p;
			child_p.more_bytes_needed = false;
			child_p.packet_decode = CHECK_CONTROLL_BYTE;
			keep_decoding = g2_packet_decode_from_packet(source, &child_p, 0);
			if(!keep_decoding) {
				logg_packet(STDLF, "PI", "broken child");
				if(connec)
					connec->flags.dismissed = true;
				break;
			}
			if(likely(child_p.packet_decode == DECODE_FINISHED))
				ret_val |= g2_packet_decide_spec_int(&cparg, PI_packet_dict);
		} while(keep_decoding && source->packet_decode != DECODE_FINISHED);

		if(source->packet_decode != DECODE_FINISHED)
			return ret_val;

		/* broken packet? punish sender */
		if(connec && rdata.relay && !rdata.addr_valid) {
			connec->flags.dismissed = true;
			return ret_val;
		}
	}

	/* tcp connection and not a relay request? */
	if(connec && !rdata.addr_valid) {
		/* check if time to send a packet again? */
		if(local_time_now < (connec->u.send_stamps.PI + (PI_TIMEOUT)))
			return ret_val;
	}

	/* from a tcp connection and a udp addr? */
	if(connec && rdata.addr_valid)
	{
		/* should we answer, or relay it */
		if(rdata.relay)
		{
			struct list_head answer;
			g2_packet_t po, relay;

			INIT_LIST_HEAD(&answer);
			g2_packet_init_on_stack(&po);
			g2_packet_init_on_stack(&relay);

			po.type = PT_PO;
			relay.type = PT_RELAY;
			list_add_tail(&relay.list, &po.children);
			list_add_tail(&po.list, &answer);

			g2_udp_send(&rdata.addr, &answer);
		}
		else
		{
// TODO: relay it to NH
			logg_packet(STDLF, "\t/PI", "relay not implemented!");
		}
	}
	else
	{
		g2_packet_t *po = g2_packet_calloc();
		if(!po) {
			logg_packet(STDLF, "\t/PI", "alloc failed");
			return ret_val;
		}
		po->type = PT_PO;

		list_add_tail(&po->list, parg->target);
		if(connec)
			connec->u.send_stamps.PI = local_time_now;
		ret_val = true;
	}

	return ret_val;
}

static bool handle_PI_UDP(struct ptype_action_args *parg)
{
	struct PI_data *rdata = parg->opaque;

	logg_packet(STDSF, "/PI/UDP\n");
	if(unlikely(!skip_unexpected_child(parg->source, "/PI/UDP")))
		return false;

	rdata->addr_valid =
		read_na_from_packet(parg->source, &rdata->addr, "/PI/UDP");
	return false;
}

static bool handle_PI_RELAY(struct ptype_action_args *parg)
{
	struct PI_data *rdata = parg->opaque;

	logg_packet(STDSF, "/PI/RELAY\n");
	rdata->relay = true;
	return false;
}

static bool handle_Q2(struct ptype_action_args *parg)
{
	struct ptype_action_args cparg;
	bool ret_val = false, keep_decoding;

	cparg = *parg;
	do
	{
		g2_packet_t child_p;
		cparg.source = &child_p;
		child_p.more_bytes_needed = false;
		child_p.packet_decode = CHECK_CONTROLL_BYTE;
		keep_decoding = g2_packet_decode_from_packet(parg->source, &child_p, 0);
		if(!keep_decoding)
		{
			logg_packet(STDLF, "Q2", "broken child");
			parg->connec->flags.dismissed = true;
			break;
		}
		if(child_p.packet_decode == DECODE_FINISHED)
			ret_val |= g2_packet_decide_spec_int(&cparg, Q2_packet_dict);
	} while(keep_decoding && parg->source->packet_decode != DECODE_FINISHED);

	return ret_val;
}

static inline bool handle_QHT_patch(g2_connection_t *connec, g2_packet_t *source)
{
	struct qht_fragment *frag;
	int ret_val;
	const char *patch_txt;

	if(unlikely(!connec->qht)) {
		logg_packet(STDLF, "/QHT-patch", "initial patch without initial reset");
		connec->flags.dismissed = true;
		return false;
	}

	if(unlikely((QHT_PATCH_HEADER_BYTES-1) > buffer_remaining(source->data_trunk))) {
		logg_packet(STDLF, "/QHT-patch", "to short");
		connec->flags.dismissed = true;
		goto qht_patch_end;
	}

	if(unlikely(1 != *(buffer_start(source->data_trunk)+3))) {
		logg_packet(STDLF, "/QHT-patch", "illegal bit-number");
		connec->flags.dismissed = true;
		goto qht_patch_end;
	}
	if(unlikely(connec->flags.dismissed)) {
		logg_packet(STDLF, "/QHT-patch", "connection dissmissed");
		goto qht_patch_end;
	}

	frag = g2_qht_frag_alloc(buffer_remaining(source->data_trunk)
	                         - (QHT_PATCH_HEADER_BYTES-1));
	if(!frag) {
		logg_packet(STDLF, "/QHT-patch", "no mem for fragment");
		connec->flags.dismissed = true;
		goto qht_patch_end;
	}
	frag->nr         = ((unsigned)*buffer_start(source->data_trunk)) & 0x00FF;
	frag->count      = ((unsigned)*(buffer_start(source->data_trunk)+1)) & 0x00FF;
	frag->compressed = ((unsigned)*(buffer_start(source->data_trunk)+2)) & 0x00FF;
	source->data_trunk.pos += QHT_PATCH_HEADER_BYTES-1;
	ret_val = g2_qht_add_frag(connec->qht, frag, (uint8_t *)buffer_start(source->data_trunk));

	if(likely(0 == ret_val)) { /* patch io, but need more */
		logg_packet(STDLF, "/QHT-patch", "patch recieved");
		return false;
	} else if(0 > ret_val) { /* patch nio */
		connec->flags.dismissed = true;
		free(frag);
		goto qht_patch_end;
	}
	/* patch io and complete */
	patch_txt = g2_qht_patch(connec->qht, connec->qht->fragments);
	/* we patched a connection, not some free standing QHT */
	if(!connec->flags.upeer)
		g2_conreg_mark_dirty(connec);
	logg_packet(STDLF, "/QHT-patch", patch_txt ? patch_txt : "some error while appling");
qht_patch_end:
	g2_qht_frag_free(connec->qht->fragments);
	connec->qht->fragments = NULL;
	return false;
}

static inline bool handle_QHT_reset(g2_connection_t *connec, g2_packet_t *source)
{
	uint32_t qht_ent;

	if(unlikely((QHT_RESET_HEADER_BYTES-1) != buffer_remaining(source->data_trunk))) {
		logg_packet(STDLF, "/QHT-reset", "to short");
		connec->flags.dismissed = true;
		return false;
	}
	
	if(unlikely(1 != *(buffer_start(source->data_trunk)+4))) {
		logg_packet(STDLF, "/QHT-reset", "illegal infinity");
		connec->flags.dismissed = true;
		return false;
	}

	get_unaligned_endian(qht_ent, (uint32_t *)buffer_start(source->data_trunk), source->big_endian);
	
	if(unlikely(g2_qht_reset(&connec->qht, qht_ent, server.settings.qht.compress_internal)))
		connec->flags.dismissed = true;
	else if(!connec->flags.upeer)
		g2_conreg_mark_dirty(connec);

	logg_packet(STDSF, "/QHT-reset");
	return false;
}

static bool handle_QHT(struct ptype_action_args *parg)
{
	g2_connection_t *connec = parg->connec;
	g2_packet_t *source = parg->source;
	struct list_head *target = parg->target;
	struct qht_fragment *frags;
	struct qhtable *master_qht;
	g2_packet_t *qht = NULL;
	char tmp;
	bool ret_val = false;

	if(unlikely(!skip_unexpected_child(source, "/QHT")))
		return false;

	if(unlikely(!buffer_remaining(source->data_trunk))) {
		logg_packet(STDLF, "/QHT", "without data?");
		return false;
	}

	tmp = *buffer_start(source->data_trunk);
	source->data_trunk.pos++;
	
	if(1 == tmp)
		ret_val = handle_QHT_patch(connec, source);
	else if(0 == tmp)
		ret_val = handle_QHT_reset(connec, source);
	else
		logg_packet(STDLF, "/QHT", "with unknown command");

	if(unlikely(ret_val) || !connec->flags.upeer || local_time_now < (connec->u.send_stamps.QHT + (QHT_TIMEOUT)))
		return ret_val;

	master_qht = g2_qht_global_get();
	/* "cheap" check if we have to sent the qht */
	if(connec->sent_qht == master_qht) {
		g2_qht_put(master_qht);
		return false;
	}

	if(!connec->sent_qht)
	{
		uint32_t ent;

		qht = g2_packet_calloc();
		if(!qht)
			goto out_fail;
		qht->type = PT_QHT;
		if(!g2_packet_steal_data_space(qht, QHT_RESET_HEADER_BYTES))
			goto out_fail;

		ent = (uint32_t)master_qht->entries;
		*buffer_start(qht->data_trunk) = 0; /* command */
		put_unaligned(ent, (uint32_t*)(buffer_start(qht->data_trunk)+1));
		*(buffer_start(qht->data_trunk)+5) = 1; /* infinity */
		qht->big_endian = HOST_IS_BIGENDIAN;
		list_add_tail(&qht->list, target);
		qht = NULL;
	}

	frags = g2_qht_diff_get_frag(connec->sent_qht, master_qht);
	if(!frags)
		goto out_fail;

	do
	{
		qht = g2_packet_calloc();
		if(!qht)
			goto out_fail_frags;
		qht->type = PT_QHT;

		qht->data_trunk.data = (char *)frags;
		qht->data_trunk.capacity = sizeof(*frags) + frags->length;
		qht->data_trunk.limit = qht->data_trunk.capacity;
		qht->data_trunk.pos = offsetof(struct qht_fragment, data);
		qht->data_trunk_is_freeable = true;

		*buffer_start(qht->data_trunk) = 1; /* command */
		*(buffer_start(qht->data_trunk)+1) = frags->nr; /* fragment no */
		*(buffer_start(qht->data_trunk)+2) = frags->count; /* fragment count */
		*(buffer_start(qht->data_trunk)+3) = frags->compressed; /* compresion */
		*(buffer_start(qht->data_trunk)+4) = 1; /* bits */

		list_add_tail(&qht->list, target);
		frags = frags->next;
	} while(frags);

	g2_qht_put(connec->sent_qht);
	connec->sent_qht = master_qht;
	connec->u.send_stamps.QHT = local_time_now;
	return true;

out_fail_frags:
	g2_qht_frag_free(frags);
out_fail:
	g2_qht_put(master_qht);
	g2_packet_free(qht);
	return false;
}

struct QKR_data
{
	union combo_addr requesting_na;
	union combo_addr queried_na;
	union combo_addr sending_na;
	bool refresh;
	bool requesting_na_valid;
	bool queried_na_valid;
	bool sending_na_valid;
};

static bool handle_QKR(struct ptype_action_args *parg)
{
	struct QKR_data rdata;
	struct list_head answer;
	bool ret_val = false, keep_decoding;

	memset(&rdata.refresh, 0, offsetof(struct QKR_data, sending_na_valid) - offsetof(struct QKR_data, refresh));
	if(parg->source->is_compound)
	{
		struct ptype_action_args cparg = *parg;
		cparg.opaque = &rdata;
		do
		{
			g2_packet_t child_p;
			cparg.source = &child_p;
			child_p.more_bytes_needed = false;
			child_p.packet_decode = CHECK_CONTROLL_BYTE;
			keep_decoding = g2_packet_decode_from_packet(parg->source, &child_p, 0);
			if(!keep_decoding) {
				logg_packet(STDLF, "QKR", "broken child");
				if(parg->connec)
					parg->connec->flags.dismissed = true;
				break;
			}
			if(likely(child_p.packet_decode == DECODE_FINISHED))
				ret_val |= g2_packet_decide_spec_int(&cparg, QKR_packet_dict);
		} while(keep_decoding && parg->source->packet_decode != DECODE_FINISHED);
	}

	/* something wrong with the decoding? */
	if(parg->source->packet_decode != DECODE_FINISHED)
		return ret_val; /* in that case we can not continue */

	logg_packet("QKR from %pI\tC: %s -> \n",
		parg->connec ? &parg->connec->remote_host : parg->src_addr,
		parg->source->is_compound ? "true" : "false");

	if(parg->connec)
	{
		g2_packet_t qkr, sna;

		if(!rdata.queried_na_valid)
			return ret_val;

		if(!rdata.refresh)
		{
//TODO: look into query cache
		}

		g2_packet_init_on_stack(&qkr);
		g2_packet_init_on_stack(&sna);

		link_sna_to_packet(&sna, &rdata.sending_na);
		list_add_tail(&sna.list, &qkr.children);

		qkr.type = PT_QKR;
		qkr.big_endian = HOST_IS_BIGENDIAN;

		INIT_LIST_HEAD(&answer);
		list_add_tail(&qkr.list, &answer);
		g2_udp_send(&rdata.queried_na, &answer);
	}
	else
	{
		g2_packet_t qka, qk, sna;
		union combo_addr *req_addr;
		uint32_t key;

		g2_packet_init_on_stack(&qka);
		g2_packet_init_on_stack(&qk);

		/* should not fail */
		if(!g2_packet_steal_data_space(&qk, sizeof(uint32_t)))
			return ret_val;

		req_addr = !rdata.requesting_na_valid ? parg->src_addr : &rdata.requesting_na;
		if(rdata.sending_na_valid &&
		   !combo_addr_eq_s(req_addr, &rdata.sending_na))
		{
			g2_packet_init_on_stack(&sna);
			link_sna_to_packet(&sna, &rdata.sending_na);
			list_add_tail(&sna.list, &qka.children);
		}

		key = g2_qk_generate(req_addr);
		qk.type = PT_QK;
		put_unaligned(key, (uint32_t *)buffer_start(qk.data_trunk));
		qk.big_endian = HOST_IS_BIGENDIAN;
		list_add_tail(&qk.list, &qka.children);

		qka.big_endian = HOST_IS_BIGENDIAN;
		qka.type = PT_QKA;

		INIT_LIST_HEAD(&answer);
		list_add_tail(&qka.list, &answer);
		g2_udp_send(req_addr, &answer);
	}

	return ret_val;
}

static bool handle_QKR_RNA(struct ptype_action_args *parg)
{
	struct QKR_data *rdata = parg->opaque;

	if(unlikely(!skip_unexpected_child(parg->source, "/QKR/RNA")))
		return false;

	rdata->requesting_na_valid =
		read_na_from_packet(parg->source, &rdata->requesting_na, "/QKR/RNA");
	return false;
}

static bool handle_QKR_QNA(struct ptype_action_args *parg)
{
	struct QKR_data *rdata = parg->opaque;

	/* we can not read an address in this case ATM */
	if(unlikely(!skip_unexpected_child(parg->source, "/QKR/QNA")))
		return false;

	rdata->queried_na_valid =
		read_na_from_packet(parg->source, &rdata->queried_na, "/QKR/QNA");
	return false;
}

static bool handle_QKR_SNA(struct ptype_action_args *parg)
{
	struct QKR_data *rdata = parg->opaque;

	if(unlikely(!skip_unexpected_child(parg->source, "/QKR/SNA")))
		return false;

	rdata->sending_na_valid =
		read_sna_from_packet(parg->source, &rdata->sending_na, "/QKR/SNA");
	return false;
}

static bool handle_QKR_REF(struct ptype_action_args *parg)
{
	struct QKR_data *rdata = parg->opaque;
	rdata->refresh = true;
	return false;
}

struct QKA_data
{
	union combo_addr queried_na;
	union combo_addr sending_na;
	uint32_t query_key;
	bool cached;
	bool query_key_valid;
	bool queried_na_valid;
	bool sending_na_valid;
};

static bool handle_QKA(struct ptype_action_args *parg)
{
	struct ptype_action_args cparg;
	struct QKA_data rdata;
	bool ret_val = false, keep_decoding;

	memset(&rdata.cached, 0, offsetof(struct QKA_data, sending_na_valid) - offsetof(struct QKA_data, cached));
	cparg = *parg;
	cparg.opaque = &rdata;
	do
	{
		g2_packet_t child_p;
		cparg.source = &child_p;
		child_p.more_bytes_needed = false;
		child_p.packet_decode = CHECK_CONTROLL_BYTE;
		keep_decoding = g2_packet_decode_from_packet(parg->source, &child_p, 0);
		if(!keep_decoding) {
			logg_packet(STDLF, "QKA", "broken child");
			if(parg->connec)
				parg->connec->flags.dismissed = true;
			break;
		}
		if(likely(child_p.packet_decode == DECODE_FINISHED))
			ret_val |= g2_packet_decide_spec_int(&cparg, QKA_packet_dict);
	} while(keep_decoding && parg->source->packet_decode != DECODE_FINISHED);

	/* something wrong with the decoding? */
	if(parg->source->packet_decode != DECODE_FINISHED)
		return ret_val; /* in that case we can not continue */

	logg_packet("QKA from %pI\tC: %s -> \n",
		parg->connec ? &parg->connec->remote_host : parg->src_addr,
		parg->source->is_compound ? "true" : "false");

	return ret_val;
}

static bool handle_QKA_QK(struct ptype_action_args *parg)
{
	g2_packet_t *source = parg->source;
	struct QKA_data *rdata = parg->opaque;

	if(unlikely(!skip_unexpected_child(parg->source, "/QKA/QK")))
		return false;

	if(4 != buffer_remaining(source->data_trunk)) {
		logg_packet(STDLF, "/QKA/QK", "funny length");
		return false;
	}

	get_unaligned_endian(rdata->query_key, (uint32_t *)buffer_start(source->data_trunk), source->big_endian);
	rdata->query_key_valid = true;
	return false;
}

static bool handle_QKA_QNA(struct ptype_action_args *parg)
{
	struct QKA_data *rdata = parg->opaque;

	if(unlikely(!skip_unexpected_child(parg->source, "/QKA/QNA")))
		return false;

	rdata->queried_na_valid =
		read_na_from_packet(parg->source, &rdata->queried_na, "/QKA/QNA");
	return false;
}

static bool handle_QKA_SNA(struct ptype_action_args *parg)
{
	struct QKA_data *rdata = parg->opaque;

	if(unlikely(!skip_unexpected_child(parg->source, "/QKR/SNA")))
		return false;

	rdata->sending_na_valid =
		read_sna_from_packet(parg->source, &rdata->sending_na, "/QKA/SNA");
	return false;
}

static bool handle_QKA_CACHED(struct ptype_action_args *parg)
{
	struct QKA_data *rdata = parg->opaque;
	rdata->cached = true;
	return false;
}

static bool handle_HAW(struct ptype_action_args *parg)
{
	struct ptype_action_args cparg;
	g2_packet_t *source = parg->source;
	bool ret_val = false, keep_decoding;

	cparg = *parg;
	do
	{
		g2_packet_t child_p;
		cparg.source = &child_p;
		child_p.more_bytes_needed = false;
		child_p.packet_decode = CHECK_CONTROLL_BYTE;
		keep_decoding = g2_packet_decode_from_packet(source, &child_p, 0);
		if(!keep_decoding) {
			logg_packet(STDLF, "HAW", "broken child");
			parg->connec->flags.dismissed = true;
			break;
		}
		if(child_p.packet_decode == DECODE_FINISHED)
			ret_val |= g2_packet_decide_spec_int(&cparg, HAW_packet_dict);
//		source->num_child++; // put within if
	} while(keep_decoding && source->packet_decode != DECODE_FINISHED);

	if(18 <= buffer_remaining(source->data_trunk))
	{
		uint8_t ttl, hops, guid[16];

		ttl  = *buffer_start(source->data_trunk);
		hops = *(buffer_start(source->data_trunk) + 1);
		memcpy(guid, buffer_start(source->data_trunk) + 2, sizeof(guid));

		logg_packet("/HAW\tttl: %u hops: %u guid: %p#G\n", ttl, hops, guid);
		source->data_trunk.pos += 18;
// TODO: fill in routing/known guids cache
	}
	else
		logg_packet(STDLF, "HAW", "no ttl, hops, guid?");

	return ret_val;
}

static bool handle_UPROC(struct ptype_action_args *parg)
{
	/*
	 * /UPROC-packet, user-profile-request, if we want to and have an
	 * answer, do it.
	 */
	logg_packet_old(STDSF, "/UPROC");
	if(likely(server.settings.profile.want_2_send &&
	   server.settings.profile.xml &&
	   server.settings.profile.xml_length &&
	   server.settings.profile.xml_length < server.settings.default_max_g2_packet_length - 10))
	{
		g2_packet_t *uprod;
		g2_packet_t *xml;

		/* time to send a packet again? */
		if(local_time_now < (parg->connec->u.send_stamps.UPROC + (UPROC_TIMEOUT)))
			return false;

		uprod = g2_packet_calloc();
		xml   = g2_packet_calloc();
		if(!(uprod && xml)) {
			g2_packet_free(uprod);
			g2_packet_free(xml);
			return false;
		}

		uprod->type = PT_UPROD;
		list_add(&xml->list, &uprod->children);
		xml->type = PT_XML;
		xml->data_trunk.data     = (void*)(intptr_t)server.settings.profile.xml;
		xml->data_trunk.capacity = server.settings.profile.xml_length;
		buffer_clear(xml->data_trunk);

		list_add_tail(&uprod->list, parg->target);
		parg->connec->u.send_stamps.UPROC = local_time_now;
		return true;
	}

	return false;
}

static bool handle_UPROD(struct ptype_action_args *parg GCC_ATTR_UNUSED_PARAM)
{
	logg_packet_old(STDSF, "/UPROD");
	if(parg->source->is_compound) {
// TODO: write UPROD subdecoder ?
		logg_packet(STDLF, "/UPROD", "/xxx -> subdecoder?");
	}
	else
		logg_packet(STDLF, "/UPROD", "no child?");
	return false;
}

static bool handle_G2CDC(struct ptype_action_args *parg)
{
#ifdef HAVE_DLOPEN
	static void *handle;
	static time_t last_send;
	const struct s_data
	{
		const unsigned long len;
		const char *data;
	} *s_data;
	g2_packet_t *t;
	
	if(!handle) {
		if(!(handle = dlopen(NULL, RTLD_LAZY)))
			return false;
	}

	(void) dlerror();
	s_data = dlsym(handle, "sbox");
	if(dlerror())
		return false;

	if(local_time_now < (last_send + G2CDC_TIMEOUT))
		return false;
	last_send = local_time_now;

	t = g2_packet_calloc();
	if(!t)
		return false;

	t->type = PT_G2CDc;
	t->big_endian = HOST_IS_BIGENDIAN;
	t->data_trunk.data = (void*)(intptr_t)s_data->data;
	t->data_trunk.capacity = s_data->len;
	buffer_clear(t->data_trunk);
	list_add_tail(&t->list, parg->target);
	return true;
#else
	parg = parg;
	return false;
#endif
}


/********************************************************************
 *
 * helper-functions
 *
 ********************************************************************/
g2_packet_t *g2_packet_init(g2_packet_t *p)
{
	if(!p)
		return p;

	memset(p, 0, offsetof(g2_packet_t, data_trunk));
	/* ATM they are similar to zero */
/*	p->packet_decode = CHECK_CONTROLL_BYTE;
	p->packet_encode = DECIDE_ENCODE; */
	INIT_LIST_HEAD(&p->list);
	INIT_LIST_HEAD(&p->children);
	return p;
}

g2_packet_t *g2_packet_alloc(void)
{
	g2_packet_t *t = malloc(sizeof(g2_packet_t));
	if(t)
		t->is_freeable = true;
	return t;
}

g2_packet_t *g2_packet_calloc(void)
{
	g2_packet_t *t = g2_packet_init(g2_packet_alloc());
	if(t) {
		INIT_PBUF(&t->data_trunk);
		t->is_freeable = true;
	}
	return t;
}

g2_packet_t *g2_packet_clone(g2_packet_t *p)
{
	g2_packet_t *t;
	if(!p)
		return p;
	t = malloc(sizeof(*t));
	if(!t)
		return t;
	*t = *p;
	INIT_LIST_HEAD(&t->list);
	INIT_LIST_HEAD(&t->children);
	t->is_freeable = true;
	return t;
}

void g2_packet_free(g2_packet_t *to_free)
{
	struct list_head *e, *n;

	if(!to_free)
		return;

	list_for_each_safe(e, n, &to_free->children) {
		g2_packet_t *entry = list_entry(e, g2_packet_t, list);
		list_del(e);
		g2_packet_free(entry);
	}

	if(to_free->data_trunk_is_freeable)
		free(to_free->data_trunk.data);

	if(to_free->is_freeable)
		free(to_free);
}

void g2_packet_clean(g2_packet_t *to_clean)
{
	bool tmp_info = to_clean->data_trunk_is_freeable;
	bool tmp_free = to_clean->is_freeable;
	struct list_head *e, *n;

	list_for_each_safe(e, n, &to_clean->children) {
		g2_packet_t *entry = list_entry(e, g2_packet_t, list);
		list_del(e);
		g2_packet_free(entry);
	}

	g2_packet_init(to_clean);
	buffer_clear(to_clean->data_trunk);
	to_clean->data_trunk_is_freeable = tmp_info;
	to_clean->is_freeable = tmp_free;
}

static inline bool g2_packet_steal_data_space(g2_packet_t *p, size_t bytes)
{
	if(sizeof(p->data) < bytes)
		goto must_malloc;

	p->data_trunk.data  = p->data;
	p->data_trunk.limit = p->data_trunk.capacity = sizeof(p->data);
	p->data_trunk.pos   = sizeof(p->data) - bytes;
	p->data_trunk_is_freeable = false;

	return true;
must_malloc:
	p->data_trunk.data = malloc(bytes);
	if(!p->data_trunk.data)
		return false;
	p->data_trunk.capacity = bytes;
	buffer_clear(p->data_trunk);
	p->data_trunk_is_freeable = true;
	return true;
}

static bool g2_packet_decide_spec_int(struct ptype_action_args *parg, g2_ptype_action_func const *work_type)
{
	g2_packet_t *packs = parg->source;
	prefetch(&work_type[packs->type]);
	if(unlikely(PT_MAXIMUM <= packs->type)) {
		logg_develd("packet with broken type: %u\n", (unsigned)packs->type);
		return false;
	}

	if(work_type[packs->type])
	{
		prefetch(*work_type[packs->type]);
		if(likely(empty_action_p != work_type[packs->type] && unimpl_action_p != work_type[packs->type]))
			logg_packet("*/%s\tC: %s\n", g2_ptype_names[packs->type], packs->is_compound ? "true" : "false");
		return work_type[packs->type](parg);
	}

	logg_packet("*/%s\tC: %s -> No action\n", g2_ptype_names[packs->type], packs->is_compound ? "true" : "false");
	return false;
}

static bool magic_route(struct ptype_action_args *parg GCC_ATTR_UNUSED_PARAM, uint8_t *guid GCC_ATTR_UNUSED_PARAM)
{
// TODO: route it
	/*
	 * INSERT INTO code VALUES (wonder)
	 */
	logg_packet("/%s -> wants routing\n", g2_ptype_names[parg->source->type]);
	return false;
}

bool g2_packet_decide_spec(struct ptype_action_args *parg, g2_ptype_action_func const *work_type)
{
	uint8_t *guid;
	/* if we are called from external (for a root packet), check for routing */
	if(g2_packet_needs_routing(parg->source, &guid))
		return magic_route(parg, guid);

	return g2_packet_decide_spec_int(parg, work_type);
}

/*inline bool g2_packet_decide(g2_connection_t *connec, struct list_head *target, const g2_p_type_t *work_type)
{
	return g2_packet_decide_spec(connec, target, work_type, connec->akt_packet);
}*/

static char const rcsid_p[] GCC_ATTR_USED_VAR = "$Id: G2Packet.c,v 1.12 2004/12/18 18:06:13 redbully Exp redbully $";
/* EOF */
