/*
 * G2Packet.c
 * helper-functions for G2-packets
 *
 * Copyright (c) 2004 - 2009 Jan Seiffert
 *
 * This file is part of g2cd.
 *
 * g2cd is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version
 * 2 as published by the Free Software Foundation.
 *
 * g2cd is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public
 * License along with g2cd; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
 * MA  02111-1307  USA
 *
 * $Id: G2Packet.c,v 1.12 2004/12/18 18:06:13 redbully Exp redbully $
 */

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
/* System includes */
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <stdbool.h>
#include <time.h>
#ifdef HAVE_DLOPEN
# include <dlfcn.h>
#endif
/* other */
#include "lib/other.h"
/* own includes */
#define _G2PACKET_C
#define _NEED_G2_P_TYPE
#define G2PACKET_POWER_MONGER
#include "G2Packet.h"
#include "G2PacketSerializer.h"
#include "G2QHT.h"
#include "G2KHL.h"
#include "G2GUIDCache.h"
#include "G2UDP.h"
#include "G2MainServer.h"
#include "G2ConRegistry.h"
#include "G2QueryKey.h"
#include "G2Handler.h"
#include "lib/sec_buffer.h"
#include "lib/log_facility.h"
#include "lib/my_bitops.h"

/* minutes to seconds */
#define PI_TIMEOUT     (   30)
#define LNI_TIMEOUT    ( 1*60)
#define KHL_TIMEOUT    ( 2*60)
#define QHT_TIMEOUT    ( 5*60)
#define CRAWLR_TIMEOUT (10*60)
#define UPROC_TIMEOUT  (15*60)
#define G2CDC_TIMEOUT  (30*60)

/*
 * Autogenerated packet typer table
 * include NO where else!!
 */
#include "G2PacketTyper.h"

/*
 * Internal Prototypes
 */
static bool g2_packet_steal_data_space(g2_packet_t *, size_t);
static bool g2_packet_steal_data_space_lit(g2_packet_t *, size_t);
static bool g2_packet_decide_spec_int(struct ptype_action_args *, g2_ptype_action_func const *);
/* packet handler */
static bool empty_action_p(struct ptype_action_args *);
static bool unimpl_action_p(struct ptype_action_args *);
static bool handle_KHLR(struct ptype_action_args *);
static bool handle_KHLR_UKHLID(struct ptype_action_args *);
static bool handle_KHLR_QK(struct ptype_action_args *);
static bool handle_KHL(struct ptype_action_args *);
static bool handle_KHL_TS(struct ptype_action_args *);
static bool handle_KHL_NH(struct ptype_action_args *);
static bool handle_KHL_NH_GU(struct ptype_action_args *);
static bool handle_KHL_CH(struct ptype_action_args *);
static bool handle_KHL_CH_GU(struct ptype_action_args *);
static bool handle_LNI(struct ptype_action_args *);
static bool handle_LNI_FW(struct ptype_action_args *);
static bool handle_LNI_HS(struct ptype_action_args *);
static bool handle_LNI_NA(struct ptype_action_args *);
static bool handle_LNI_GU(struct ptype_action_args *);
static bool handle_LNI_QK(struct ptype_action_args *);
static bool handle_LNI_V(struct ptype_action_args *);
static bool handle_PI(struct ptype_action_args *);
static bool handle_PI_UDP(struct ptype_action_args *);
static bool handle_PI_RELAY(struct ptype_action_args *);
static bool handle_PO(struct ptype_action_args *);
static bool handle_Q2(struct ptype_action_args *);
static bool handle_Q2_UDP(struct ptype_action_args *);
static bool handle_Q2_QKY(struct ptype_action_args *);
static bool handle_Q2_URN(struct ptype_action_args *);
static bool handle_Q2_DN(struct ptype_action_args *);
static bool handle_Q2_MD(struct ptype_action_args *);
static bool handle_QA(struct ptype_action_args *);
static bool handle_QA_TS(struct ptype_action_args *);
static bool handle_QA_D(struct ptype_action_args *);
static bool handle_QA_S(struct ptype_action_args *);
static bool handle_QH2(struct ptype_action_args *);
static bool handle_QH2_GU(struct ptype_action_args *);
static bool handle_QH2_NA(struct ptype_action_args *);
static bool handle_QHT(struct ptype_action_args *);
static bool handle_QKR(struct ptype_action_args *);
static bool handle_QKR_RNA(struct ptype_action_args *parg);
static bool handle_QKR_QNA(struct ptype_action_args *parg);
static bool handle_QKR_SNA(struct ptype_action_args *parg);
static bool handle_QKR_REF(struct ptype_action_args *parg);
static bool handle_QKA(struct ptype_action_args *);
static bool handle_QKA_QK(struct ptype_action_args *);
static bool handle_QKA_SNA(struct ptype_action_args *);
static bool handle_QKA_QNA(struct ptype_action_args *);
static bool handle_QKA_CACHED(struct ptype_action_args *);
static bool handle_HAW(struct ptype_action_args *);
static bool handle_HAW_NA(struct ptype_action_args *);
static bool handle_UPROC(struct ptype_action_args *);
static bool handle_UPROD(struct ptype_action_args *);
static bool handle_CRAWLR(struct ptype_action_args *);
static bool handle_CRAWLR_REXT(struct ptype_action_args *);
static bool handle_CRAWLR_RGPS(struct ptype_action_args *);
static bool handle_CRAWLR_RNAME(struct ptype_action_args *);
static bool handle_CRAWLR_RLEAF(struct ptype_action_args *);
static bool handle_G2CDC(struct ptype_action_args *);

/*
 * Packet dicts
 */
/* main dict */
const g2_ptype_action_func g2_packet_dict[PT_MAXIMUM] GCC_ATTR_VIS("hidden") =
{
	[PT_G2CDc ] = handle_G2CDC,
	[PT_KHL   ] = handle_KHL,
	[PT_LNI   ] = handle_LNI,
	[PT_HAW   ] = handle_HAW,
	[PT_PI    ] = handle_PI,
	[PT_PO    ] = handle_PO,
	[PT_PUSH  ] = empty_action_p, /* we do not push */
	[PT_Q2    ] = handle_Q2,
	[PT_QA    ] = handle_QA,
	[PT_QH2   ] = handle_QH2,
	[PT_QHT   ] = handle_QHT,
	[PT_QKR   ] = handle_QKR,
	[PT_QKA   ] = handle_QKA,
	[PT_UPROC ] = handle_UPROC,
	[PT_UPROD ] = handle_UPROD,
};

const g2_ptype_action_func g2_packet_dict_udp[PT_MAXIMUM] GCC_ATTR_VIS("hidden") =
{
	[PT_CRAWLA] = empty_action_p, /* we don't request crawls */
	[PT_CRAWLR] = handle_CRAWLR,
	[PT_KHLA  ] = empty_action_p, /* we don't request khls by udp */
	[PT_KHLR  ] = handle_KHLR,
	[PT_PI    ] = handle_PI,
	[PT_PO    ] = empty_action_p, /* yeah, so what */
	[PT_JCT   ] = empty_action_p, /* no answer needed, it's ACKed */
	[PT_Q2    ] = handle_Q2,
	[PT_QA    ] = handle_QA,
	[PT_QH2   ] = handle_QH2,
	[PT_QKR   ] = handle_QKR,
	[PT_QKA   ] = handle_QKA,
	[PT_PUSH  ] = empty_action_p, /* we do not push */
};

/* PI-childs */
static const g2_ptype_action_func PI_packet_dict[PT_MAXIMUM] =
{
	[PT_TO    ] = empty_action_p,
	[PT_UDP   ] = handle_PI_UDP,
	[PT_RELAY ] = handle_PI_RELAY,
};

/* LNI-childs */
static const g2_ptype_action_func LNI_packet_dict[PT_MAXIMUM] =
{
	[PT_TO] = empty_action_p,
	[PT_FW] = handle_LNI_FW,
	[PT_GU] = handle_LNI_GU,
	[PT_HS] = handle_LNI_HS,
	[PT_LS] = empty_action_p,
	[PT_NA] = handle_LNI_NA,
	[PT_QK] = handle_LNI_QK,
	[PT_V ] = handle_LNI_V,
};

/* KHLR-childs */
/*
 * This is speculation, this packet is not documented, only
 * the answer...
 */
static const g2_ptype_action_func KHLR_packet_dict[PT_MAXIMUM] =
{
	[PT_TO    ] = empty_action_p,
	[PT_UKHLID] = handle_KHLR_UKHLID,
	[PT_QK    ] = handle_KHLR_QK,
};

/* KHL-childs */
static const g2_ptype_action_func KHL_packet_dict[PT_MAXIMUM] =
{
	[PT_TO    ] = empty_action_p,
	[PT_TS    ] = handle_KHL_TS,
	[PT_NH    ] = handle_KHL_NH,
	[PT_CH    ] = handle_KHL_CH,
	[PT_YOURIP] = empty_action_p,
};

/* KHL/NH-childs */
static const g2_ptype_action_func KHL_NH_packet_dict[PT_MAXIMUM] =
{
	[PT_GU] = handle_KHL_NH_GU,
	[PT_V ] = empty_action_p,
	[PT_LS] = empty_action_p,
	[PT_HS] = empty_action_p,
};

/* KHL/CH-childs */
static const g2_ptype_action_func KHL_CH_packet_dict[PT_MAXIMUM] =
{
	[PT_GU] = handle_KHL_CH_GU,
	[PT_V ] = empty_action_p,
	[PT_LS] = empty_action_p,
	[PT_HS] = empty_action_p,
};

/* Q2-childs */
static const g2_ptype_action_func Q2_packet_dict[PT_MAXIMUM] =
{
	[PT_TO ] = empty_action_p,
	[PT_UDP] = handle_Q2_UDP,
	[PT_QKY] = handle_Q2_QKY,
	[PT_URN] = handle_Q2_URN,
	[PT_DN ] = handle_Q2_DN,
	[PT_MD ] = handle_Q2_MD,
	[PT_SZR] = empty_action_p,
	[PT_I  ] = empty_action_p,
};

/* QH2-childs */
/*
 * These packets are a nightmare...
 * Since we do not search, all QH2 which pass us are:
 * a) not for us
 * or
 * b) spam, malicious
 * maybe both at the same time.
 *
 * The NA is useless, if we do not intend to know every client there is
 * (but we have to to provide routing...)
 * we could look at the other packets to guess if the node is firewalled,
 * the NH are only interresting as a route back to the client
 * (taking them as khl is to dangerous...)
 * and the guid is only good for this routing, which is important, since
 * the node could be firewalled.
 *
 * BULLSHIT! Everything.
 *
 * At least the guid is a must-have field, check it, so we
 * can drop broken packets before forwarding.
 */
static const g2_ptype_action_func QH2_packet_dict[PT_MAXIMUM] =
{
	[PT_TO   ] = empty_action_p,
	[PT_GU   ] = handle_QH2_GU,
	[PT_NA   ] = handle_QH2_NA,
	[PT_NH   ] = unimpl_action_p,
	[PT_V    ] = empty_action_p, /* not interresting */
	[PT_FW   ] = empty_action_p,
	[PT_BH   ] = empty_action_p,
	[PT_BUP  ] = empty_action_p,
	[PT_BUSY ] = empty_action_p,
	[PT_UNSTA] = empty_action_p,
	[PT_PCH  ] = empty_action_p,
	[PT_HG   ] = empty_action_p,
	[PT_H    ] = empty_action_p,
	[PT_MD   ] = empty_action_p,
	[PT_UPRO ] = empty_action_p,
	[PT_SS   ] = empty_action_p,
};

/* QA-childs */
/*
 * The same is true for QA, but they are trusted a little bit more,
 * since they come from hubs...
 * Check that? How? By knowing every Hub at every corner of
 * the Network?
 * We simply take whats delivered there (as Shareaza), actually we
 * don't care for the khl that much.
 */
static const g2_ptype_action_func QA_packet_dict[PT_MAXIMUM] =
{
	[PT_TO] = empty_action_p,
	[PT_TS] = handle_QA_TS,
	[PT_D ] = handle_QA_D,
	[PT_S ] = handle_QA_S,
	[PT_RA] = empty_action_p,
	[PT_FR] = unimpl_action_p,
};


/* QKR-childs */
static const g2_ptype_action_func QKR_packet_dict[PT_MAXIMUM] =
{
	[PT_TO ] = empty_action_p,
	[PT_RNA] = handle_QKR_RNA,
	[PT_QNA] = handle_QKR_QNA,
	[PT_SNA] = handle_QKR_SNA,
	[PT_REF] = handle_QKR_REF,
};

/* QKA-childs */
static const g2_ptype_action_func QKA_packet_dict[PT_MAXIMUM] =
{
	[PT_TO    ] = empty_action_p,
	[PT_QK    ] = handle_QKA_QK,
	[PT_QNA   ] = handle_QKA_QNA,
	[PT_SNA   ] = handle_QKA_SNA,
	[PT_CACHED] = handle_QKA_CACHED,
};

/* CRAWLR-childs */
static const g2_ptype_action_func CRAWLR_packet_dict[PT_MAXIMUM] =
{
	[PT_TO   ] = empty_action_p,
	[PT_REXT ] = handle_CRAWLR_REXT,
	[PT_RGPS ] = handle_CRAWLR_RGPS,
	[PT_RLEAF] = handle_CRAWLR_RLEAF,
	[PT_RNAME] = handle_CRAWLR_RNAME,
};

/* HAW-childs */
static const g2_ptype_action_func HAW_packet_dict[PT_MAXIMUM] =
{
	[PT_TO] = empty_action_p,
	[PT_HS] = empty_action_p, /* not interresting */
	[PT_NA] = handle_HAW_NA,
	[PT_V ] = empty_action_p, /* not interresting */
};

#define ENUM_CMD(x, y) str_it(x)
const char g2_ptype_names[][8] GCC_ATTR_VIS("hidden") =
{
	G2_PACKET_TYPES
};
#undef ENUM_CMD

#define ENUM_CMD(x, y) str_size(str_it(x))
const uint8_t g2_ptype_names_length[] GCC_ATTR_VIS("hidden") =
{
	G2_PACKET_TYPES
};
#undef ENUM_CMD

/*
 * Packet typer function
 *
 */
void g2_packet_find_type(g2_packet_t *packet, const char type_str[16])
{
	unsigned i = g2_ptype_dict_table[(unsigned char)type_str[0]] << 1;
	unsigned j = 1;

	prefetch(&g2_ptype_state_table[i]);
	packet->type = PT_UNKNOWN;
	if(unlikely((unsigned char)-1 == i))
		goto out;

	do
	{
		const unsigned char x = g2_ptype_state_table[i].c;
		const char match = T_GET_CHAR(x);
		logg_develd_old("\tp x: 0x%02X m: 0x%02X, '%c', %i, %i\n", x, match ? : '0',
			type_str[j] ? : '0', i, g2_ptype_state_table[i].u.d);
		if(likely(type_str[j] == match))
		{
			if(likely(T_IS_LAST(x))) {
				if(likely(type_str[j+1] == '\0')) {
					packet->type = T_GET_TYPE(g2_ptype_state_table[i].u.t);
					break;;
				}
			} else {
				i += T_GET_DELTA(g2_ptype_state_table[i].u.d);
				j++;
				continue;
			}
		}
		if(unlikely(T_IS_END(g2_ptype_state_table[i].u.d)))
			break;
		i++;
	} while(j < 16);

out:
	if(unlikely(PT_UNKNOWN == packet->type))
		logg_posd(LOGF_DEBUG, "Unknown packet type \"%s\"\tC: %s\n", type_str, packet->is_compound ? "true" : "false");
}

/*
 * prebuild packets
 */
static const char packet_po[]    = { 0x08, 'P', 'O', };
static const char packet_uproc[] = { 0x20, 'U', 'P', 'R', 'O', 'C' };

#define logg_packet(x, ...) logg_develd("\t"x, __VA_ARGS__)
#define logg_packet_old(x, ...) logg_develd_old("\t"x, __VA_ARGS__)
#define STDSF	"%s\n"
#define STDLF	"%s -> /%s\n"

/*
 * Packet handler helper
 *
 */
static noinline bool skip_child(g2_packet_t *s, const char *name)
{
	bool ret_val = false;

	do
	{
		g2_packet_t child_p;
		child_p.more_bytes_needed = false;
		child_p.packet_decode = CHECK_CONTROLL_BYTE;
		ret_val = g2_packet_decode_from_packet(s, &child_p, 0);
		if(!ret_val) {
			logg_packet(STDLF, name, "broken child");
			break;
		}
		logg_packet("%s -> */%s additinaly found\n", name, g2_ptype_names[child_p.type]);
	} while(ret_val && s->packet_decode != DECODE_FINISHED);

//TODO: handle "reserverd" (important even if unknown) packets?

	return ret_val;
}

static bool skip_unexpected_child(g2_packet_t *s, const char *name)
{
	if(unlikely(s->is_compound))
		return skip_child(s, name);
	return true;
}

static inline bool unexpected_child(g2_packet_t *s, const char *name)
{
	if(s->is_compound) {
		logg_packet("%s\twith child! len: %zu\n", name, buffer_remaining(s->data_trunk));
		return true;
	}
	return false;
}

static bool read_na_from_packet(g2_packet_t *source, union combo_addr *target, const char *name)
{
	size_t rem = buffer_remaining(source->data_trunk);
	uint16_t tmp_port;

	if(6 != rem && 18 != rem) {
		logg_packet(STDLF, name, "NA not an IPv4 or IPv6 address");
		return false;
	}

	memset(target, 0, sizeof(*target));
	/* We Assume network byte order for the IP */
	if(6 == rem) {
		target->s_fam = AF_INET;
		get_unaligned(target->in.sin_addr.s_addr, (uint32_t *) buffer_start(source->data_trunk));
		source->data_trunk.pos += sizeof(uint32_t);
	} else {
		target->s_fam = AF_INET6;
		memcpy(&target->in6.sin6_addr.s6_addr, buffer_start(source->data_trunk), INET6_ADDRLEN);
		source->data_trunk.pos += INET6_ADDRLEN;
	}

	/* load port and fix it for those, who sent it the wrong way round */
	get_unaligned(tmp_port, (uint16_t *) buffer_start(source->data_trunk));
	if(!source->big_endian)
		tmp_port = (tmp_port >> 8) | (tmp_port << 8);
	combo_addr_set_port(target, tmp_port);

	logg_packet_old("%s:\t%p#I\n", name, target);
	return true;
}

/*
 * sna are a na without port
 */
static bool read_sna_from_packet(g2_packet_t *source, union combo_addr *target, const char *name)
{
	size_t rem = buffer_remaining(source->data_trunk);

	if(4 != rem && INET6_ADDRLEN != rem) {
		logg_packet(STDLF, name, "SNA not an IPv4 or IPv6 address");
		return false;
	}

	memset(target, 0, sizeof(*target));
	/* We Assume network byte order for the IP */
	if(4 == rem) {
		target->s_fam = AF_INET;
		get_unaligned(target->in.sin_addr.s_addr, (uint32_t *) buffer_start(source->data_trunk));
		source->data_trunk.pos += sizeof(uint32_t);
	} else {
		target->s_fam = AF_INET6;
		memcpy(&target->in6.sin6_addr.s6_addr, buffer_start(source->data_trunk), INET6_ADDRLEN);
		source->data_trunk.pos += INET6_ADDRLEN;
	}

	logg_packet("%s:\t%p#I\n", name, target);
	return true;
}

static bool read_ts_from_packet(g2_packet_t *source, time_t *tio, const char *name)
{
	time_t foreign_time;

	foreign_time = local_time_now;
	if(unlikely(!skip_unexpected_child(source, name)))
		goto out;

	if(unlikely(4 != buffer_remaining(source->data_trunk) &&
	            8 != buffer_remaining(source->data_trunk))) {
		logg_packet(STDLF, name, "not 4 or 8 byte");
		goto out;
	}

	/* fill the upper bit of time_t if we need more than the recvd 32 bit */
	if(8 == sizeof(time_t))
		foreign_time &= (time_t)0xFFFFFFFF00000000;
	else
		foreign_time  = 0;

	/* the most commen case 32-bit time_t and little endian (all the Win-Clients) */
	if(likely(4 == buffer_remaining(source->data_trunk)))
	{
		uint32_t t;
		get_unaligned_endian(t, (uint32_t *)buffer_start(source->data_trunk),
		                     source->big_endian);
		foreign_time |= (time_t)t;
	}
	else
	{
		uint64_t t;
		logg_packet(STDLF, name, "with 8 byte! Ola, a 64-bit OS?");
		/*
		 * Lets try too cludge it together, if we also have a 64-bit OS,
		 * everything will be fine, if not, we hopefully get the lower 32 bit,
		 * and if we don't test at the moment of overflow in 2013 (or when ever)
		 * it should work
		 */
		get_unaligned_endian(t, (uint64_t *)buffer_start(source->data_trunk),
		                     source->big_endian);
		foreign_time = (time_t)t;
	}

	*tio = foreign_time;

	return true;
out:
	return false;

}

static bool write_na_to_packet(g2_packet_t *target, union combo_addr *source)
{
	uint16_t port;
	size_t len, old_pos;

	len  = AF_INET == source->s_fam ? sizeof(uint32_t) : INET6_ADDRLEN;
	len += sizeof(port);

	if(!g2_packet_steal_data_space(target, len))
		return false;

	old_pos = target->data_trunk.pos;
	/* We Assume network byte order for the IP */
	if(AF_INET == source->s_fam) {
		put_unaligned(source->in.sin_addr.s_addr,
		              (uint32_t *)buffer_start(target->data_trunk));
		target->data_trunk.pos += sizeof(uint32_t);
	} else {
		memcpy(buffer_start(target->data_trunk),
		       &source->in6.sin6_addr.s6_addr, INET6_ADDRLEN);
		target->data_trunk.pos += INET6_ADDRLEN;
	}

	/*  and use host byte order for the port */
	port = combo_addr_port(source);
	port = ntohs(port);
	put_unaligned(port, (uint16_t *)(buffer_start(target->data_trunk)));

	target->data_trunk.pos = old_pos;
	target->big_endian = HOST_IS_BIGENDIAN;
	return true;
}

static bool write_nats_to_packet(g2_packet_t *target, union combo_addr *source, time_t when)
{
	size_t len, old_pos;
	uint16_t port;

	len  = AF_INET == source->s_fam ? sizeof(uint32_t) : INET6_ADDRLEN;
	len += sizeof(time_t) + sizeof(uint16_t);

	if(!g2_packet_steal_data_space(target, len))
		return false;

	old_pos = target->data_trunk.pos;
	/* We Assume network byte order for the IP */
	if(AF_INET == source->s_fam) {
		put_unaligned(source->in.sin_addr.s_addr,
		              (uint32_t *)buffer_start(target->data_trunk));
		target->data_trunk.pos += sizeof(uint32_t);
	} else {
		memcpy(buffer_start(target->data_trunk),
		       &source->in6.sin6_addr.s6_addr, INET6_ADDRLEN);
		target->data_trunk.pos += INET6_ADDRLEN;
	}

	/*  and use host byte order for the port */
	port = combo_addr_port(source);
	port = ntohs(port);
	put_unaligned(port, (uint16_t *)(buffer_start(target->data_trunk)));
	target->data_trunk.pos += sizeof(uint16_t);

	/* now the time stamp */
	put_unaligned(when, (time_t *)buffer_start(target->data_trunk));

	target->data_trunk.pos = old_pos;
	target->big_endian = HOST_IS_BIGENDIAN;
	return true;
}

static void link_sna_to_packet(g2_packet_t *target, union combo_addr *source)
{
	/* We Assume network byte order for the IP */
	if(AF_INET == source->s_fam){
		target->data_trunk.data = (void *)&source->in.sin_addr.s_addr;
		target->data_trunk.capacity = sizeof(uint32_t);
	} else {
		target->data_trunk.data = (void *)source->in6.sin6_addr.s6_addr;
		target->data_trunk.capacity = INET6_ADDRLEN;
	}
	target->data_trunk_is_freeable = false;
	buffer_clear(target->data_trunk);
	target->big_endian = HOST_IS_BIGENDIAN;
}

static bool write_sna_to_packet(g2_packet_t *target, union combo_addr *source)
{
	size_t len;

	len = AF_INET == source->s_fam ? sizeof(uint32_t) : INET6_ADDRLEN;

	if(!g2_packet_steal_data_space(target, len))
		return false;

	/* We Assume network byte order for the IP */
	if(AF_INET == source->s_fam) {
		put_unaligned(source->in.sin_addr.s_addr,
		              (uint32_t *)buffer_start(target->data_trunk));
	} else {
		memcpy(buffer_start(target->data_trunk),
		       &source->in6.sin6_addr.s6_addr, INET6_ADDRLEN);
	}

	target->big_endian = HOST_IS_BIGENDIAN;
	return true;
}

static bool fill_d_packet(g2_packet_t *d, union combo_addr *taddr, uint16_t leafs)
{
	size_t len, old_pos_in;
	uint16_t port;

	len  = AF_INET == taddr->s_fam ? sizeof(uint32_t) : INET6_ADDRLEN;
	len += sizeof(port) + sizeof(uint16_t);

	if(!g2_packet_steal_data_space(d, len))
		return false;

	d->type = PT_D;
	d->big_endian = HOST_IS_BIGENDIAN;

	old_pos_in = d->data_trunk.pos;
	/* We Assume network byte order for the IP */
	if(AF_INET == taddr->s_fam) {
		put_unaligned(taddr->in.sin_addr.s_addr,
		              (uint32_t *)buffer_start(d->data_trunk));
		d->data_trunk.pos += sizeof(uint32_t);
	} else {
		memcpy(buffer_start(d->data_trunk),
		       &taddr->in6.sin6_addr.s6_addr, INET6_ADDRLEN);
		d->data_trunk.pos += INET6_ADDRLEN;
	}

	/* and use host byte order for the port and leaf count */
	port = combo_addr_port(taddr);
	port = ntohs(port);
	put_unaligned(port, (uint16_t *)(buffer_start(d->data_trunk)));
	d->data_trunk.pos += sizeof(port);

	put_unaligned(leafs, (uint16_t *)(buffer_start(d->data_trunk)));
	d->data_trunk.pos = old_pos_in;

	return true;
}

static bool g2_packet_has_TO(g2_packet_t *src, uint8_t **guid)
{
	char *data;

	/*
	 * This is a utterly dirty Hack
	 * we skim the start of the packet buffer for a TO packet,
	 * without proper decoding.
	 * This allows us to decide to route on a generic level, without
	 * going into the details of all packets, and without repeating
	 * code over and over again.
	 * Shareaza does the same (maybe with a little more checking
	 * hidden in C++ fluff).
	 * Thats also the reason why the TO packet has to be the first
	 * child packet.
	 */

	/* child packets? */
	if(!src->is_compound)
		return false;

	/* enough space for TO packet + guid? */
	if(buffer_remaining(src->data_trunk) < 4 + 16)
		return false;

	/* TO signature? */
	data = buffer_start(src->data_trunk);
	if(data[0] != 0x48)
		return false;
	if(data[1] != 0x10)
		return false;
	if(data[2] != 'T')
		return false;
	if(data[3] != 'O')
		return false;

	*guid = (uint8_t *)&data[4];
	return true;
}

static bool g2_packet_needs_routing(g2_packet_t *src, uint8_t **guid)
{
	/* do we have a to? */
	if(!g2_packet_has_TO(src, guid))
		return false;

	/* is it addressed to us? */
	if(0 == memcmp(server.settings.our_guid, *guid, 16))
		return false; /* handle localy */

	return true;
}

static void g2_packet_send_qka(union combo_addr *req_addr, union combo_addr *send_addr)
{
	struct list_head answer;
	g2_packet_t qka, qk, sna;
	uint32_t key;

	g2_packet_init_on_stack(&qka);
	g2_packet_init_on_stack(&qk);

	/* should not fail */
	if(!g2_packet_steal_data_space(&qk, sizeof(uint32_t)))
		return;

// TODO: check for our own IP
	if(send_addr &&
	   !combo_addr_eq_ip(req_addr, send_addr))
	{
		g2_packet_init_on_stack(&sna);
		link_sna_to_packet(&sna, send_addr);
		list_add_tail(&sna.list, &qka.children);
	}

	key = g2_qk_generate(req_addr);
	qk.type = PT_QK;
	put_unaligned(key, (uint32_t *)buffer_start(qk.data_trunk));
	qk.big_endian = HOST_IS_BIGENDIAN;
	list_add_tail(&qk.list, &qka.children);

	qka.big_endian = HOST_IS_BIGENDIAN;
	qka.type = PT_QKA;

	INIT_LIST_HEAD(&answer);
	list_add_tail(&qka.list, &answer);
	g2_udp_send(req_addr, &answer);
}

static void g2_packet_add2target(g2_packet_t *to_add, struct list_head *target, shortlock_t *target_lock)
{
	if(target_lock)
	{
		shortlock_t_lock(target_lock);
		list_add_tail(&to_add->list, target);
		shortlock_t_unlock(target_lock);
	}
	else
		list_add_tail(&to_add->list, target);
}

static intptr_t forward_lit_callback_ignore(g2_connection_t *con, void *carg)
{
	struct ptype_action_args *parg = carg;
	g2_packet_t *t, *source = parg->source;

	logg_packet("/%s -> wants routing to %p#I\n", g2_ptype_names[parg->source->type], &con->remote_host);
	/*
	 * The connection is locked against removal inside this callback
	 * (but because of this we do not want to lock to long, we have
	 * a whole hash slot locked in the conreg...).
	 * But there may be further locking needed.
	 */
	t = g2_packet_clone(source);
	if(!t)
		return 0;

	/* if we can, steal the data form the source packet */
	if(unlikely(source->data_trunk_is_freeable)) {
		source->data_trunk.data = NULL;
		source->data_trunk.pos = source->data_trunk.limit = source->data_trunk.capacity = 0;
		source->data_trunk_is_freeable = false;
	} else {
		/* data in packet buffer? Adjust */
		if(unlikely(source->data_trunk.data >= source->pd.out &&
		            source->data_trunk.data < &source->pd.out[sizeof(source->pd.out)])) {
			ptrdiff_t diff = source->data_trunk.data - source->pd.out;
			t->data_trunk.data = &t->pd.out[diff];
		}
		else
		{
			/* data still lingers in the recv buff, we have to copy it */
			if(!g2_packet_steal_data_space_lit(t, buffer_remaining(source->data_trunk))) {
				g2_packet_free(t);
				return 0;
			}
			memcpy(buffer_start(t->data_trunk), buffer_start(source->data_trunk),
			       buffer_remaining(source->data_trunk));
		}
	}
	t->is_literal = true;
	g2_handler_con_mark_write(t, con);

	return 0;
}

static intptr_t forward_lit_callback_found(g2_connection_t *con, void *carg)
{
	struct ptype_action_args *parg = carg;
	g2_packet_t *t, *source = parg->source;

	/*
	 * The connection is locked against removal inside this callback
	 * (but because of this we do not want to lock to long, we have
	 * a whole hash slot locked in the conreg...).
	 * But there may be further locking needed.
	 */
	t = g2_packet_clone(source);
	if(!t)
		return 1;

	/* if we can, steal the data form the source packet */
	if(unlikely(source->data_trunk_is_freeable)) {
		source->data_trunk.data = NULL;
		source->data_trunk.pos = source->data_trunk.limit = source->data_trunk.capacity = 0;
		source->data_trunk_is_freeable = false;
	} else {
		/* data in packet buffer? Adjust */
		if(unlikely(source->data_trunk.data >= source->pd.out &&
		            source->data_trunk.data < &source->pd.out[sizeof(source->pd.out)])) {
			ptrdiff_t diff = source->data_trunk.data - source->pd.out;
			t->data_trunk.data = &t->pd.out[diff];
		}
		else
		{
			/* data still lingers in the recv buff, we have to copy it */
			if(!g2_packet_steal_data_space_lit(t, buffer_remaining(source->data_trunk))) {
				g2_packet_free(t);
				return 1;
			}
			memcpy(buffer_start(t->data_trunk), buffer_start(source->data_trunk),
			       buffer_remaining(source->data_trunk));
		}
	}
	t->is_literal = true;
	g2_handler_con_mark_write(t, con);

	return 1;
}

/*
 * Packet handler functions
 *
 *
 */
static bool empty_action_p(struct ptype_action_args *parg GCC_ATTR_UNUSED_PARAM)
{
	/* packet is not useful for us */
	logg_packet("*/%s\tC: %s -> ignored\n", g2_ptype_names[parg->source->type], parg->source->is_compound ? "true" : "false");
	return false;
}

static bool unimpl_action_p(struct ptype_action_args *parg GCC_ATTR_UNUSED_PARAM)
{
	/* packet should be handled,  */
	logg_packet("*/%s\tC: %s -> unimplemented\n", g2_ptype_names[parg->source->type], parg->source->is_compound ? "true" : "false");
	return false;
}

struct KHLR_data
{
	char *id;
	uint32_t query_key;
	bool query_key_valid;
};

static bool handle_KHLR(struct ptype_action_args *parg)
{
	struct khl_entry khle[8];
	struct KHLR_data rdata;
	g2_packet_t *khla, *ts, *yourip, *url;
	size_t res;
	bool ret_val = false;

	rdata.id = NULL;
	rdata.query_key_valid = false;
	if(parg->source->is_compound)
	{
		struct ptype_action_args cparg;
		bool keep_decoding;

		cparg = *parg;
		cparg.opaque = &rdata;
		do
		{
			g2_packet_t child_p;
			cparg.source = &child_p;
			child_p.more_bytes_needed = false;
			child_p.packet_decode = CHECK_CONTROLL_BYTE;
			keep_decoding = g2_packet_decode_from_packet(parg->source, &child_p, 0);
			if(!keep_decoding) {
				logg_packet(STDLF, "KHLR", "broken child");
				break;
			}
			if(likely(child_p.packet_decode == DECODE_FINISHED))
				ret_val |= g2_packet_decide_spec_int(&cparg, KHLR_packet_dict);
		} while(keep_decoding && parg->source->packet_decode != DECODE_FINISHED);

		/* punishment for broken packets: no answer */
		if(parg->source->packet_decode != DECODE_FINISHED)
			return ret_val;
	}

	/*
	 * ------======******** HINT HINT HINT ********======------
	 * <<<<(((({{{{{{[[[[  IMPORTANT NOTICE  ]]]]}}}}}}))))>>>>
	 *
	 * ! ! ! ! there is no query key for KHLR in the spec ! ! ! !
	 *
	 * But this is madness, someone not carefully read the comment
	 * about search security and did not understand why query keys
	 * are needed for UDP querys.
	 * (poisening the sender is a minor problem, harming unrelated
	 * internet nodes is (traffic amplification attack))
	 *
	 * Since we already have a query key infrastructure (and KHLRs
	 * are not supposed for UDP challenged nodes...), use it, to
	 * prevent flooding other/the wrong nodes.
	 *
	 * This is a deviation and so no client will get a KHLA from
	 * us, till they also see a need for this, but till then
	 * i wont be the one who sends unsolicied UDP to a sender
	 * address, which can be spoofed.
	 *
	 * ^+++EOM
	 */
	if(!rdata.query_key_valid)
		return ret_val;

	if(!g2_qk_check(parg->src_addr, rdata.query_key))
		return ret_val;
// TODO: maybe send a query key renewel...

		/* build package */
	khla   = g2_packet_calloc();
	ts     = g2_packet_calloc();
	yourip = g2_packet_calloc();
	url    = g2_packet_calloc();

	if(!(khla && ts))
		goto out_fail;

	khla->type = PT_KHL;
	ts->type   = PT_TS;
	if(g2_packet_steal_data_space(ts, sizeof(time_t)))
	{
		time_t now = local_time_now;
		put_unaligned(now, (time_t *)(buffer_start(ts->data_trunk)));
		ts->big_endian = HOST_IS_BIGENDIAN;
		list_add_tail(&ts->list, &khla->children);
	}
	else
		goto out_fail;

	if(yourip)
	{
		yourip->type = PT_YOURIP;
		if(write_na_to_packet(yourip, parg->src_addr))
			list_add_tail(&yourip->list, &khla->children);
		else
			g2_packet_free(yourip);
	}

	if(url)
	{
		const char *url_str;

		url_str = g2_khl_get_url();
		if(url_str && g2_packet_steal_data_space(url, strlen(url_str)))
		{
			url->type = PT_URL;
			memcpy(buffer_start(yourip->data_trunk), url_str, strlen(url_str));
			url->big_endian = HOST_IS_BIGENDIAN;
			list_add_tail(&url->list, &khla->children);
		}
		else
			g2_packet_free(url);
	}

	if(rdata.id)
	{
		g2_packet_t *ukhlid = g2_packet_calloc();
		if(ukhlid)
		{
			if(g2_packet_steal_data_space(yourip, 16))
			{
				ukhlid->type = PT_UKHLID;
				memcpy(buffer_start(ukhlid->data_trunk), rdata.id, 16);
				ukhlid->big_endian = HOST_IS_BIGENDIAN;
				list_add_tail(&ukhlid->list, &khla->children);
			}
			else
				g2_packet_free(ukhlid);
		}
	}

	res = g2_khl_fill_p(khle, anum(khle), parg->src_addr->s_fam);
	while(res--)
	{
		g2_packet_t *ch = g2_packet_calloc();

		if(!ch)
			break;
		ch->type = PT_CH;
		if(!write_nats_to_packet(ch, &khle[res].na, khle[res].when)) {
			g2_packet_free(ch);
			break;
		}
		list_add_tail(&ch->list, &khla->children);
	}
	khla->big_endian = HOST_IS_BIGENDIAN;

// TODO: fill in our neighbouring hubs

	/* only UDP, no need to lock */
	list_add_tail(&khla->list, parg->target);
	return true;
out_fail:
	g2_packet_free(ts);
	g2_packet_free(khla);
	g2_packet_free(yourip);
	g2_packet_free(url);
	return false;
}

static bool handle_KHLR_UKHLID(struct ptype_action_args *parg)
{
	struct KHLR_data *rdata = parg->opaque;

	if(unlikely(!skip_unexpected_child(parg->source, "/KHLR/UKHLID")))
		return false;

	if(16 == buffer_remaining(parg->source->data_trunk))
		rdata->id = buffer_start(parg->source->data_trunk);
	else
		logg_packet(STDLF, "/KHLR/UKHLID", "UKHLID not a valid ID");

	return false;
}

static bool handle_KHLR_QK(struct ptype_action_args *parg)
{
	g2_packet_t *source = parg->source;
	struct KHLR_data *rdata = parg->opaque;

	if(unlikely(!skip_unexpected_child(parg->source, "/KHLR/QK")))
		return false;

	if(4 != buffer_remaining(source->data_trunk)) {
		logg_packet(STDLF, "/KHLR/QK", "funny length");
		return false;
	}

	get_unaligned_endian(rdata->query_key, (uint32_t *)buffer_start(source->data_trunk), source->big_endian);
	rdata->query_key_valid = true;
	return false;
}

static bool handle_KHL(struct ptype_action_args *parg)
{
	struct khl_entry khle[16];
	struct ptype_action_args cparg;
	g2_packet_t *khl, *ts, *yourip;
	size_t res;
	bool ret_val = false, keep_decoding;

	cparg = *parg;
	do
	{
		g2_packet_t child_p;
		cparg.source = &child_p;
		child_p.more_bytes_needed = false;
		child_p.packet_decode = CHECK_CONTROLL_BYTE;
		keep_decoding = g2_packet_decode_from_packet(parg->source, &child_p, 0);
		if(!keep_decoding) {
			logg_packet(STDLF, "KHL", "broken child");
			parg->connec->flags.dismissed = true;
			return ret_val;
		}
		if(likely(child_p.packet_decode == DECODE_FINISHED))
			ret_val |= g2_packet_decide_spec_int(&cparg, KHL_packet_dict);
	} while(keep_decoding && parg->source->packet_decode != DECODE_FINISHED);

	parg->connec->flags.last_data_active = true;

	/* time to send a packet again? */
	if(local_time_now <
	   (parg->connec->u.handler.send_stamps.KHL + (KHL_TIMEOUT * parg->connec->flags.upeer ? 1 : 3)))
		return ret_val;

	/* build package */
	khl    = g2_packet_calloc();
	ts     = g2_packet_calloc();
	yourip = g2_packet_calloc();

	if(!(khl && ts))
		goto out_fail;

	khl->type = PT_KHL;
	ts->type  = PT_TS;
	if(g2_packet_steal_data_space(ts, sizeof(time_t)))
	{
		time_t now = local_time_now;
		put_unaligned(now, (time_t *)(buffer_start(ts->data_trunk)));
		ts->big_endian = HOST_IS_BIGENDIAN;
		list_add_tail(&ts->list, &khl->children);
	}
	else
		goto out_fail;

	if(yourip)
	{
		if(write_sna_to_packet(yourip, &parg->connec->remote_host))
			list_add_tail(&yourip->list, &khl->children);
		else
			g2_packet_free(yourip);
	}

	res = g2_khl_fill_p(khle, anum(khle), parg->connec->remote_host.s_fam);
	while(res--)
	{
		g2_packet_t *ch = g2_packet_calloc();

		if(!ch)
			break;
		ch->type = PT_CH;
		if(!write_nats_to_packet(ch, &khle[res].na, khle[res].when)) {
			g2_packet_free(ch);
			break;
		}
		list_add_tail(&ch->list, &khl->children);
	}
	khl->big_endian = HOST_IS_BIGENDIAN;

// TODO: fill in our neighbouring hubs

	g2_packet_add2target(khl, parg->target, parg->target_lock);
	parg->connec->u.handler.send_stamps.KHL = local_time_now;
	return true;
out_fail:
	g2_packet_free(yourip);
	g2_packet_free(ts);
	g2_packet_free(khl);
	return false;
}

static bool handle_KHL_TS(struct ptype_action_args *parg)
{
	time_t foreign_time;
	time_t local_time;

	local_time = local_time_now;

	if(read_ts_from_packet(parg->source, &foreign_time, "/KHL/TS")) {
		logg_packet("/KHL/TS -> %lu\t%lu\n", (unsigned long)foreign_time, (unsigned long)local_time);
		parg->connec->time_diff = (long)local_time - (long)foreign_time;
	}

	return false;
}

struct KHL_NH_data
{
	uint8_t *guid;
	/*
	 * Vendor code
	 * Hub status
	 * Library statistics (ignore it, we are not in for casual talk...)
	 */
};

static bool handle_KHL_NH(struct ptype_action_args *parg)
{
	union combo_addr addr;
	struct KHL_NH_data rdata;
	g2_packet_t *source = parg->source;
	bool ret_val = false;

	rdata.guid = NULL;
	if(source->is_compound)
	{
		struct ptype_action_args cparg;
		bool keep_decoding;

		cparg = *parg;
		cparg.opaque = &rdata;
		do
		{
			g2_packet_t child_p;
			cparg.source = &child_p;
			child_p.more_bytes_needed = false;
			child_p.packet_decode = CHECK_CONTROLL_BYTE;
			keep_decoding = g2_packet_decode_from_packet(source, &child_p, 0);
			if(!keep_decoding) {
				logg_packet(STDLF, "KHL/NH", "broken child");
				parg->connec->flags.dismissed = true;
				break;
			}
			if(likely(child_p.packet_decode == DECODE_FINISHED))
				ret_val |= g2_packet_decide_spec_int(&cparg, KHL_NH_packet_dict);
		} while(keep_decoding && source->packet_decode != DECODE_FINISHED);
	}

// TODO: a neighbouring hub is different: cluster and routing and foo

	if(source->packet_decode == DECODE_FINISHED &&
	   read_na_from_packet(source, &addr, "/KHL/NH")) {
		if(rdata.guid)
			g2_guid_add(rdata.guid, &addr, local_time_now, GT_KHL_NEIGHBOUR);
		g2_khl_add(&addr, local_time_now, parg->connec->flags.upeer);
		/* only the NH of our connected hubs are in our cluster */
	}
	return ret_val;
}

static bool handle_KHL_NH_GU(struct ptype_action_args *parg)
{
	struct KHL_NH_data *rdata = parg->opaque;

	if(unlikely(!skip_unexpected_child(parg->source, "/KHL/NH/GU")))
		return false;

	if(16 == buffer_remaining(parg->source->data_trunk))
		rdata->guid = (uint8_t *)buffer_start(parg->source->data_trunk);
	else
		logg_packet(STDLF, "/KHL/NH/GU", "GU not a valid GUID");

	return false;
}

struct KHL_CH_data
{
	uint8_t *guid;
	/*
	 * Vendor code
	 * Hub status
	 * Library statistics (ignore it, we are not in for casual talk...)
	 */
};

static bool handle_KHL_CH(struct ptype_action_args *parg)
{
	struct KHL_CH_data rdata;
	g2_packet_t *source = parg->source;
	g2_connection_t *connec = parg->connec;
	size_t remaining;
	union combo_addr addr;
	time_t when;
	bool ret_val = false;

	rdata.guid = NULL;
	/* revalute unlikely with real network connection */
	if(unlikely(source->is_compound))
	{
		struct ptype_action_args cparg;
		bool keep_decoding;

		cparg = *parg;
		cparg.opaque = &rdata;
		do
		{
			g2_packet_t child_p;
			cparg.source = &child_p;
			child_p.more_bytes_needed = false;
			child_p.packet_decode = CHECK_CONTROLL_BYTE;
			keep_decoding = g2_packet_decode_from_packet(source, &child_p, 0);
			if(!keep_decoding) {
				logg_packet(STDLF, "KHL/NH/CH", "broken child");
				connec->flags.dismissed = true;
				break;
			}
			if(likely(child_p.packet_decode == DECODE_FINISHED))
				ret_val |= g2_packet_decide_spec_int(&cparg, KHL_CH_packet_dict);
		} while(keep_decoding && source->packet_decode != DECODE_FINISHED);
	}

	/* something wrong with the decoding? */
	if(source->packet_decode != DECODE_FINISHED)
		return ret_val; /* in that case we can not continue */

	/*
	 * who thought of that shit???
	 * "Hey, lets cram all kind of binary numbers which will /never/ change
	 * their size into one blob" yeah, maybe on winblow... IPv6? 64bit time_t?
	 *
	 *	IP	Port	TS
	 *	4	2	4	= 10 winblow
	 *	16	2	4	= 22 IPv6
	 *	16	2	8	= 26 IPv6 + 64bit time_t
	 *	4	2	8	= 14 64bit time_t
	 *
	 * and the docs say nothing about endianess...
	 * looks like ip in net byte order, rest in host byte order
	 */

	remaining = buffer_remaining(source->data_trunk);

	if(8 == sizeof(time_t))
		when = local_time_now & (time_t)0xFFFFFFFF00000000ULL;
	else
		when = 0;

	if(10 == remaining || /* IPv4 */
	   22 == remaining    /* IPv6 */)
	{
		char *data = buffer_start(source->data_trunk) + remaining - 4;
		uint32_t t;
		get_unaligned_endian(t, (uint32_t *)data, source->big_endian);
		source->data_trunk.limit -= 4;
		when |= (time_t)(t + connec->time_diff);
	}
	else if(26 == remaining || /* IPv6 + 64Bit time_t */
	        14 == remaining    /*        64Bit time_t */)
	{
		char *data = buffer_start(source->data_trunk) + remaining - 8;
		uint64_t t;
		get_unaligned_endian(t, (uint64_t *)data, source->big_endian);
		source->data_trunk.limit -= 8;
		when = (time_t)(t + connec->time_diff);
	} else {
		logg_packet(STDLF, "/KHL/CH", "funny length");
		goto out;
	}

	if(read_na_from_packet(source, &addr, "/KHL/CH")) {
		g2_khl_add(&addr, when, false);
		if(rdata.guid)
			g2_guid_add(rdata.guid, &addr, when, GT_KHL);
	}

out:
	return ret_val;
}

static bool handle_KHL_CH_GU(struct ptype_action_args *parg)
{
	struct KHL_CH_data *rdata = parg->opaque;

	if(unlikely(!skip_unexpected_child(parg->source, "/KHL/CH/GU")))
		return false;

	if(16 == buffer_remaining(parg->source->data_trunk))
		rdata->guid = (uint8_t *)buffer_start(parg->source->data_trunk);
	else
		logg_packet(STDLF, "/KHL/CH/GU", "GU not a valid GUID");

	return false;
}

struct LNI_data
{
	bool had_LNI_HS;
	bool had_LNI_GU;
};

static bool handle_LNI(struct ptype_action_args *parg)
{
	union combo_addr local_addr;
	struct ptype_action_args cparg;
	g2_packet_t *lni, *na, *gu, *v, *hs;
	g2_connection_t *connec = parg->connec;
	socklen_t sin_size = sizeof(local_addr);
	bool ret_val = false, keep_decoding;
	struct LNI_data rdata;

	rdata.had_LNI_HS = false;
	rdata.had_LNI_GU = false;
	cparg = *parg;
	cparg.opaque = &rdata;
	do
	{
		g2_packet_t child_p;
		cparg.source = &child_p;
		child_p.more_bytes_needed = false;
		child_p.packet_decode = CHECK_CONTROLL_BYTE;
		keep_decoding = g2_packet_decode_from_packet(parg->source, &child_p, 0);
		if(!keep_decoding) {
			logg_packet(STDLF, "LNI", "broken child");
			connec->flags.dismissed = true;
			return ret_val;
		}
		if(likely(child_p.packet_decode == DECODE_FINISHED))
			ret_val |= g2_packet_decide_spec_int(&cparg, LNI_packet_dict);
	} while(keep_decoding && parg->source->packet_decode != DECODE_FINISHED);

	if(!rdata.had_LNI_HS && connec->flags.upeer)
	{
		/* demote connection from hub mode */
		connec->flags.upeer = false;
		g2_conreg_demote_hub(connec);
		/* connection is no hub anymore, add to QHTs */
		g2_conreg_mark_dirty(connec);
		if(connec->sent_qht) {
			struct qhtable *t = connec->sent_qht;
			connec->sent_qht = NULL;
			g2_qht_put(t);
		}
	}

// TODO: update less often?
	/* conreg and guid update only in timeout intervals? */
	if(rdata.had_LNI_GU)
		g2_guid_add(connec->guid, &connec->remote_host, local_time_now,
		            connec->flags.upeer ? GT_NEIGHBOUR : GT_LEAF);
		/* using remote_host because we registered it with this in the registry */

	connec->flags.last_data_active = true;
	/* time to send a packet again? */
	if(unlikely(local_time_now < (connec->u.handler.send_stamps.LNI + (LNI_TIMEOUT))))
		return ret_val;

	/* build package */
	lni = g2_packet_calloc();
	na  = g2_packet_calloc();
	gu  = g2_packet_calloc();
	v   = g2_packet_calloc();
	hs  = likely(server.status.our_server_upeer) ? g2_packet_calloc() : NULL;

	if(!(lni && na))
		goto out_fail;

	lni->type = PT_LNI;
	na->type = PT_NA;

	if(getsockname(connec->com_socket, casa(&local_addr), &sin_size))
		goto out_fail;
	if(!write_na_to_packet(na, &local_addr))
		goto out_fail;
	list_add_tail(&na->list, &lni->children);

	if(v)
	{
		v->type = PT_V;
		v->data_trunk.data     = (void *)(intptr_t)OWN_VENDOR_CODE;
		v->data_trunk.capacity = str_size(OWN_VENDOR_CODE);
		buffer_clear(v->data_trunk);
		list_add_tail(&v->list, &lni->children);
	}
	if(gu)
	{
		gu->type = PT_GU;
		gu->data_trunk.data     = (char *)server.settings.our_guid;
		gu->data_trunk.capacity = sizeof(server.settings.our_guid);
		buffer_clear(gu->data_trunk);
		list_add_tail(&gu->list, &lni->children);
	}
	if(hs)
	{
		hs->type = PT_HS;
		if(g2_packet_steal_data_space(hs, 4))
		{
			uint16_t cons     = (uint16_t)atomic_read(&server.status.act_connection_sum);
			uint16_t max_cons = server.settings.max_connection_sum;
			put_unaligned(cons, (uint16_t *)buffer_start(hs->data_trunk));
			put_unaligned(max_cons, (uint16_t *)(buffer_start(hs->data_trunk)+2));
			hs->big_endian = HOST_IS_BIGENDIAN;
			list_add_tail(&hs->list, &lni->children);
		}
		else
			g2_packet_free(hs);
	}
	lni->big_endian = HOST_IS_BIGENDIAN;

	g2_packet_add2target(lni, parg->target, parg->target_lock);
	parg->connec->u.handler.send_stamps.LNI = local_time_now;

	return true;
out_fail:
	g2_packet_free(lni);
	g2_packet_free(na);
	g2_packet_free(gu);
	g2_packet_free(v);
	g2_packet_free(hs);
	return false;
}

static bool handle_LNI_FW(struct ptype_action_args *parg)
{
	logg_packet_old("/LNI/FW\n");
	parg->connec->flags.firewalled = true;
// TODO: reset this state if a LNI without FW comes in
	return false;
}

static bool handle_LNI_HS(struct ptype_action_args *parg)
{
	g2_connection_t *connec = parg->connec;
	g2_packet_t *source = parg->source;
	uint16_t akt_leaf = 0, max_leaf = 0;
	size_t rem = buffer_remaining(source->data_trunk);

	/* we can not read any info in this case */
	if(likely(skip_unexpected_child(source, "/LNI/HS")))
	{
		/* sometimes Shareaza only sends 2 bytes, thats only the leaf count */
		if(2 <= rem)
			get_unaligned_endian(akt_leaf, (uint16_t *) buffer_start(source->data_trunk), source->big_endian);
		if(4 <= rem)
			get_unaligned_endian(max_leaf, (uint16_t *) (buffer_start(source->data_trunk)+2), source->big_endian);

		connec->u.handler.leaf_count = akt_leaf;
		logg_packet("/LNI/HS:\told: %s leaf: %u max: %u\n",
				connec->flags.upeer ? G2_TRUE : G2_FALSE, akt_leaf, max_leaf);
	}

	if(!connec->flags.upeer) {
		connec->flags.upeer = true;
		g2_conreg_promote_hub(connec);
		/* connection is now a hub, remove from QHTs */
		g2_conreg_mark_dirty(connec);
	}
	connec->flags.upeer = true;
	((struct LNI_data *)(parg->opaque))->had_LNI_HS = true;

	return false;
}

static bool handle_LNI_GU(struct ptype_action_args *parg)
{
	if(unlikely(!skip_unexpected_child(parg->source, "/LNI/GU")))
		return false;

	if(sizeof(parg->connec->guid) == buffer_remaining(parg->source->data_trunk)) {
		memcpy(parg->connec->guid, buffer_start(parg->source->data_trunk), sizeof(parg->connec->guid));
		((struct LNI_data *)(parg->opaque))->had_LNI_GU = true;
	}
	else
		logg_packet(STDLF, "/LNI/GU", "GU not a valid GUID");

	return false;
}

static bool handle_LNI_QK(struct ptype_action_args *parg)
{
	logg_packet_old("/LNI/QK\t\tlen: %zu\n", buffer_remaining(parg->source->data_trunk));
	parg->connec->flags.query_key_cache = true;
	return false;
}

static bool handle_LNI_NA(struct ptype_action_args *parg)
{
	if(unlikely(!skip_unexpected_child(parg->source, "/LNI/NA")))
		return false;

	read_na_from_packet(parg->source, &parg->connec->sent_addr, "/LNI/NA");
	return false;
}

static bool handle_LNI_V(struct ptype_action_args *parg)
{
	g2_connection_t *connec = parg->connec;
	g2_packet_t *source = parg->source;
	size_t min_length;

	if(unlikely(!skip_unexpected_child(source, "/LNI/V")))
		return false;

	min_length =
		(buffer_remaining(source->data_trunk) < (sizeof(connec->vendor_code)-1) ?
		buffer_remaining(source->data_trunk) : sizeof(connec->vendor_code)-1);
	memcpy(connec->vendor_code, buffer_start(source->data_trunk), min_length);
	connec->vendor_code[min_length] = '\0';

	logg_packet_old(STDLF, "\t/LNI/V", connec->vendor_code);
	
	return false;
}

struct PI_data
{
	union combo_addr addr;
	bool addr_valid;
	bool relay;
};

static intptr_t PI_callback(g2_connection_t *con, void *carg)
{
	struct ptype_action_args *parg = carg;
	struct PI_data *rdata = parg->opaque;;
	g2_packet_t *pi, *udp, *relay;

	/*
	 * The connection is locked against removal inside this callback
	 * (but because of this we do not want to lock to long, we have
	 * a whole hash slot locked in the conreg...).
	 * But there may be further locking needed.
	 */

	/*
	 * we simply rebuild the packet, this way we can avoid
	 * to add a child packet to a raw packet. We may loose
	 * unknown/untypical childs by this.
	 */
	pi    = g2_packet_calloc();
	udp   = g2_packet_calloc();
	relay = g2_packet_calloc();

	if(!(pi && udp && relay))
		goto out_fail;

	udp->type = PT_UDP;
	/* buffers are now large enough, should not fail */
	if(!write_na_to_packet(udp, &rdata->addr))
		goto out_fail;

	relay->type = PT_RELAY;
	relay->big_endian = HOST_IS_BIGENDIAN;

	list_add_tail(&udp->list, &pi->children);
	list_add_tail(&relay->list, &pi->children);

	pi->type = PT_PI;
	pi->big_endian = HOST_IS_BIGENDIAN;

	g2_handler_con_mark_write(pi, con);
	return 0;

out_fail:
	g2_packet_free(pi);
	g2_packet_free(udp);
	g2_packet_free(relay);
	return 0;
}

static bool handle_PI(struct ptype_action_args *parg)
{
	struct PI_data rdata;
	g2_packet_t *source = parg->source;
	g2_connection_t *connec = parg->connec;
	bool ret_val = false;

	/* not simple /PI-packet? */
	rdata.addr_valid = false;
	rdata.relay = false;
	if(source->is_compound)
	{
		struct ptype_action_args cparg;
		bool keep_decoding;

		cparg = *parg;
		cparg.opaque = &rdata;
		do
		{
			g2_packet_t child_p;
			cparg.source = &child_p;
			child_p.more_bytes_needed = false;
			child_p.packet_decode = CHECK_CONTROLL_BYTE;
			keep_decoding = g2_packet_decode_from_packet(source, &child_p, 0);
			if(!keep_decoding) {
				logg_packet(STDLF, "PI", "broken child");
				if(connec)
					connec->flags.dismissed = true;
				break;
			}
			if(likely(child_p.packet_decode == DECODE_FINISHED))
				ret_val |= g2_packet_decide_spec_int(&cparg, PI_packet_dict);
		} while(keep_decoding && source->packet_decode != DECODE_FINISHED);

		if(source->packet_decode != DECODE_FINISHED)
			return ret_val;

		/* broken packet? punish sender */
		if(connec && rdata.relay && !rdata.addr_valid) {
			connec->flags.dismissed = true;
			return ret_val;
		}
	}

	/* tcp connection and not a relay request? */
	if(connec && !rdata.addr_valid) {
		/* check if time to send a packet again? */
		if(local_time_now < (connec->u.handler.send_stamps.PI + (PI_TIMEOUT)))
			goto out_ok;
	}

	/* from a tcp connection and a udp addr? */
	if(connec && rdata.addr_valid)
	{
		/* should we answer, or relay it */
		if(rdata.relay)
		{
			struct list_head answer;
			g2_packet_t po, relay;

			INIT_LIST_HEAD(&answer);
			g2_packet_init_on_stack(&po);
			g2_packet_init_on_stack(&relay);

			po.type = PT_PO;
			relay.type = PT_RELAY;
			list_add_tail(&relay.list, &po.children);
			list_add_tail(&po.list, &answer);

			g2_udp_send(&rdata.addr, &answer);
		}
		else
			ret_val |= !!g2_conreg_all_hub(&connec->remote_host, PI_callback, parg);
	}
	else
	{
		g2_packet_t *po = g2_packet_calloc();
		if(!po) {
			logg_packet(STDLF, "\t/PI", "alloc failed");
			return ret_val;
		}
		po->type = PT_PO;

		g2_packet_add2target(po, parg->target, parg->target_lock);
		if(connec)
			connec->u.handler.send_stamps.PI = local_time_now;
		ret_val = true;
	}

out_ok:
	if(connec)
		connec->flags.last_data_active = true;
	return ret_val;
}

static bool handle_PI_UDP(struct ptype_action_args *parg)
{
	struct PI_data *rdata = parg->opaque;

	logg_packet(STDSF, "/PI/UDP");
	if(unlikely(!skip_unexpected_child(parg->source, "/PI/UDP")))
		return false;

	rdata->addr_valid =
		read_na_from_packet(parg->source, &rdata->addr, "/PI/UDP");
	return false;
}

static bool handle_PI_RELAY(struct ptype_action_args *parg)
{
	struct PI_data *rdata = parg->opaque;

	logg_packet(STDSF, "/PI/RELAY");
	rdata->relay = true;
	return false;
}

static bool handle_PO(struct ptype_action_args *parg)
{
	parg->connec->flags.last_data_active = true;
	return false;
}

struct Q2_data
{
	union combo_addr udp_na;
	uint32_t qk;
	char *metadata;
	size_t metadata_len;
	char *dn;
	size_t dn_len;
	uint8_t *s_guid;
	g2_packet_t *qa;
	bool had_urn;
	bool udp_na_valid;
	bool qk_valid;
};

intptr_t g2_packet_leaf_qht_match(g2_connection_t *con, void *data)
{
	struct ptype_action_args *parg = data;
	g2_packet_t *t, *source = parg->source;

	t = g2_packet_clone(source);
	if(!t)
		return 0;

	/* if we have a datatrunk, inc refcnt */
	if(source->data_trunk_is_freeable) {
		struct packet_data_store *pds =
			container_of(source->data_trunk.data,
			             struct packet_data_store, data);
		atomic_inc(&pds->refcnt);
	} else {
		/* data in packet buffer? Adjust */
		if(source->data_trunk.data >= source->pd.out &&
		   source->data_trunk.data < &source->pd.out[sizeof(source->pd.out)]) {
			ptrdiff_t diff = source->data_trunk.data - source->pd.out;
			t->data_trunk.data = &t->pd.out[diff];
		}
		else
		{
			/*
			 * data still lingers in the recv buff, we have to copy it
			 * this should not happen, higher levels should have fixed things
			 */
			if(!g2_packet_steal_data_space_lit(t, buffer_remaining(source->data_trunk))) {
				g2_packet_free(t);
				return 0;
			}
			memcpy(buffer_start(t->data_trunk), buffer_start(source->data_trunk),
			       buffer_remaining(source->data_trunk));
		}
	}
	t->is_literal = true;
	g2_handler_con_mark_write(t, con);
	return 0;
}

intptr_t g2_packet_hub_qht_match(g2_connection_t *con, void *data)
{
	struct ptype_action_args *parg = data;
	g2_packet_t *t, *source = parg->source;

	t = g2_packet_clone(source);
	if(!t)
		goto out;

	/* if we have a datatrunk, inc refcnt */
	if(source->data_trunk_is_freeable) {
		struct packet_data_store *pds =
			container_of(source->data_trunk.data,
			             struct packet_data_store, data);
		atomic_inc(&pds->refcnt);
	} else {
		/* data in packet buffer? Adjust */
		if(source->data_trunk.data >= source->pd.out &&
		   source->data_trunk.data < &source->pd.out[sizeof(source->pd.out)]) {
			ptrdiff_t diff = source->data_trunk.data - source->pd.out;
			t->data_trunk.data = &t->pd.out[diff];
		}
		else
		{
			/*
			 * data still lingers in the recv buff, we have to copy it
			 * this should not happen, higher levels should have fixed things
			 */
			if(!g2_packet_steal_data_space_lit(t, buffer_remaining(source->data_trunk))) {
				g2_packet_free(t);
				goto out;
			}
			memcpy(buffer_start(t->data_trunk), buffer_start(source->data_trunk),
			       buffer_remaining(source->data_trunk));
		}
	}
	t->is_literal = true;
	g2_handler_con_mark_write(t, con);
out:
	return g2_packet_hub_qht_done(con, data);
}

intptr_t g2_packet_hub_qht_done(g2_connection_t *con, void *data)
{
	struct ptype_action_args *parg = data;
	struct Q2_data *rdata = parg->opaque;
	g2_packet_t *d = g2_packet_calloc();

	if(!d)
		return 0;

	if(fill_d_packet(d, &con->sent_addr, con->u.handler.leaf_count))
		list_add_tail(&d->list, &rdata->qa->children);
	else
		g2_packet_free(d);

	return 0;
}

bool g2_packet_search_finalize(uint32_t hashes[], size_t num, void *data, bool hubs)
{
	struct ptype_action_args *parg = data;
	struct Q2_data *rdata = parg->opaque;
	g2_packet_t *qa, *d, *ts, *source = parg->source;
	union combo_addr *our_addr = NULL, backup_addr;

	qa = g2_packet_calloc();
	d  = g2_packet_calloc();
	ts = g2_packet_calloc();

	if(!(qa && d && ts))
		return false;

	if(parg->connec)
	{
		socklen_t sin_size = sizeof(backup_addr);
		/*
		 * get our ip the remote host connected to from
		 * our socket handle
		 */
		if(unlikely(getsockname(parg->connec->com_socket, casa(&backup_addr), &sin_size))) {
			logg_errno(LOGF_DEBUG, "getting local addr of socket");
			our_addr = AF_INET == parg->connec->remote_host.s_fam ?
			           &server.settings.bind.ip4 : &server.settings.bind.ip6;
		}
		else
			our_addr = &backup_addr;
	}
	else
		our_addr = parg->dst_addr;
	if(!our_addr)
		return false;

	if(source->data_trunk_is_freeable) {
	/*
	 * We already have a datatrunk, thats fine, but we have to
	 * remove it later from the source
	 */
	} else {
		if(source->data_trunk.data >= source->pd.out &&
		   source->data_trunk.data < &source->pd.out[sizeof(source->pd.out)]) {
			/* the data is in the packet buffer, thats also fine */
		}
		else
		{
			struct pointer_buff pb = source->data_trunk;
			/* data still lingers in the recv buff, we have to copy it */
			if(!g2_packet_steal_data_space_lit(source, buffer_remaining(pb)))
				goto out_fail_free_all;
			memcpy(buffer_start(source->data_trunk), buffer_start(pb),
			       buffer_remaining(pb));
		}
	}

	if(!fill_d_packet(d, our_addr, atomic_read(&server.status.act_connection_sum)))
		goto out_fail_free_all;

	ts->type   = PT_TS;
	/* should not fail, we should have enough space */
	if(likely(g2_packet_steal_data_space(ts, sizeof(time_t))))
	{
		time_t now = local_time_now;
		put_unaligned(now, (time_t *)(buffer_start(ts->data_trunk)));
		ts->big_endian = HOST_IS_BIGENDIAN;
	}
	else
		goto out_fail_free_all;

	if(!g2_packet_steal_data_space(qa, 16))
		goto out_fail_free_all;

	list_add_tail(&ts->list, &qa->children);
	list_add_tail(&d->list, &qa->children);
	qa->type = PT_QA;
	qa->big_endian = HOST_IS_BIGENDIAN;
	memcpy(buffer_start(qa->data_trunk), rdata->s_guid, 16);

	/*
	 * Do the search!
	 */
	rdata->qa = qa;
	if(hubs)
		g2_qht_match_hubs(hashes, num, data);
	g2_qht_match_leafs(hashes, num, data);

// TODO: add some search hubs

	/* if our source had a buffer, remove it now */
	if(source->data_trunk_is_freeable) {
		struct packet_data_store *pds =
			container_of(source->data_trunk.data,
			             struct packet_data_store, data);
		source->data_trunk.data = NULL;
		source->data_trunk.pos = source->data_trunk.limit = source->data_trunk.capacity = 0;
		source->data_trunk_is_freeable = false;
		if(atomic_dec_test(&pds->refcnt))
			free(pds);
	}

	if(parg->connec)
	{
		if(rdata->udp_na_valid)
			goto do_it_by_udp;
		else
			g2_packet_add2target(qa, parg->target, parg->target_lock);
	}
	else
	{
		if(!combo_addr_eq(&rdata->udp_na, parg->src_addr))
		{
			struct list_head answer;
do_it_by_udp:
			INIT_LIST_HEAD(&answer);
			list_add_tail(&qa->list, &answer);
			g2_udp_send(&rdata->udp_na, &answer);
			g2_packet_free(qa);
			return false;
		}
		else
			g2_packet_add2target(qa, parg->target, parg->target_lock);
	}
	return true;

out_fail_free_all:
	g2_packet_free(d);
	g2_packet_free(ts);
	g2_packet_free(qa);
	return false;
}

static bool handle_Q2(struct ptype_action_args *parg)
{
	struct Q2_data rdata;
	struct ptype_action_args cparg;
	size_t old_pos = parg->source->data_trunk.pos;
	bool ret_val = false, keep_decoding;

	if(!parg->source->is_compound)
		return ret_val;

	if(!g2_qht_search_prepare())
		return ret_val;

	memset(&rdata.metadata, 0, sizeof(struct Q2_data) - offsetof(struct Q2_data, metadata));
	cparg = *parg;
	cparg.opaque = &rdata;
	do
	{
		g2_packet_t child_p;
		cparg.source = &child_p;
		child_p.more_bytes_needed = false;
		child_p.packet_decode = CHECK_CONTROLL_BYTE;
		keep_decoding = g2_packet_decode_from_packet(parg->source, &child_p, 0);
		if(!keep_decoding) {
			logg_packet(STDLF, "Q2", "broken child");
			if(parg->connec)
				parg->connec->flags.dismissed = true;
			return ret_val;
		}
		if(child_p.packet_decode == DECODE_FINISHED)
			ret_val |= g2_packet_decide_spec_int(&cparg, Q2_packet_dict);
	} while(keep_decoding && parg->source->packet_decode != DECODE_FINISHED);

	if(16 < buffer_remaining(parg->source->data_trunk)) {
		logg_packet(STDLF, "Q2", "no guid?");
		return ret_val;
	}

	rdata.s_guid = (uint8_t *)buffer_start(parg->source->data_trunk);
	if(parg->connec)
	{
		parg->connec->flags.last_data_active = true;
// TODO: query limit one connection

		if(!parg->connec->flags.upeer && rdata.udp_na_valid &&
		   !combo_addr_eq_ip(&parg->connec->remote_host, &rdata.udp_na))
			return ret_val;

		if(g2_guid_add(rdata.s_guid,
		               rdata.udp_na_valid ? &rdata.udp_na : &parg->connec->remote_host,
		               local_time_now, GT_QUERY))
			return ret_val;

		/* rewind buffer for forwarding */
		parg->source->data_trunk.pos = old_pos;
		parg->opaque = &rdata;
		ret_val =
			g2_qht_search_drive(rdata.metadata, rdata.metadata_len, rdata.dn,
			                    rdata.dn_len, parg, rdata.had_urn,
			                    !parg->connec->flags.upeer); /* leafs only or hubs & leafs */
	}
	else
	{
		if(!(rdata.udp_na_valid && rdata.qk_valid))
			return ret_val;

		if(!g2_qk_check(&rdata.udp_na, rdata.qk)) {
			g2_packet_send_qka(&rdata.udp_na, parg->src_addr);
			return ret_val;
		}

		if(g2_guid_add(rdata.s_guid, &rdata.udp_na, local_time_now, GT_QUERY))
		{
			/* already in the cache */
			g2_packet_t qa, d;
			struct list_head answer;
			union combo_addr *our_addr;

			our_addr = parg->dst_addr;
			if(!our_addr)
				return ret_val;

			g2_packet_init_on_stack(&d);
			if(!fill_d_packet(&d, our_addr, 0))
				return ret_val;

			g2_packet_init_on_stack(&qa);
			if(!g2_packet_steal_data_space(&qa, 16)) {
				g2_packet_free(&d);
				return ret_val;
			}

			list_add_tail(&d.list, &qa.children);
			qa.type = PT_QA;
			qa.big_endian = HOST_IS_BIGENDIAN;
			memcpy(buffer_start(qa.data_trunk),
			       buffer_start(parg->source->data_trunk), 16);

			INIT_LIST_HEAD(&answer);
			list_add_tail(&qa.list, &answer);
			g2_udp_send(&rdata.udp_na, &answer);
			return ret_val;
		}

		/* rewind buffer for forwarding */
		parg->source->data_trunk.pos = old_pos;
		parg->opaque = &rdata;
		ret_val =
			g2_qht_search_drive(rdata.metadata, rdata.metadata_len, rdata.dn,
			                    rdata.dn_len, parg, rdata.had_urn, true); /* hubs & leafs */
	}

	return ret_val;
}

static bool handle_Q2_UDP(struct ptype_action_args *parg)
{
	struct Q2_data *rdata = parg->opaque;
	g2_packet_t *source = parg->source;
	char *data;
	size_t remaining;

	if(unlikely(!skip_unexpected_child(source, "/Q2/UDP")))
		return false;

	remaining = buffer_remaining(source->data_trunk);

	if( 6 != remaining || /* IPv4 */
	   10 != remaining || /* IPv4 + key */
	   18 != remaining || /* IPv6 */
	   22 != remaining    /* IPv6 + key */) {
		logg_packet(STDLF, "/Q2/UDP", "funny length");
		return false;
	}

	if(10 == remaining ||
	   22 == remaining) {
		data = buffer_start(source->data_trunk) + remaining - 4;
		get_unaligned_endian(rdata->qk, (uint32_t *)data, source->big_endian);
		source->data_trunk.limit -= 4;
		rdata->qk_valid = true;
	}

	rdata->udp_na_valid =
		read_na_from_packet(source, &rdata->udp_na, "/Q2/UDP");
	if(rdata->udp_na_valid && combo_addr_eq_any(&rdata->udp_na)) {
		if(parg->src_addr)
			memcpy(&rdata->udp_na, parg->src_addr, sizeof(rdata->udp_na));
		else
			rdata->udp_na_valid = false;
	}
	return false;
}

static bool handle_Q2_QKY(struct ptype_action_args *parg)
{
	struct Q2_data *rdata = parg->opaque;
	g2_packet_t *source = parg->source;

	if(unlikely(!skip_unexpected_child(source, "/Q2/QKY")))
		return false;

	if(4 != buffer_remaining(source->data_trunk)) {
		logg_packet(STDLF, "/Q2/QKY", "funny length");
		return false;
	}

	get_unaligned_endian(rdata->qk, (uint32_t *)buffer_start(source->data_trunk), source->big_endian);
	rdata->qk_valid = true;

	if(!rdata->udp_na_valid) {
		if(parg->src_addr) {
			memcpy(&rdata->udp_na, parg->src_addr, sizeof(rdata->udp_na));
			rdata->udp_na_valid = true;
		}
	}
	else if(combo_addr_eq_any(&rdata->udp_na)) {
		if(parg->src_addr)
			memcpy(&rdata->udp_na, parg->src_addr, sizeof(rdata->udp_na));
		else
			rdata->udp_na_valid = false;
	}
	return false;
}

static bool handle_Q2_URN(struct ptype_action_args *parg)
{
	struct Q2_data *rdata = parg->opaque;
	g2_packet_t *source = parg->source;
	char *urn = buffer_start(source->data_trunk);
	unsigned char *hash;
	size_t remaining = buffer_remaining(source->data_trunk);
	size_t len;

	/*
	 * even if we had an urn we do not understand, no
	 * dn && md processing
	 */
	rdata->had_urn = true;
	len = strnlen(urn, remaining);
	if(unlikely(len < 2 || len + 1 >= remaining))
		return false;

	source->data_trunk.pos += len + 1;
	remaining = buffer_remaining(source->data_trunk);
	if(unlikely(20 != remaining && /* sha1 && btih */
	            44 != remaining && /* bp */
	            24 != remaining && /* ttr */
	            16 != remaining))  /* md5 && ed2k */
		return false;

	hash = (unsigned char *)buffer_start(source->data_trunk);
	if(likely(len <= 4))
	{
		uint32_t type = 0;
#define MAKE_TYPE(a, b, c, d) \
	ntohl((((uint32_t)(a)) << 24) | \
	      (((uint32_t)(b)) << 16) | \
	      (((uint32_t)(c)) <<  8) | \
	      (((uint32_t)(d)) <<  0))

		get_unaligned(type, (uint32_t *)urn);
		if(HOST_IS_BIGENDIAN)
			type &= (uint32_t)0xFFFFFFFF << ((4 - len) * 8);
		else
			type &= (uint32_t)0xFFFFFFFF >> ((4 - len) * 8);

		if(MAKE_TYPE('s', 'h', 'a', '1') == type && 20 == remaining)
			g2_qht_search_add_sha1(hash);
		else if(MAKE_TYPE('b', 'p',  0,   0 ) == type && 44 == remaining)
		{
handle_bitprint:
			g2_qht_search_add_sha1(hash);
			hash += 20;
			g2_qht_search_add_ttr(hash);
		}
		else if(MAKE_TYPE('t', 't', 'r',  0 ) == type && 24 == remaining)
			g2_qht_search_add_ttr(hash);
		else if(MAKE_TYPE('e', 'd', '2', 'k') == type && 16 == remaining)
			g2_qht_search_add_ed2k(hash);
		else if(MAKE_TYPE('b', 't', 'i', 'h') == type && 20 == remaining)
			g2_qht_search_add_bth(hash);
		else if(MAKE_TYPE('m', 'd', '5',  0 ) == type && 16 == remaining)
			g2_qht_search_add_md5(hash);
#undef MAKE_TYPE
	}
	else
	{
		if(44 == remaining && !strlitcmp(urn, "bitprint"))
			goto handle_bitprint;
		else if(24 == remaining && !strlitcmp(urn, "tree:tiger/"))
			g2_qht_search_add_ttr(hash);
	}

	return false;
}

static bool handle_Q2_DN(struct ptype_action_args *parg)
{
	struct Q2_data *rdata = parg->opaque;
	g2_packet_t *source = parg->source;

	if(unlikely(!skip_unexpected_child(source, "/Q2/DN")))
		return false;

	rdata->dn_len = buffer_remaining(source->data_trunk);
	rdata->dn     = buffer_start(source->data_trunk);
	logg_develd("/Q2/DN - %zu \"%.*s\"\n", rdata->dn_len, (int)rdata->dn_len, rdata->dn);
	return false;
}

static bool handle_Q2_MD(struct ptype_action_args *parg)
{
	struct Q2_data *rdata = parg->opaque;
	g2_packet_t *source = parg->source;

	if(unlikely(!skip_unexpected_child(source, "/Q2/MD")))
		return false;

	rdata->metadata_len = buffer_remaining(source->data_trunk);
	rdata->metadata     = buffer_start(source->data_trunk);
	return false;
}

struct QA_data
{
	long td;
	bool td_valid;
};

static bool handle_QA(struct ptype_action_args *parg)
{
	struct QA_data rdata;
	struct ptype_action_args cparg;
	union combo_addr dest;
	g2_packet_t *source = parg->source;
	uint8_t *guid;
	size_t old_pos;
	bool ret_val = false, keep_decoding;

	if(!source->is_compound)
		return ret_val;

	/*
	 * Kamikaze!
	 * We try to fish for the GUID which is the payload somewhere
	 * behind any childs, so we can match it to our cache, see if
	 * we want to parse the packet and trust its content.
	 */
	/* guid + 0 byte + shortest packet */
	if(16 + 1 + 3 > buffer_remaining(source->data_trunk)) {
		logg_packet(STDLF, "/QA", "to short");
		return ret_val;
	}

	guid = (uint8_t *)buffer_start(source->data_trunk) + buffer_remaining(source->data_trunk) - 16;
	if(!g2_guid_lookup(guid, GT_QUERY, &dest))
		return ret_val;

	old_pos = source->data_trunk.pos;
	rdata.td_valid = false;
	cparg = *parg;
	cparg.opaque = &rdata;
	do
	{
		g2_packet_t child_p;
		cparg.source = &child_p;
		child_p.more_bytes_needed = false;
		child_p.packet_decode = CHECK_CONTROLL_BYTE;
		keep_decoding = g2_packet_decode_from_packet(parg->source, &child_p, 0);
		if(!keep_decoding) {
			logg_packet(STDLF, "QA", "broken child");
			if(parg->connec)
				parg->connec->flags.dismissed = true;
			return ret_val;
		}
		if(child_p.packet_decode == DECODE_FINISHED)
			ret_val |= g2_packet_decide_spec_int(&cparg, QA_packet_dict);
	} while(keep_decoding && parg->source->packet_decode != DECODE_FINISHED);

	/*
	 * this should not happen, if it happens, someone
	 * had a funny plan, faking a guid and then creating
	 * some broken packet.
	 */
	if(16 != buffer_remaining(source->data_trunk))
		return ret_val;

	/* rewind buffer */
	source->data_trunk.pos = old_pos;

	if(parg->connec)
		parg->connec->flags.last_data_active = true;

	/* either target is connected or nothing */
	return (!!g2_conreg_for_addr(&dest, forward_lit_callback_ignore, parg)) | ret_val;
}

static bool handle_QA_TS(struct ptype_action_args *parg)
{
	struct QA_data *rdata = parg->opaque;
	time_t foreign_time;
	time_t local_time;

	if(unlikely(!skip_unexpected_child(parg->source, "/QA/TS")))
		return false;

	local_time = local_time_now;

	if(read_ts_from_packet(parg->source, &foreign_time, "/QA/TS")) {
		logg_packet("/QA/TS -> %lu\t%lu\n", (unsigned long)foreign_time, (unsigned long)local_time);
		rdata->td = (long)local_time - (long)foreign_time;
		rdata->td_valid = true;
	}

	return false;
}

static bool handle_QA_D(struct ptype_action_args *parg)
{
	union combo_addr addr;
	size_t remaining = buffer_remaining(parg->source->data_trunk);

	if(unlikely(!skip_unexpected_child(parg->source, "/QA/D")))
		return false;

	/*
	 * some idiot thought it would be funny to cram data in
	 * here "on demand"...
	 * SAY NO TO WACKY BINARY PROTOCOLS!
	 * So we maybe only have an ip, ip + port, ip + port + leafs.
	 * Now mix in IPv6...
	 * Thank god we do not have a time stamp here...
	 */

	if( 6 + 2 != remaining &&
	   18 + 2 != remaining &&
	    6     != remaining &&
	   18     != remaining)
		return false;

	if( 6 + 2 == remaining ||
	   18 + 2 == remaining)
		parg->source->data_trunk.limit -= 2;

	if(read_na_from_packet(parg->source, &addr, "/QA/D"))
		g2_khl_add(&addr, local_time_now, false);

	return false;
}

static bool handle_QA_S(struct ptype_action_args *parg)
{
	union combo_addr addr;
	g2_packet_t *source = parg->source;
	size_t remaining = buffer_remaining(source->data_trunk);
	time_t when;
	struct QA_data *rdata = parg->opaque;

	if(unlikely(!skip_unexpected_child(parg->source, "/QA/S")))
		return false;

	if( 6     != remaining &&
	   18     != remaining &&
	    6 + 4 != remaining &&
	   18 + 4 != remaining &&
	    6 + 8 != remaining &&
	   18 + 8 != remaining)
		return false;

	when = local_time_now;
	if( 6  == remaining ||
	   18  == remaining) {
		if(!read_na_from_packet(source, &addr, "/QA/S"))
			return false;
	}
	else
	{
		if(!rdata->td_valid)
			return false;

		if(8 == sizeof(time_t))
			when &= (time_t)0xFFFFFFFF00000000ULL;
		else
			when  = 0;

		if( 6 + 4 == remaining || /* IPv4 */
		   18 + 4 == remaining    /* IPv6 */)
		{
			char *data = buffer_start(source->data_trunk) + remaining - 4;
			uint32_t t;
			get_unaligned_endian(t, (uint32_t *)data, source->big_endian);
			source->data_trunk.limit -= 4;
			when |= (time_t)(t + rdata->td);
		}
		else if(18 + 8 == remaining || /* IPv6 + 64Bit time_t */
		         6 + 8 == remaining    /*        64Bit time_t */)
		{
			char *data = buffer_start(source->data_trunk) + remaining - 8;
			uint64_t t;
			get_unaligned_endian(t, (uint64_t *)data, source->big_endian);
			source->data_trunk.limit -= 8;
			when = (time_t)(t + rdata->td);
		}

		if(!read_na_from_packet(source, &addr, "/QA/S"))
			return false;
	}

	g2_khl_add(&addr, when, false);
	return false;
}

struct QH2_data
{
	union combo_addr na;
	uint8_t *guid;
	bool na_valid;
};


static bool handle_QH2(struct ptype_action_args *parg)
{
	struct QH2_data rdata;
	struct ptype_action_args cparg;
	union combo_addr dest;
	g2_packet_t *source = parg->source;
	uint8_t *hop_count, *guid;
	size_t old_pos;
	bool ret_val = false, keep_decoding;

	if(!source->is_compound)
		return ret_val;

	/*
	 * Kamikaze!
	 * We try to fish for the GUID which is the payload somewhere
	 * behind any childs, so we can match it to our cache, see if
	 * we want to parse the packet and trust its content.
	 */
	/* guid & hopcnt + 0 byte + GU */
	if(17 + 1 + 4 + 16 > buffer_remaining(source->data_trunk)) {
		logg_packet(STDLF, "/QH2", "to short");
		return ret_val;
	}

	guid = (uint8_t *)buffer_start(source->data_trunk) + buffer_remaining(source->data_trunk) - 16;
	if(!g2_guid_lookup(guid, GT_QUERY, &dest))
		return ret_val;

	old_pos = source->data_trunk.pos;
	rdata.guid = NULL;
	rdata.na_valid = false;
	cparg = *parg;
	cparg.opaque = &rdata;
	do
	{
		g2_packet_t child_p;
		cparg.source = &child_p;
		child_p.more_bytes_needed = false;
		child_p.packet_decode = CHECK_CONTROLL_BYTE;
		keep_decoding = g2_packet_decode_from_packet(parg->source, &child_p, 0);
		if(!keep_decoding) {
			logg_packet(STDLF, "QH2", "broken child");
			if(parg->connec)
				parg->connec->flags.dismissed = true;
			return ret_val;
		}
		if(child_p.packet_decode == DECODE_FINISHED)
			ret_val |= g2_packet_decide_spec_int(&cparg, QH2_packet_dict);
	} while(keep_decoding && parg->source->packet_decode != DECODE_FINISHED);

	/*
	 * this should not happen, if it happens, someone
	 * had a funny plan, faking a guid and then creating
	 * some broken packet.
	 */
	if(17 != buffer_remaining(source->data_trunk) || !rdata.guid)
		return ret_val;

	if(!parg->connec)
	{
		/* for UDP they better send their address along */
		if(!rdata.na_valid)
			return ret_val;

		/* and it has to be valid */
		if(!combo_addr_is_public(&rdata.na) || !combo_addr_eq(&rdata.na, parg->src_addr))
			return ret_val;
	}

	hop_count = (uint8_t *)buffer_start(source->data_trunk);
	if(*hop_count >= 254)
		return ret_val;

	/* increment hop count */
	*hop_count += 1;

	/*
	 * We normaly would have to tear apart a fucking lot
	 * of this package to understand it.
	 * But we do not search, we do not need those infos.
	 *
	 * Only thing thats left is to decide if the packet
	 * is "good" or "bad".
	 *
	 * This includes parsing and frobnicating XML (ahhhh),
	 * looking over all Hits/HitGroups (alloc galore), only
	 * to have a glimpse idea that the packet is not uterly
	 * crap.
	 *
	 * When it is "good", we can use the guid, na, etc...
	 *
	 * At least all this checking would be beneficial not
	 * to forward junk.
	 */

	if(parg->connec)
		parg->connec->flags.last_data_active = true;

	/* rewind buffer */
	source->data_trunk.pos = old_pos;

	if(!g2_conreg_for_addr(&dest, forward_lit_callback_found, parg))
	{
		struct list_head answer;
		/* seems to be a udp address */
		source->is_literal = true;
		INIT_LIST_HEAD(&answer);
		list_add_tail(&source->list, &answer);
		g2_udp_send(&dest, &answer);
	}

	return ret_val;
}

static bool handle_QH2_GU(struct ptype_action_args *parg)
{
	struct QH2_data *rdata = parg->opaque;

	if(unlikely(!skip_unexpected_child(parg->source, "/QH2/GU")))
		return false;

	if(16 == buffer_remaining(parg->source->data_trunk))
		rdata->guid = (uint8_t *)buffer_start(parg->source->data_trunk);
	else
		logg_packet(STDLF, "/QH2/GU", "GU not a valid GUID");

	return false;
}

static bool handle_QH2_NA(struct ptype_action_args *parg)
{
	struct QH2_data *rdata = parg->opaque;

	if(unlikely(!skip_unexpected_child(parg->source, "/QH2/NA")))
		return false;

	rdata->na_valid =
		read_na_from_packet(parg->source, &rdata->na, "/QH2/NA");
	return false;
}

static inline bool handle_QHT_patch(g2_connection_t *connec, g2_packet_t *source)
{
	struct qht_fragment *frag;
	int ret_val;
	const char *patch_txt;

	if(unlikely(!connec->qht)) {
		logg_packet(STDLF, "/QHT-patch", "initial patch without initial reset");
		connec->flags.dismissed = true;
		return false;
	}

	if(unlikely((QHT_PATCH_HEADER_BYTES-1) > buffer_remaining(source->data_trunk))) {
		logg_packet(STDLF, "/QHT-patch", "to short");
		connec->flags.dismissed = true;
		goto qht_patch_end;
	}

	if(unlikely(1 != *(buffer_start(source->data_trunk)+3))) {
		logg_packet(STDLF, "/QHT-patch", "illegal bit-number");
		connec->flags.dismissed = true;
		goto qht_patch_end;
	}
	if(unlikely(connec->flags.dismissed)) {
		logg_packet(STDLF, "/QHT-patch", "connection dissmissed");
		goto qht_patch_end;
	}

	frag = g2_qht_frag_alloc(buffer_remaining(source->data_trunk)
	                         - (QHT_PATCH_HEADER_BYTES-1));
	if(!frag) {
		logg_packet(STDLF, "/QHT-patch", "no mem for fragment");
		connec->flags.dismissed = true;
		goto qht_patch_end;
	}
	frag->nr         = ((unsigned)*buffer_start(source->data_trunk)) & 0x00FF;
	frag->count      = ((unsigned)*(buffer_start(source->data_trunk)+1)) & 0x00FF;
	frag->compressed = ((unsigned)*(buffer_start(source->data_trunk)+2)) & 0x00FF;
	source->data_trunk.pos += QHT_PATCH_HEADER_BYTES-1;
	ret_val = g2_qht_add_frag(connec->qht, frag, (uint8_t *)buffer_start(source->data_trunk));

	if(likely(0 == ret_val)) { /* patch io, but need more */
		logg_packet(STDLF, "/QHT-patch", "patch recieved");
		return false;
	} else if(0 > ret_val) { /* patch nio */
		connec->flags.dismissed = true;
		free(frag);
		goto qht_patch_end;
	}
	/* patch io and complete */
	patch_txt = g2_qht_patch(connec->qht, connec->qht->fragments);
	/* we patched a connection, not some free standing QHT */
	if(!connec->flags.upeer)
		g2_conreg_mark_dirty(connec);
	logg_packet(STDLF, "/QHT-patch", patch_txt ? patch_txt : "some error while appling");
qht_patch_end:
	g2_qht_frag_free(connec->qht->fragments);
	connec->qht->fragments = NULL;
	return false;
}

static inline bool handle_QHT_reset(g2_connection_t *connec, g2_packet_t *source)
{
	uint32_t qht_ent;

	if(unlikely((QHT_RESET_HEADER_BYTES-1) != buffer_remaining(source->data_trunk))) {
		logg_packet(STDLF, "/QHT-reset", "to short");
		connec->flags.dismissed = true;
		return false;
	}
	
	if(unlikely(1 != *(buffer_start(source->data_trunk)+4))) {
		logg_packet(STDLF, "/QHT-reset", "illegal infinity");
		connec->flags.dismissed = true;
		return false;
	}

	get_unaligned_endian(qht_ent, (uint32_t *)buffer_start(source->data_trunk), source->big_endian);

	if(unlikely(g2_qht_reset(&connec->qht, qht_ent, server.settings.qht.compress_internal)))
		connec->flags.dismissed = true;
	else if(!connec->flags.upeer)
		g2_conreg_mark_dirty(connec);

	logg_packet(STDSF, "/QHT-reset");
	return false;
}

static bool handle_QHT(struct ptype_action_args *parg)
{
	g2_connection_t *connec = parg->connec;
	g2_packet_t *source = parg->source;
	struct qht_fragment *frags, *nfrag;
	struct qhtable *master_qht;
	g2_packet_t *qht = NULL;
	char tmp;
	bool ret_val = false;

	if(unlikely(!skip_unexpected_child(source, "/QHT")))
		return false;

	if(unlikely(!buffer_remaining(source->data_trunk))) {
		logg_packet(STDLF, "/QHT", "without data?");
		return false;
	}

	tmp = *buffer_start(source->data_trunk);
	source->data_trunk.pos++;
	
	if(1 == tmp)
		ret_val = handle_QHT_patch(connec, source);
	else if(0 == tmp)
		ret_val = handle_QHT_reset(connec, source);
	else
		logg_packet(STDLF, "/QHT", "with unknown command");

	connec->flags.last_data_active = true;
	return ret_val;
	if(unlikely(ret_val) || !connec->flags.upeer || local_time_now < (connec->u.handler.send_stamps.QHT + (QHT_TIMEOUT)))
		return ret_val;

	master_qht = g2_qht_global_get();
	/* "cheap" check if we have to sent the qht */
	if(connec->sent_qht == master_qht) {
		g2_qht_put(master_qht);
		return false;
	}

	if(!connec->sent_qht)
	{
		uint32_t ent;

		qht = g2_packet_calloc();
		if(!qht)
			goto out_fail;
		qht->type = PT_QHT;
		if(!g2_packet_steal_data_space(qht, QHT_RESET_HEADER_BYTES))
			goto out_fail;

		ent = (uint32_t)master_qht->entries;
		*buffer_start(qht->data_trunk) = 0; /* command */
		put_unaligned(ent, (uint32_t*)(buffer_start(qht->data_trunk)+1));
		*(buffer_start(qht->data_trunk)+5) = 1; /* infinity */
		qht->big_endian = HOST_IS_BIGENDIAN;
		g2_packet_add2target(qht, parg->target, parg->target_lock);
		qht = NULL;
	}

	frags = g2_qht_diff_get_frag(connec->sent_qht, master_qht);
	if(!frags)
		goto out_fail;

	do
	{
		struct packet_data_store *pds;

		/*
		 * Dirty Dirty Dirty
		 * We got frags from the qht stuff. They left us some space
		 * at the start for a qht fragment header.
		 * But to free the fragments, by being data_trunk->data, we
		 * have to set up stuff right.
		 * First it was enough to set the raw fragment as ->data
		 * and advance ->pos over the struct fragment.
		 * Now, since the data store is refcounted, we have to move
		 * the start about a sizeof(pds).
		 * So this is ugly pointer foo and aliasing.
		 *
		 * May the compiler be with us...
		 */
		nfrag = frags->next;
		qht = g2_packet_calloc();
		if(!qht)
			goto out_fail_frags;
		qht->type = PT_QHT;
		frags->next = NULL;

		pds = (struct packet_data_store *)frags;
		qht->data_trunk.capacity = sizeof(*frags) + frags->length - sizeof(*pds);
		qht->data_trunk.limit = qht->data_trunk.capacity;
		qht->data_trunk.pos =
			offsetof(struct qht_fragment, data) - offsetof(struct packet_data_store, data);
		qht->data_trunk_is_freeable = true;
		qht->data_trunk.data = pds->data;
		atomic_set(&pds->refcnt, 1);

		*buffer_start(qht->data_trunk) = 1; /* command */
		*(buffer_start(qht->data_trunk)+1) = frags->nr; /* fragment no */
		*(buffer_start(qht->data_trunk)+2) = frags->count; /* fragment count */
		*(buffer_start(qht->data_trunk)+3) = frags->compressed; /* compresion */
		*(buffer_start(qht->data_trunk)+4) = 1; /* bits */

		g2_packet_add2target(qht, parg->target, parg->target_lock);
		frags = nfrag;
	} while(frags);

	g2_qht_put(connec->sent_qht);
	connec->sent_qht = master_qht;
	connec->u.handler.send_stamps.QHT = local_time_now;
	return true;

out_fail_frags:
	g2_qht_frag_free(frags);
out_fail:
	g2_qht_put(master_qht);
	g2_packet_free(qht);
	return false;
}

struct QKR_data
{
	union combo_addr requesting_na;
	union combo_addr queried_na;
	union combo_addr sending_na;
	bool refresh;
	bool requesting_na_valid;
	bool queried_na_valid;
	bool sending_na_valid;
};

static bool handle_QKR(struct ptype_action_args *parg)
{
	struct QKR_data rdata;
	struct list_head answer;
	bool ret_val = false, keep_decoding;

	memset(&rdata.refresh, 0, sizeof(struct QKR_data) - offsetof(struct QKR_data, refresh));
	if(parg->source->is_compound)
	{
		struct ptype_action_args cparg = *parg;
		cparg.opaque = &rdata;
		do
		{
			g2_packet_t child_p;
			cparg.source = &child_p;
			child_p.more_bytes_needed = false;
			child_p.packet_decode = CHECK_CONTROLL_BYTE;
			keep_decoding = g2_packet_decode_from_packet(parg->source, &child_p, 0);
			if(!keep_decoding) {
				logg_packet(STDLF, "QKR", "broken child");
				if(parg->connec)
					parg->connec->flags.dismissed = true;
				return ret_val;
			}
			if(likely(child_p.packet_decode == DECODE_FINISHED))
				ret_val |= g2_packet_decide_spec_int(&cparg, QKR_packet_dict);
		} while(keep_decoding && parg->source->packet_decode != DECODE_FINISHED);
	}

	/* something wrong with the decoding? */
	if(parg->source->packet_decode != DECODE_FINISHED)
		return ret_val; /* in that case we can not continue */

	logg_packet("QKR from %pI\tC: %s -> \n",
		parg->connec ? &parg->connec->remote_host : parg->src_addr,
		parg->source->is_compound ? "true" : "false");

	if(parg->connec)
	{
		uint32_t key;

		if(!rdata.queried_na_valid)
			return ret_val;

		parg->connec->flags.last_data_active = true;
		if(!rdata.refresh && g2_qk_lookup(&key, &rdata.queried_na))
		{
			g2_packet_t *qka, *qna, *qk, *cached;

			qka    = g2_packet_calloc();
			qna    = g2_packet_calloc();
			qk     = g2_packet_calloc();
			cached = g2_packet_calloc();

			if(!(qka && qna && qk))
				goto out_fail;

			qna->type = PT_QNA;
			if(!write_na_to_packet(qna, &rdata.queried_na))
				goto out_fail;

			qk->type = PT_QK;
			qk->big_endian = HOST_IS_BIGENDIAN;
			/* should not fail */
			if(!g2_packet_steal_data_space(qk, sizeof(uint32_t)))
				goto out_fail;
			put_unaligned(key, (uint32_t *)buffer_start(qk->data_trunk));

			list_add_tail(&qna->list, &qka->children);
			list_add_tail(&qk->list, &qka->children);

			if(cached) {
				cached->type = PT_CACHED;
				cached->big_endian = HOST_IS_BIGENDIAN;
				list_add_tail(&cached->list, &qka->children);
			}

			qka->type = PT_QKA;
			qka->big_endian = HOST_IS_BIGENDIAN;
			g2_packet_add2target(qka, parg->target, parg->target_lock);

			return true;
out_fail:
			g2_packet_free(qka);
			g2_packet_free(qna);
			g2_packet_free(qk);
			g2_packet_free(cached);
		}
		else
		{
			g2_packet_t qkr, sna;

			g2_packet_init_on_stack(&qkr);
			g2_packet_init_on_stack(&sna);

			link_sna_to_packet(&sna, &rdata.sending_na);
			list_add_tail(&sna.list, &qkr.children);

			qkr.type = PT_QKR;
			qkr.big_endian = HOST_IS_BIGENDIAN;

			INIT_LIST_HEAD(&answer);
			list_add_tail(&qkr.list, &answer);
			g2_udp_send(&rdata.queried_na, &answer);
		}
	}
	else
		g2_packet_send_qka(!rdata.requesting_na_valid ? parg->src_addr : &rdata.requesting_na,
		                    rdata.sending_na_valid ? &rdata.sending_na : NULL);

	return ret_val;
}

static bool handle_QKR_RNA(struct ptype_action_args *parg)
{
	struct QKR_data *rdata = parg->opaque;

	if(unlikely(!skip_unexpected_child(parg->source, "/QKR/RNA")))
		return false;

	rdata->requesting_na_valid =
		read_na_from_packet(parg->source, &rdata->requesting_na, "/QKR/RNA");
	return false;
}

static bool handle_QKR_QNA(struct ptype_action_args *parg)
{
	struct QKR_data *rdata = parg->opaque;

	/* we can not read an address in this case ATM */
	if(unlikely(!skip_unexpected_child(parg->source, "/QKR/QNA")))
		return false;

	rdata->queried_na_valid =
		read_na_from_packet(parg->source, &rdata->queried_na, "/QKR/QNA");
	return false;
}

static bool handle_QKR_SNA(struct ptype_action_args *parg)
{
	struct QKR_data *rdata = parg->opaque;

	if(unlikely(!skip_unexpected_child(parg->source, "/QKR/SNA")))
		return false;

	rdata->sending_na_valid =
		read_sna_from_packet(parg->source, &rdata->sending_na, "/QKR/SNA");
	return false;
}

static bool handle_QKR_REF(struct ptype_action_args *parg)
{
	struct QKR_data *rdata = parg->opaque;
	rdata->refresh = true;
	return false;
}

struct QKA_data
{
	union combo_addr queried_na;
	union combo_addr sending_na;
	uint32_t query_key;
	bool cached;
	bool query_key_valid;
	bool queried_na_valid;
	bool sending_na_valid;
};

static intptr_t QKA_SNA_callback(g2_connection_t *con, void *carg)
{
	struct ptype_action_args *parg = carg;
	struct QKA_data *rdata = parg->opaque;;
	g2_packet_t *qka, *qk, *sna, *qna;

	/*
	 * The connection is locked against removal inside this callback
	 * (but because of this we do not want to lock to long, we have
	 * a whole hash slot locked in the conreg...).
	 * But there may be further locking needed.
	 */

	/*
	 * we simply rebuild the packet, this way we can avoid
	 * to add a child packet to a raw packet. We may loose
	 * unknown/untypical childs by this.
	 */
	qka = g2_packet_calloc();
	qk  = g2_packet_calloc();
	sna = g2_packet_calloc();
	qna = g2_packet_calloc();

	if(!(qka && qk && sna && qna))
		goto out_fail;

	qna->type = PT_QNA;
	if(!write_na_to_packet(qna, parg->src_addr))
		goto out_fail;

	sna->type = PT_CACHED;
	/* buffers are now large enough, should not fail */
	if(!write_sna_to_packet(sna, &rdata->sending_na))
		goto out_fail;

	qk->type = PT_QK;
	qk->big_endian = HOST_IS_BIGENDIAN;
	/* should not fail */
	if(!g2_packet_steal_data_space(qk, sizeof(uint32_t)))
		goto out_fail;
	put_unaligned(rdata->query_key, (uint32_t *)buffer_start(qk->data_trunk));

	list_add_tail(&sna->list, &qka->children);
	list_add_tail(&qna->list, &qka->children);
	list_add_tail(&qk->list, &qka->children);

	qka->type = PT_QKA;
	qka->big_endian = HOST_IS_BIGENDIAN;

	g2_handler_con_mark_write(qka, con);
	return 0;

out_fail:
	g2_packet_free(qka);
	g2_packet_free(qk);
	g2_packet_free(sna);
	g2_packet_free(qna);
	return 0;
}

static bool handle_QKA(struct ptype_action_args *parg)
{
	struct ptype_action_args cparg;
	struct QKA_data rdata;
	bool ret_val = false, keep_decoding;

// TODO: punish sender for sending bullshit?
	if(!parg->source->is_compound)
		return ret_val;

	if(parg->connec && !parg->connec->flags.upeer)
		return ret_val;

	memset(&rdata.cached, 0, sizeof(struct QKA_data) - offsetof(struct QKA_data, cached));
	cparg = *parg;
	cparg.opaque = &rdata;
	do
	{
		g2_packet_t child_p;
		cparg.source = &child_p;
		child_p.more_bytes_needed = false;
		child_p.packet_decode = CHECK_CONTROLL_BYTE;
		keep_decoding = g2_packet_decode_from_packet(parg->source, &child_p, 0);
		if(!keep_decoding) {
			logg_packet(STDLF, "QKA", "broken child");
			if(parg->connec)
				parg->connec->flags.dismissed = true;
			return ret_val;
		}
		if(likely(child_p.packet_decode == DECODE_FINISHED))
			ret_val |= g2_packet_decide_spec_int(&cparg, QKA_packet_dict);
	} while(keep_decoding && parg->source->packet_decode != DECODE_FINISHED);

	/* something wrong with the decoding? */
	if(parg->source->packet_decode != DECODE_FINISHED)
		return ret_val; /* in that case we can not continue */

// TODO: punish sender for sending bullshit?
	if(!rdata.query_key_valid)
		return ret_val;

	logg_packet("QKA from %pI for %pI\tkey: %#x\n",
		parg->connec ? &parg->connec->remote_host : parg->src_addr,
		rdata.queried_na_valid ? &rdata.queried_na :
			parg->connec ? &parg->connec->remote_host : parg->src_addr,
		rdata.query_key);

// TODO: check for our own IP
	if(parg->connec) {
		if(rdata.queried_na_valid) {
			parg->connec->flags.last_data_active = true;
			g2_qk_add(rdata.query_key, &rdata.queried_na);
		}
	}
	else
	{
		g2_qk_add(rdata.query_key, parg->src_addr);
		if(rdata.sending_na_valid) {
			parg->opaque = &rdata;
			ret_val = !!g2_conreg_for_ip(&rdata.sending_na, QKA_SNA_callback, parg);
		}
	}

	return ret_val;
}

static bool handle_QKA_QK(struct ptype_action_args *parg)
{
	g2_packet_t *source = parg->source;
	struct QKA_data *rdata = parg->opaque;

	if(unlikely(!skip_unexpected_child(parg->source, "/QKA/QK")))
		return false;

	if(4 != buffer_remaining(source->data_trunk)) {
		logg_packet(STDLF, "/QKA/QK", "funny length");
		return false;
	}

	get_unaligned_endian(rdata->query_key, (uint32_t *)buffer_start(source->data_trunk), source->big_endian);
	rdata->query_key_valid = true;
	return false;
}

static bool handle_QKA_QNA(struct ptype_action_args *parg)
{
	struct QKA_data *rdata = parg->opaque;

	if(unlikely(!skip_unexpected_child(parg->source, "/QKA/QNA")))
		return false;

	rdata->queried_na_valid =
		read_na_from_packet(parg->source, &rdata->queried_na, "/QKA/QNA");
	return false;
}

static bool handle_QKA_SNA(struct ptype_action_args *parg)
{
	struct QKA_data *rdata = parg->opaque;

	if(unlikely(!skip_unexpected_child(parg->source, "/QKR/SNA")))
		return false;

	rdata->sending_na_valid =
		read_sna_from_packet(parg->source, &rdata->sending_na, "/QKA/SNA");
	return false;
}

static bool handle_QKA_CACHED(struct ptype_action_args *parg)
{
	struct QKA_data *rdata = parg->opaque;
	rdata->cached = true;
	return false;
}

struct HAW_data
{
	union combo_addr na;
	bool na_valid;
};

static bool handle_HAW(struct ptype_action_args *parg)
{
	struct HAW_data rdata;
	struct ptype_action_args cparg;
	g2_packet_t *source = parg->source;
	size_t old_pos;
	uint8_t *ttl, *hops, *guid;
	bool ret_val = false, keep_decoding;

	if(!source->is_compound)
		return ret_val;

	old_pos = source->data_trunk.pos;
	rdata.na_valid = false;
	cparg = *parg;
	cparg.opaque = &rdata;
	do
	{
		g2_packet_t child_p;
		cparg.source = &child_p;
		child_p.more_bytes_needed = false;
		child_p.packet_decode = CHECK_CONTROLL_BYTE;
		keep_decoding = g2_packet_decode_from_packet(source, &child_p, 0);
		if(!keep_decoding) {
			logg_packet(STDLF, "HAW", "broken child");
			parg->connec->flags.dismissed = true;
			return ret_val;
		}
		if(child_p.packet_decode == DECODE_FINISHED)
			ret_val |= g2_packet_decide_spec_int(&cparg, HAW_packet_dict);
	} while(keep_decoding && source->packet_decode != DECODE_FINISHED);

	if(!rdata.na_valid)
		return ret_val;

	if(18 < buffer_remaining(source->data_trunk)) {
		logg_packet(STDLF, "HAW", "no ttl, hops, guid?");
// TODO: punishment?
		return ret_val;
	}

	parg->connec->flags.last_data_active = true;
	ttl  = (uint8_t *)buffer_start(source->data_trunk);
	hops = (uint8_t *)(buffer_start(source->data_trunk) + 1);
	guid = (uint8_t *)buffer_start(source->data_trunk) + 2;
// TODO: check ttl/hops for validity

	g2_khl_add(&rdata.na, local_time_now, g2_conreg_is_neighbour_hub(&rdata.na));

	/*
	 * sh** f***ing guids...
	 * HAWs have their own guid, not to confuse with all the
	 * others, to identify THIS HAW (???). It's not the guid
	 * of the node sending a HAW.
	 * Save it, for whatever purpose...
	 */
	/* do we know this HAW already? */
	if(g2_guid_lookup(guid, GT_HAW, NULL))
		return ret_val; /* do not forward */

	g2_guid_add(guid, &rdata.na, local_time_now, GT_HAW);

	logg_packet("/HAW\tttl: %u hops: %u guid: %p#G\n", *ttl, *hops, guid);
	if(*ttl > 0 && *hops < 255)
	{
		*ttl  -= 1;
		*hops += 1;

		/* rewind buffer */
		source->data_trunk.pos = old_pos;
		ret_val |= !!g2_conreg_random_hub(&parg->connec->remote_host, forward_lit_callback_ignore, parg);
	}

	return ret_val;
}

static bool handle_HAW_NA(struct ptype_action_args *parg)
{
	struct HAW_data *rdata = parg->opaque;

	if(unlikely(!skip_unexpected_child(parg->source, "/HAW/NA")))
		return false;

	rdata->na_valid =
		read_na_from_packet(parg->source, &rdata->na, "/HAW/NA");
	return false;
}

static bool handle_UPROC(struct ptype_action_args *parg)
{
	/*
	 * /UPROC-packet, user-profile-request, if we want to and have an
	 * answer, do it.
	 */
	parg->connec->flags.last_data_active = true;
	logg_packet_old(STDSF, "/UPROC");
	if(likely(server.settings.profile.want_2_send &&
	   server.settings.profile.xml &&
	   server.settings.profile.xml_length &&
	   server.settings.profile.xml_length < server.settings.default_max_g2_packet_length - 10))
	{
		g2_packet_t *uprod;
		g2_packet_t *xml;

		/* time to send a packet again? */
		if(local_time_now < (parg->connec->u.handler.send_stamps.UPROC + (UPROC_TIMEOUT)))
			return false;

		uprod = g2_packet_calloc();
		xml   = g2_packet_calloc();
		if(!(uprod && xml)) {
			g2_packet_free(uprod);
			g2_packet_free(xml);
			return false;
		}

		uprod->type = PT_UPROD;
		list_add(&xml->list, &uprod->children);
		xml->type = PT_XML;
		xml->data_trunk.data     = (void*)(intptr_t)server.settings.profile.xml;
		xml->data_trunk.capacity = server.settings.profile.xml_length;
		buffer_clear(xml->data_trunk);

		g2_packet_add2target(uprod, parg->target, parg->target_lock);
		parg->connec->u.handler.send_stamps.UPROC = local_time_now;
		return true;
	}

	return false;
}

static bool handle_UPROD(struct ptype_action_args *parg GCC_ATTR_UNUSED_PARAM)
{
	logg_packet_old(STDSF, "/UPROD");
	if(parg->source->is_compound) {
		parg->connec->flags.last_data_active = true;
// TODO: write UPROD subdecoder ?
		logg_packet(STDLF, "/UPROD", "/xxx -> subdecoder?");
	}
	else
		logg_packet(STDLF, "/UPROD", "no child?");
	return false;
}

struct CRAWLR_data
{
	g2_packet_t *crawla;
	bool leaf;
	bool name;
	bool gps;
	bool ext;
};

static intptr_t CRAWLR_callback(g2_connection_t *con, void *carg)
{
	struct ptype_action_args *parg = carg;
	struct CRAWLR_data *rdata = parg->opaque;
	g2_packet_t *nh, *na, *hs;

	nh = g2_packet_calloc();
	na = g2_packet_calloc();
	hs = g2_packet_calloc();

	if(!(nh && na && hs))
		goto out_free;

	na->type = PT_NA;
	if(!write_na_to_packet(na, &con->sent_addr))
		goto out_free;

	hs->type = PT_HS;
	if(g2_packet_steal_data_space(hs, 2))
	{
		uint16_t cons     = (uint16_t)con->u.handler.leaf_count;
		put_unaligned(cons, (uint16_t *)buffer_start(hs->data_trunk));
		hs->big_endian = HOST_IS_BIGENDIAN;
		list_add_tail(&hs->list, &nh->children);
	}
	else
		g2_packet_free(hs);

	list_add_tail(&na->list, &nh->children);

	nh->type = PT_NH;
	nh->big_endian = HOST_IS_BIGENDIAN;

	if(rdata->gps)
	{
		/* add gps data to nh */
	}
	if(rdata->name)
	{
		/* add nick to nh */
	}

	list_add_tail(&nh->list, &rdata->crawla->children);
	return 0;

out_free:
	g2_packet_free(nh);
	g2_packet_free(na);
	g2_packet_free(hs);
	return 0;
}

static bool handle_CRAWLR(struct ptype_action_args *parg)
{
	static pthread_mutex_t s_lock = PTHREAD_MUTEX_INITIALIZER;
	static time_t last_send;
	struct CRAWLR_data rdata;
	g2_packet_t *crawla, *self, *na, *hs, *hub;
	bool ret_val = false;

	if(unlikely(pthread_mutex_lock(&s_lock)))
		return false;

	if(local_time_now < (last_send + CRAWLR_TIMEOUT))
		goto out_unlock;
	last_send = local_time_now;

	if(unlikely(pthread_mutex_unlock(&s_lock)))
		diedie("s_lock stuck, bye!");

	memset(&rdata, 0, sizeof(rdata));

	crawla = g2_packet_calloc();
	self   = g2_packet_calloc();
	na     = g2_packet_calloc();
	hs     = g2_packet_calloc();
	hub    = g2_packet_calloc();
	if(!(crawla && self && na && hs && hub))
		goto out_free;

	na->type = PT_NA;
	if(!write_na_to_packet(na, parg->dst_addr))
		goto out_free;

	hs->type = PT_HS;
	if(g2_packet_steal_data_space(hs, 2))
	{
		uint16_t cons     = (uint16_t)atomic_read(&server.status.act_connection_sum);
		put_unaligned(cons, (uint16_t *)buffer_start(hs->data_trunk));
		hs->big_endian = HOST_IS_BIGENDIAN;
		list_add_tail(&hs->list, &self->children);
	}
	else
		g2_packet_free(hs);

	list_add_tail(&na->list, &self->children);

	hub->type = likely(server.status.our_server_upeer) ? PT_HUB : PT_LEAF;
	list_add_tail(&hub->list, &self->children);

	if(rdata.gps)
	{
		/* add gps data to self */
	}
	if(rdata.name)
	{
		/* add nick to self */
	}
	if(rdata.ext)
	{
		g2_packet_t *v, *cv;

		v = g2_packet_calloc();
		if(v)
		{
			v->type                = PT_V;
			v->data_trunk.data     = (void *)(intptr_t)OWN_VENDOR_CODE;
			v->data_trunk.capacity = str_size(OWN_VENDOR_CODE);
			buffer_clear(v->data_trunk);
			list_add_tail(&v->list, &self->children);
		}
		cv = g2_packet_calloc();
		if(cv)
		{
			cv->type                = PT_CV;
			cv->data_trunk.data     = (void *)(intptr_t)OUR_VERSION;
			cv->data_trunk.capacity = str_size(OUR_VERSION);
			buffer_clear(cv->data_trunk);
			list_add_tail(&cv->list, &self->children);
		}
	}

	self->type = PT_SELF;
	self->big_endian = HOST_IS_BIGENDIAN;

	list_add_tail(&self->list, &crawla->children);

	crawla->type = PT_CRAWLA;
	crawla->big_endian = HOST_IS_BIGENDIAN;

	rdata.crawla = crawla;
	parg->opaque = &rdata;
	g2_conreg_all_hub(NULL, CRAWLR_callback, parg);

	if(rdata.leaf)
	{
		/* we will NEVER add this info */
	}

	g2_packet_add2target(crawla, parg->target, parg->target_lock);

	return true;

out_free:
	g2_packet_free(crawla);
	g2_packet_free(self);
	g2_packet_free(na);
	g2_packet_free(hs);
	g2_packet_free(hub);
	return ret_val;

out_unlock:
	if(unlikely(pthread_mutex_unlock(&s_lock)))
		diedie("s_lock stuck, bye!");
	return ret_val;
}

static bool handle_CRAWLR_REXT(struct ptype_action_args *parg)
{
	struct CRAWLR_data *rdata = parg->opaque;
	rdata->ext = true;
	return false;
}

static bool handle_CRAWLR_RGPS(struct ptype_action_args *parg)
{
	struct CRAWLR_data *rdata = parg->opaque;
	rdata->gps = true;
	return false;
}

static bool handle_CRAWLR_RNAME(struct ptype_action_args *parg)
{
	struct CRAWLR_data *rdata = parg->opaque;
	rdata->name = true;
	return false;
}

static bool handle_CRAWLR_RLEAF(struct ptype_action_args *parg)
{
	struct CRAWLR_data *rdata = parg->opaque;
	rdata->leaf = true;
	return false;
}

static bool handle_G2CDC(struct ptype_action_args *parg)
{
	bool ret_val = false;
#ifdef HAVE_DLOPEN
	static pthread_mutex_t s_lock = PTHREAD_MUTEX_INITIALIZER;
	static void *handle;
	static time_t last_send;
	const struct s_data
	{
		const unsigned long len;
		const char *data;
	} *s_data;
	g2_packet_t *t;

	if(unlikely(pthread_mutex_lock(&s_lock)))
		return false;

	if(!handle) {
		if(!(handle = dlopen(NULL, RTLD_LAZY)))
			goto out_unlock;
	}

	(void) dlerror();
	s_data = dlsym(handle, "sbox");
	if(dlerror())
		goto out_unlock;

	if(parg->source->is_compound ||
	   buffer_remaining(parg->source->data_trunk))
		goto out_unlock;

	if(local_time_now < (last_send + G2CDC_TIMEOUT))
		goto out_unlock;
	last_send = local_time_now;

	t = g2_packet_calloc();
	if(!t)
		goto out_unlock;

	t->type = PT_G2CDc;
	t->big_endian = HOST_IS_BIGENDIAN;
	t->data_trunk.data = (void*)(intptr_t)s_data->data;
	t->data_trunk.capacity = s_data->len;
	buffer_clear(t->data_trunk);
	g2_packet_add2target(t, parg->target, parg->target_lock);
	ret_val = true;

out_unlock:
	if(unlikely(pthread_mutex_unlock(&s_lock)))
		diedie("s_lock stuck, bye!");
#else
	parg = parg;
#endif
	return ret_val;
}


/********************************************************************
 *
 * helper-functions
 *
 ********************************************************************/
g2_packet_t *g2_packet_init(g2_packet_t *p)
{
	if(!p)
		return p;

	memset(p, 0, offsetof(g2_packet_t, data_trunk));
	/* ATM they are similar to zero */
/*	p->packet_decode = CHECK_CONTROLL_BYTE;
	p->packet_encode = DECIDE_ENCODE; */
	INIT_LIST_HEAD(&p->list);
	INIT_LIST_HEAD(&p->children);
	return p;
}

g2_packet_t *g2_packet_alloc(void)
{
	g2_packet_t *t = malloc(sizeof(g2_packet_t));
	if(t)
		t->is_freeable = true;
	return t;
}

// TODO: write a TLS boosted allocator
g2_packet_t *g2_packet_calloc(void)
{
	g2_packet_t *t = g2_packet_init(g2_packet_alloc());
	if(t) {
		INIT_PBUF(&t->data_trunk);
		t->is_freeable = true;
	}
	return t;
}

g2_packet_t *g2_packet_clone(g2_packet_t *p)
{
	g2_packet_t *t;
	if(!p)
		return p;
	t = malloc(sizeof(*t));
	if(!t)
		return t;
	*t = *p;
	INIT_LIST_HEAD(&t->list);
	INIT_LIST_HEAD(&t->children);
	t->is_freeable = true;
	return t;
}

void g2_packet_free(g2_packet_t *to_free)
{
	struct list_head *e, *n;

	if(!to_free)
		return;

	list_for_each_safe(e, n, &to_free->children) {
		g2_packet_t *entry = list_entry(e, g2_packet_t, list);
		list_del(e);
		g2_packet_free(entry);
	}

	if(unlikely(to_free->data_trunk_is_freeable && to_free->data_trunk.data))
	{
		struct packet_data_store *pds =
			container_of(to_free->data_trunk.data,
			             struct packet_data_store, data);
		if(atomic_dec_test(&pds->refcnt))
			free(pds);
	}

	if(likely(to_free->is_freeable))
		free(to_free);
}

void g2_packet_clean(g2_packet_t *to_clean)
{
	bool tmp_info = to_clean->data_trunk_is_freeable;
	bool tmp_free = to_clean->is_freeable;
	struct list_head *e, *n;

	list_for_each_safe(e, n, &to_clean->children) {
		g2_packet_t *entry = list_entry(e, g2_packet_t, list);
		list_del(e);
		g2_packet_free(entry);
	}

	g2_packet_init(to_clean);
	buffer_clear(to_clean->data_trunk);
	to_clean->data_trunk_is_freeable = tmp_info;
	to_clean->is_freeable = tmp_free;
}

static bool g2_packet_steal_data_space(g2_packet_t *p, size_t bytes)
{
	struct packet_data_store *pds;

	if(sizeof(p->pd.out) < bytes)
		goto must_malloc;

	p->data_trunk.data  = p->pd.out;
	p->data_trunk.limit = p->data_trunk.capacity = sizeof(p->pd.out);
	p->data_trunk.pos   = sizeof(p->pd.out) - bytes;
	p->data_trunk_is_freeable = false;

	return true;

must_malloc:
	pds = malloc(sizeof(*pds) + bytes);
	if(!pds)
		return false;
	atomic_set(&pds->refcnt, 1);
	p->data_trunk.data = pds->data;
	p->data_trunk.capacity = bytes;
	buffer_clear(p->data_trunk);
	p->data_trunk_is_freeable = true;
	return true;
}

static bool g2_packet_steal_data_space_lit(g2_packet_t *p, size_t bytes)
{
	struct packet_data_store *pds;
	size_t have_bytes;
	char *buf_start;

	if(likely(PT_UNKNOWN != p->type)) {
		have_bytes = sizeof(p->pd.out);
		buf_start  = p->pd.out;
	} else {
		have_bytes = sizeof(p->pd.out) - p->type_length;
		buf_start  = &p->pd.out[p->type_length];
	}
	if(have_bytes < bytes)
		goto must_malloc;

	p->data_trunk.data  = buf_start;
	p->data_trunk.limit = p->data_trunk.capacity = have_bytes;
	p->data_trunk.pos   = have_bytes - bytes;
	p->data_trunk_is_freeable = false;

	return true;

must_malloc:
	pds = malloc(sizeof(*pds) + bytes);
	if(!pds)
		return false;
	atomic_set(&pds->refcnt, 1);
	p->data_trunk.data = pds->data;
	p->data_trunk.capacity = bytes;
	buffer_clear(p->data_trunk);
	p->data_trunk_is_freeable = true;
	return true;
}

static bool g2_packet_decide_spec_int(struct ptype_action_args *parg, g2_ptype_action_func const *work_type)
{
	g2_packet_t *packs = parg->source;
	prefetch(&work_type[packs->type]);
	if(unlikely(PT_MAXIMUM <= packs->type)) {
		logg_develd("packet with broken type: %u\n", (unsigned)packs->type);
		return false;
	}

	if(work_type[packs->type])
	{
		prefetch(*work_type[packs->type]);
		if(likely(empty_action_p != work_type[packs->type] && unimpl_action_p != work_type[packs->type]) &&
			PT_CH != packs->type) {
			logg_packet("*/%s\tC: %s\n", g2_ptype_names[packs->type], packs->is_compound ? "true" : "false");
		}
		return work_type[packs->type](parg);
	}

	logg_packet("*/%s\tC: %s -> No action\n", g2_ptype_names[packs->type], packs->is_compound ? "true" : "false");
	return false;
}

static bool magic_route(struct ptype_action_args *parg, uint8_t *guid)
{
	union combo_addr na;

	if(!g2_guid_lookup(guid, GT_LEAF, &na))
		return false;

	return !!g2_conreg_for_addr(&na, forward_lit_callback_ignore, parg);
}

bool g2_packet_decide_spec(struct ptype_action_args *parg, g2_ptype_action_func const *work_type)
{
	uint8_t *guid;
	/* if we are called from external (for a root packet), check for routing */
	if(g2_packet_needs_routing(parg->source, &guid))
		return magic_route(parg, guid);

	return g2_packet_decide_spec_int(parg, work_type);
}

/*inline bool g2_packet_decide(g2_connection_t *connec, struct list_head *target, const g2_p_type_t *work_type)
{
	return g2_packet_decide_spec(connec, target, work_type, connec->akt_packet);
}*/

static char const rcsid_p[] GCC_ATTR_USED_VAR = "$Id: G2Packet.c,v 1.12 2004/12/18 18:06:13 redbully Exp redbully $";
/* EOF */
