/*
 * G2Packet.c
 * helper-functions for G2-packets
 *
 * Copyright (c) 2004 - 2009 Jan Seiffert
 *
 * This file is part of g2cd.
 *
 * g2cd is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version
 * 2 as published by the Free Software Foundation.
 *
 * g2cd is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public
 * License along with g2cd; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
 * MA  02111-1307  USA
 *
 * $Id: G2Packet.c,v 1.12 2004/12/18 18:06:13 redbully Exp redbully $
 */

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
/* System includes */
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <stdbool.h>
#include <time.h>
#ifdef HAVE_DLOPEN
# include <dlfcn.h>
#endif
/* other */
#include "lib/other.h"
/* own includes */
#define _G2PACKET_C
#define _NEED_G2_P_TYPE
#include "G2Packet.h"
#include "G2PacketSerializer.h"
#include "G2QHT.h"
#include "G2KHL.h"
#include "G2MainServer.h"
#include "G2ConRegistry.h"
#include "G2QueryKey.h"
#include "lib/sec_buffer.h"
#include "lib/log_facility.h"

/* minutes to seconds */
#define PI_TIMEOUT    (   30)
#define LNI_TIMEOUT   ( 1*60)
#define KHL_TIMEOUT   ( 2*60)
#define QHT_TIMEOUT   ( 5*60)
#define UPROC_TIMEOUT (15*60)
#define G2CDC_TIMEOUT (30*60)

/*
 * Autogenerated packet typer table
 * include NO where else!!
 */
#include "G2PacketTyper.h"

/*
 * Internal Prototypes
 */
static inline bool g2_packet_steal_data_space(g2_packet_t *, size_t);
/* packet handler */
static bool empty_action_p(struct ptype_action_args *);
static bool unimpl_action_p(struct ptype_action_args *);
static bool handle_KHL(struct ptype_action_args *);
static bool handle_KHL_TS(struct ptype_action_args *);
static bool handle_KHL_NH(struct ptype_action_args *);
static bool handle_KHL_CH(struct ptype_action_args *);
static bool handle_LNI(struct ptype_action_args *);
static bool handle_LNI_FW(struct ptype_action_args *);
static bool handle_LNI_HS(struct ptype_action_args *);
static bool handle_LNI_NA(struct ptype_action_args *);
static bool handle_LNI_GU(struct ptype_action_args *);
static bool handle_LNI_QK(struct ptype_action_args *);
static bool handle_LNI_V(struct ptype_action_args *);
static bool handle_PI(struct ptype_action_args *);
static bool handle_Q2(struct ptype_action_args *);
static bool handle_QHT(struct ptype_action_args *);
static bool handle_QKR(struct ptype_action_args *);
static bool handle_QKR_RNA(struct ptype_action_args *parg);
static bool handle_QKR_QNA(struct ptype_action_args *parg);
static bool handle_QKR_SNA(struct ptype_action_args *parg);
static bool handle_QKR_REF(struct ptype_action_args *parg);
static bool handle_QKA(struct ptype_action_args *);
static bool handle_QKA_QK(struct ptype_action_args *);
static bool handle_QKA_SNA(struct ptype_action_args *);
static bool handle_QKA_QNA(struct ptype_action_args *);
static bool handle_QKA_CACHED(struct ptype_action_args *);
static bool handle_HAW(struct ptype_action_args *);
static bool handle_UPROC(struct ptype_action_args *);
static bool handle_UPROD(struct ptype_action_args *);
static bool handle_G2CDC(struct ptype_action_args *);

/*
 * Packet dicts
 */
/* main dict */
const g2_ptype_action_func g2_packet_dict[PT_MAXIMUM] GCC_ATTR_VIS("hidden") =
{
	[PT_CRAWLA] = empty_action_p,
	[PT_CRAWLR] = unimpl_action_p,
	[PT_G2CDc ] = handle_G2CDC,
	[PT_KHL   ] = handle_KHL,
	[PT_LNI   ] = handle_LNI,
	[PT_HAW   ] = handle_HAW,
	[PT_PI    ] = handle_PI,
	[PT_PO    ] = unimpl_action_p,
	[PT_PUSH  ] = unimpl_action_p,
	[PT_Q2    ] = handle_Q2,
	[PT_QA    ] = unimpl_action_p,
	[PT_QHT   ] = handle_QHT,
	[PT_QKR   ] = handle_QKR,
	[PT_QKA   ] = handle_QKA,
	[PT_UPROC ] = handle_UPROC,
	[PT_UPROD ] = handle_UPROD,
};

const g2_ptype_action_func g2_packet_dict_udp[PT_MAXIMUM] GCC_ATTR_VIS("hidden") =
{
	[PT_KHLR  ] = unimpl_action_p,
	[PT_PI    ] = handle_PI,
	[PT_JCT   ] = empty_action_p,
	[PT_QKR   ] = handle_QKR,
	[PT_QKA   ] = handle_QKA,
};

/* PI-childs */
static const g2_ptype_action_func PI_packet_dict[PT_MAXIMUM] =
{
	[PT_UDP   ] = unimpl_action_p,
	[PT_RELAY ] = unimpl_action_p,
};

/* LNI-childs */
static const g2_ptype_action_func LNI_packet_dict[PT_MAXIMUM] =
{
	[PT_FW] = handle_LNI_FW,
	[PT_GU] = handle_LNI_GU,
	[PT_HS] = handle_LNI_HS,
	[PT_LS] = empty_action_p,
	[PT_NA] = handle_LNI_NA,
	[PT_QK] = handle_LNI_QK,
	[PT_V ] = handle_LNI_V,
};

/* KHL-childs */
static const g2_ptype_action_func KHL_packet_dict[PT_MAXIMUM] =
{
	[PT_TS] = handle_KHL_TS,
	[PT_NH] = handle_KHL_NH,
	[PT_CH] = handle_KHL_CH,
};

/* Q2-childs */
static const g2_ptype_action_func Q2_packet_dict[PT_MAXIMUM] =
{
	[PT_UDP] = unimpl_action_p,
	[PT_URN] = unimpl_action_p,
	[PT_DN ] = unimpl_action_p,
	[PT_MD ] = unimpl_action_p,
	[PT_SZR] = unimpl_action_p,
	[PT_I  ] = unimpl_action_p,
};

/* QA-childs */
static const g2_ptype_action_func QA_packet_dict[PT_MAXIMUM] =
{
	[PT_TS] = unimpl_action_p,
	[PT_D ] = unimpl_action_p,
	[PT_S ] = unimpl_action_p,
	[PT_RA] = unimpl_action_p,
	[PT_FR] = unimpl_action_p,
};

/* QH2-childs */
static const g2_ptype_action_func QH2_packet_dict[PT_MAXIMUM] =
{
	[PT_GU  ] = unimpl_action_p,
	[PT_NA  ] = unimpl_action_p,
	[PT_NH  ] = unimpl_action_p,
	[PT_V   ] = unimpl_action_p,
	[PT_BUP ] = unimpl_action_p,
	[PT_PCH ] = unimpl_action_p,
	[PT_HG  ] = unimpl_action_p,
	[PT_H   ] = unimpl_action_p,
	[PT_MD  ] = unimpl_action_p,
	[PT_UPRO] = unimpl_action_p,
};

/* QKR-childs */
static const g2_ptype_action_func QKR_packet_dict[PT_MAXIMUM] =
{
	[PT_RNA] = handle_QKR_RNA,
	[PT_QNA] = handle_QKR_QNA,
	[PT_SNA] = handle_QKR_SNA,
	[PT_REF] = handle_QKR_REF,
};

/* QKA-childs */
static const g2_ptype_action_func QKA_packet_dict[PT_MAXIMUM] =
{
	[PT_QK    ] = handle_QKA_QK,
	[PT_QNA   ] = handle_QKA_QNA,
	[PT_SNA   ] = handle_QKA_SNA,
	[PT_CACHED] = handle_QKA_CACHED,
};

/* CRAWLR-childs */
static const g2_ptype_action_func CRAWLR_packet_dict[PT_MAXIMUM] =
{
	[PT_REXT ] = unimpl_action_p,
	[PT_RGPS ] = unimpl_action_p,
	[PT_RLEAF] = unimpl_action_p,
	[PT_RNAME] = unimpl_action_p,
};

/* HAW-childs */
static const g2_ptype_action_func HAW_packet_dict[PT_MAXIMUM] =
{
	[PT_HS] = unimpl_action_p,
	[PT_NA] = unimpl_action_p,
	[PT_V ] = unimpl_action_p,
};

#define ENUM_CMD(x, y) str_it(x)
const char const g2_ptype_names[][8] GCC_ATTR_VIS("hidden") =
{
	G2_PACKET_TYPES
};
#undef ENUM_CMD

#define ENUM_CMD(x, y) str_size(str_it(x))
const uint8_t const g2_ptype_names_length[] GCC_ATTR_VIS("hidden") =
{
	G2_PACKET_TYPES
};
#undef ENUM_CMD

/*
 * Packet typer function
 *
 */
void g2_packet_find_type(g2_packet_t *packet, const char type_str[16])
{
	unsigned i = g2_ptype_dict_table[(unsigned char)type_str[0]] << 1;
	unsigned j = 1;

	prefetch(&g2_ptype_state_table[i]);
	packet->type = PT_UNKNOWN;
	if(unlikely((unsigned char)-1 == i))
		goto out;

	do
	{
		const unsigned char x = g2_ptype_state_table[i].c;
		const char match = T_GET_CHAR(x);
		logg_develd_old("\tp x: 0x%02X m: 0x%02X, '%c', %i, %i\n", x, match ? : '0',
			type_str[j] ? : '0', i, g2_ptype_state_table[i].u.d);
		if(likely(type_str[j] == match))
		{
			if(likely(T_IS_LAST(x))) {
				if(likely(type_str[j+1] == '\0')) {
					packet->type = T_GET_TYPE(g2_ptype_state_table[i].u.t);
					break;;
				}
			} else {
				i += T_GET_DELTA(g2_ptype_state_table[i].u.d);
				j++;
				continue;
			}
		}
		if(unlikely(T_IS_END(g2_ptype_state_table[i].u.d)))
			break;
		i++;
	} while(j < 16);

out:
	if(unlikely(PT_UNKNOWN == packet->type))
		logg_posd(LOGF_DEBUG, "Unknown packet type \"%s\"\tC: %s\n", type_str, packet->is_compound ? "true" : "false");
}

/*
 * prebuild packets
 */
static const char packet_po[]    = { 0x08, 'P', 'O', };
static const char packet_uproc[] = { 0x20, 'U', 'P', 'R', 'O', 'C' };

#define logg_packet(x, ...) logg_develd("\t"x, __VA_ARGS__)
#define logg_packet_old(x, ...) logg_develd_old("\t"x, __VA_ARGS__)
#define STDSF	"%s\n"
#define STDLF	"%s -> /%s\n"

/*
 * Packet handler helper
 *
 */
static bool read_na_from_packet(g2_packet_t *source, union combo_addr *target, const char *name)
{
	size_t rem = buffer_remaining(source->data_trunk);
	uint16_t tmp_port;

	if(6 != rem && 18 != rem) {
		logg_packet(STDLF, name, "NA not an IPv4 or IPv6 address");
		return false;
	}

	memset(target, 0, sizeof(*target));
	/* We Assume network byte order for the IP */
	if(6 == rem) {
		target->s_fam = AF_INET;
		get_unaligned(target->in.sin_addr.s_addr, (uint32_t *) buffer_start(source->data_trunk));
		source->data_trunk.pos += sizeof(uint32_t);
	} else {
		target->s_fam = AF_INET6;
		memcpy(&target->in6.sin6_addr.s6_addr, buffer_start(source->data_trunk), INET6_ADDRLEN);
		source->data_trunk.pos += INET6_ADDRLEN;
	}

	/* load port and fix it for those, who sent it the wrong way round */
	get_unaligned(tmp_port, (uint16_t *) buffer_start(source->data_trunk));
	if(!source->big_endian)
		tmp_port = (tmp_port >> 8) | (tmp_port << 8);
	combo_addr_set_port(target, tmp_port);

	logg_packet("%s:\t%p#I\n", name, target);
	return true;
}

static bool unexpected_child(g2_packet_t *s, const char *name)
{
	if(s->is_compound) {
		logg_packet("%s\twith child! len: %zu\n", name, buffer_remaining(s->data_trunk));
		return true;
	}
	return false;
}

/*
 * Packet handler functions
 *
 *
 */
static bool empty_action_p(struct ptype_action_args *parg GCC_ATTR_UNUSED_PARAM)
{
	/* packet is not useful for us */
	logg_packet("*/%s\tC: %s -> ignored\n", g2_ptype_names[parg->source->type], parg->source->is_compound ? "true" : "false");
	return false;
}

static bool unimpl_action_p(struct ptype_action_args *parg GCC_ATTR_UNUSED_PARAM)
{
	/* packet should be handled,  */
	logg_packet("*/%s\tC: %s -> unimplemented\n", g2_ptype_names[parg->source->type], parg->source->is_compound ? "true" : "false");
	return false;
}

static bool handle_KHL(struct ptype_action_args *parg)
{
	struct khl_entry khle[16];
	struct ptype_action_args cparg;
	g2_packet_t *khl, *ts;
	size_t res;
	bool ret_val = false, keep_decoding;

	cparg = *parg;
	do
	{
		g2_packet_t child_p;
		cparg.source = &child_p;
		child_p.more_bytes_needed = false;
		child_p.packet_decode = CHECK_CONTROLL_BYTE;
		keep_decoding = g2_packet_decode_from_packet(parg->source, &child_p, 0);
		if(!keep_decoding) {
			logg_packet(STDLF, "KHL", "broken child");
			parg->connec->flags.dismissed = true;
			break;
		}
		if(likely(child_p.packet_decode == DECODE_FINISHED))
			ret_val |= g2_packet_decide_spec(&cparg, KHL_packet_dict);
	} while(keep_decoding && parg->source->packet_decode != DECODE_FINISHED);

	/* time to send a packet again? */
	if(local_time_now < (parg->connec->u.send_stamps.KHL + (KHL_TIMEOUT)))
		return ret_val;

	/* build package */
	khl = g2_packet_calloc();
	ts  = g2_packet_calloc();

	if(!(khl && ts))
		goto out_fail;

	khl->type = PT_KHL;
	ts->type  = PT_TS;
	if(g2_packet_steal_data_space(ts, sizeof(time_t)))
	{
		time_t now = local_time_now;
		put_unaligned(now, (time_t *)(buffer_start(ts->data_trunk)));
		ts->big_endian = HOST_IS_BIGENDIAN;
		list_add_tail(&ts->list, &khl->children);
	}
	else
		goto out_fail;

	res = g2_khl_fill_p(khle, anum(khle), parg->connec->remote_host.s_fam);
	while(res--)
	{
		g2_packet_t *ch = g2_packet_calloc();
		size_t old_pos;
		unsigned i;
		uint16_t port;

		if(!ch)
			break;
		ch->type = PT_CH;
		i  =  sizeof(time_t) + sizeof(uint16_t);
		i +=  AF_INET == khle[res].na.s_fam ? sizeof(uint32_t) : INET6_ADDRLEN;
		if(!g2_packet_steal_data_space(ch, i)) {
			g2_packet_free(ch);
			break;
		}

		old_pos = ch->data_trunk.pos;
		if(AF_INET == khle[res].na.s_fam) {
			put_unaligned(khle[res].na.in.sin_addr.s_addr, (uint32_t *)(buffer_start(ch->data_trunk)));
			ch->data_trunk.pos += sizeof(uint32_t);
		} else {
			memcpy(&khle[res].na.in6.sin6_addr.s6_addr, buffer_start(ch->data_trunk), INET6_ADDRLEN);
			ch->data_trunk.pos += INET6_ADDRLEN;
		}
		port = combo_addr_port(&khle[res].na);
		port = ntohs(port);
		put_unaligned(port, (uint16_t *)buffer_start(ch->data_trunk));
		ch->data_trunk.pos += sizeof(uint16_t);
		put_unaligned(khle[res].when, (time_t *)buffer_start(ch->data_trunk));

		ch->data_trunk.pos = old_pos;
		ch->big_endian = HOST_IS_BIGENDIAN;
		list_add_tail(&ch->list, &khl->children);
	}
	khl->big_endian = HOST_IS_BIGENDIAN;

	list_add_tail(&khl->list, parg->target);
	parg->connec->u.send_stamps.KHL = local_time_now;
	return true;
out_fail:
	g2_packet_free(ts);
	g2_packet_free(khl);
	return false;
}

static bool handle_KHL_TS(struct ptype_action_args *parg)
{
	g2_packet_t *source = parg->source;
	time_t foreign_time;
	time_t local_time;
	foreign_time = local_time = local_time_now;

	if(unlikely(unexpected_child(source, "/KHL/TS")))
		goto out;

	if(unlikely(4 != buffer_remaining(source->data_trunk) &&
	            8 != buffer_remaining(source->data_trunk))) {
		logg_packet(STDLF, "/KHL/TS", "TS not 4 or 8 byte");
		goto out;
	}

	/* fill the upper bit of time_t if we need more than the recvd 32 bit */
	if(8 == sizeof(time_t))
		foreign_time &= (time_t)0xFFFFFFFF00000000;
	else
		foreign_time = 0;

	/* the most commen case 32-bit time_t and little endian (all the Win-Clients) */
	if(likely(4 == buffer_remaining(source->data_trunk)))
	{
		uint32_t t;
		get_unaligned_endian(t, (uint32_t *)buffer_start(source->data_trunk),
		                     source->big_endian);
		foreign_time |= (time_t)t;
	}
	else
	{
		uint64_t t;
		logg_packet(STDLF, "/KHL", "TS with 8 byte! Ola, a 64-bit OS?");
		/*
		 * Lets try too cludge it together, if we also have a 64-bit OS,
		 * everything will be fine, if not, we hopefully get the lower 32 bit,
		 * and if we don't test at the moment of overflow in 2013 (or when ever)
		 * it should work
		 */
		get_unaligned_endian(t, (uint64_t *)buffer_start(source->data_trunk),
		                     source->big_endian);
		foreign_time = (time_t)t;
	}
	logg_packet("/KHL/TS -> %lu\t%lu\n", (unsigned long)foreign_time, (unsigned long)local_time);

out:
	parg->connec->time_diff = (long)local_time - (long)foreign_time;
	return false;
}

static bool handle_KHL_NH(struct ptype_action_args *parg)
{
	g2_packet_t *source = parg->source;
	union combo_addr addr;

	/* we can not read a address in this case ATM */
// TODO: read/remove child packets (guid, ts, qk, etc.)
	if(unexpected_child(source, "/KHL/NH"))
		return false;

	if(read_na_from_packet(source, &addr, "/KHL/NH"))
		g2_khl_add(&addr, local_time_now, true);
	return false;
}

static bool handle_KHL_CH(struct ptype_action_args *parg)
{
	g2_packet_t *source = parg->source;
	g2_connection_t *connec = parg->connec;
	char *src = buffer_start(source->data_trunk);
	size_t remaining = buffer_remaining(source->data_trunk);
	union combo_addr addr;
	time_t when;
	uint16_t tmp_port;

	/*
	 * who thought of that shit???
	 * "Hey, lets cram all kind of binary numbers which will /never/ change
	 * their size into one blob" yeah, maybe on winblow... IPv6? 64bit time_t?
	 *
	 *	IP	Port	TS
	 *	4	2	4	= 10 winblow
	 *	16	2	4	= 20 IPv6
	 *	16	2	8	= 24 IPv6 + 64bit time_t
	 *	4	2	8	= 14 64bit time_t
	 *
	 * and the docs say nothing about endianess...
	 * looks like ip in net byte order, rest in host byte order
	 */
	/* we can not read a address in this case ATM */
// TODO: read/remove child packets (guid, ts, qk, etc.)
	if(unexpected_child(source, "/KHL/CH"))
		return false;

	memset(&addr, 0, sizeof(addr));
	if(8 == sizeof(time_t))
		when = local_time_now & (time_t)0xFFFFFFFF00000000;
	else
		when = 0;
	if(likely(10 == remaining))
	{
		uint32_t t;
		addr.s_fam = AF_INET;
		get_unaligned(addr.in.sin_addr.s_addr, (uint32_t *) src);
		src += sizeof(uint32_t);
		get_unaligned(tmp_port, (uint16_t *) src);
		src += sizeof(uint16_t);
		get_unaligned_endian(t, (uint32_t *) src, source->big_endian);
		when |= (time_t)(t + connec->time_diff);
	}
	else if(20 == remaining)
	{
		uint32_t t;
		addr.s_fam = AF_INET6;
		memcpy(&addr.in6.sin6_addr.s6_addr, src, INET6_ADDRLEN);
		src += INET6_ADDRLEN;
		get_unaligned(tmp_port, (uint16_t *) src);
		src += sizeof(uint16_t);
		get_unaligned_endian(t, (uint32_t *) src, source->big_endian);
		when |= (time_t)(t + connec->time_diff);
	}
	else if(24 == remaining)
	{
		uint64_t t;
		addr.s_fam = AF_INET6;
		memcpy(&addr.in6.sin6_addr.s6_addr, src, INET6_ADDRLEN);
		src += INET6_ADDRLEN;
		get_unaligned(tmp_port, (uint16_t *) src);
		src += sizeof(uint16_t);
		get_unaligned_endian(t, (uint64_t *) src, source->big_endian);
		when = (time_t)(t + connec->time_diff);
	}
	else if(14 == remaining)
	{
		uint64_t t;
		addr.s_fam = AF_INET;
		get_unaligned(addr.in.sin_addr.s_addr, (uint32_t *) src);
		src += sizeof(uint32_t);
		get_unaligned(tmp_port, (uint16_t *) src);
		src += sizeof(uint16_t);
		get_unaligned_endian(t, (uint64_t *) src, source->big_endian);
		when = (time_t)(t + connec->time_diff);
	} else
		goto out;

	if(likely(!source->big_endian))
		tmp_port = (tmp_port >> 8) | (tmp_port << 8);
	combo_addr_set_port(&addr, tmp_port);
	g2_khl_add(&addr, when, false);
out:
	return false;
}

static bool handle_LNI(struct ptype_action_args *parg)
{
	g2_connection_t *connec = parg->connec;
	struct ptype_action_args cparg;
	g2_packet_t *lni, *na, *gu, *v, *hs;
	bool ret_val = false, keep_decoding;
	bool had_LNI_HS = false;

	cparg = *parg;
	cparg.opaque = &had_LNI_HS;
	do
	{
		g2_packet_t child_p;
		cparg.source = &child_p;
		child_p.more_bytes_needed = false;
		child_p.packet_decode = CHECK_CONTROLL_BYTE;
		keep_decoding = g2_packet_decode_from_packet(parg->source, &child_p, 0);
		if(!keep_decoding) {
			logg_packet(STDLF, "LNI", "broken child");
			connec->flags.dismissed = true;
			break;
		}
		if(likely(child_p.packet_decode == DECODE_FINISHED))
			ret_val |= g2_packet_decide_spec(&cparg, LNI_packet_dict);
	} while(keep_decoding && parg->source->packet_decode != DECODE_FINISHED);

	if(!had_LNI_HS && connec->flags.upeer)
	{
		/* demote connection from hub mode */
		connec->flags.upeer = false;
// TODO: remove from hub connections
		/* connection is no hub anymore, add to QHTs */
		g2_conreg_mark_dirty(connec);
		if(connec->sent_qht) {
			struct qhtable *t = connec->sent_qht;
			connec->sent_qht = NULL;
			g2_qht_put(t);
		}
	}

	/* time to send a packet again? */
	if(unlikely(local_time_now < (connec->u.send_stamps.LNI + (LNI_TIMEOUT))))
		return ret_val;

	/* build package */
	lni = g2_packet_calloc();
	na  = g2_packet_calloc();
	gu  = g2_packet_calloc();
	v   = g2_packet_calloc();
	hs  = likely(server.status.our_server_upeer) ? g2_packet_calloc() : NULL;

	if(!(lni && na))
		goto out_fail;

	lni->type = PT_LNI;
	na->type = PT_NA;
// TODO: handle IPv6
	if(g2_packet_steal_data_space(na, 6))
	{
		uint16_t port;
		uint32_t addr;
		union combo_addr local_addr;
		socklen_t sin_size = sizeof(local_addr);

		if(getsockname(connec->com_socket, &local_addr.sa, &sin_size))
			goto out_fail;
		addr = local_addr.in.sin_addr.s_addr;
		port = combo_addr_port(&local_addr);
		port = ntohs(port);
		put_unaligned(addr, (uint32_t *)buffer_start(na->data_trunk));
		put_unaligned(port, (uint16_t *)(buffer_start(na->data_trunk)+4));
		na->big_endian = HOST_IS_BIGENDIAN;
		list_add_tail(&na->list, &lni->children);
	}
	else
		goto out_fail;

	if(v)
	{
		v->type = PT_V;
		v->data_trunk.data     = (void*)(intptr_t)OWN_VENDOR_CODE;
		v->data_trunk.capacity = str_size(OWN_VENDOR_CODE);
		buffer_clear(v->data_trunk);
		list_add_tail(&v->list, &lni->children);
	}
	if(gu)
	{
		gu->type = PT_GU;
		gu->data_trunk.data     = (char *)server.settings.our_guid;
		gu->data_trunk.capacity = sizeof(server.settings.our_guid);
		buffer_clear(gu->data_trunk);
		list_add_tail(&gu->list, &lni->children);
	}
	if(hs)
	{
		hs->type = PT_HS;
		if(g2_packet_steal_data_space(hs, 4))
		{
			uint16_t cons     = (uint16_t)atomic_read(&server.status.act_connection_sum);
			uint16_t max_cons = server.settings.max_connection_sum;
			put_unaligned(cons, (uint16_t *)buffer_start(hs->data_trunk));
			put_unaligned(max_cons, (uint16_t *)(buffer_start(hs->data_trunk)+2));
			hs->big_endian = HOST_IS_BIGENDIAN;
			list_add_tail(&hs->list, &lni->children);
		}
		else
			g2_packet_free(hs);
	}
	lni->big_endian = HOST_IS_BIGENDIAN;
	list_add_tail(&lni->list, parg->target);
	parg->connec->u.send_stamps.LNI = local_time_now;

	return true;
out_fail:
	g2_packet_free(lni);
	g2_packet_free(na);
	g2_packet_free(gu);
	g2_packet_free(v);
	g2_packet_free(hs);
	return false;
}

static bool handle_LNI_FW(struct ptype_action_args *parg)
{
	logg_packet_old("/LNI/FW\n");
	parg->connec->flags.firewalled = true;
// TODO: reset this state if a LNI without FW comes in
	return false;
}

static bool handle_LNI_HS(struct ptype_action_args *parg)
{
	g2_connection_t *connec = parg->connec;
	g2_packet_t *source = parg->source;
	uint16_t akt_leaf = 0, max_leaf = 0;
	size_t rem = buffer_remaining(source->data_trunk);

	/* we can not read any info in this case */
	if(likely(!unexpected_child(source, "/LNI/HS")))
	{
		/* sometimes Shareaza only sends 2 bytes, thats only the leaf count */
		if(2 <= rem)
			get_unaligned_endian(akt_leaf, (uint16_t *) buffer_start(source->data_trunk), source->big_endian);
		if(4 <= rem)
			get_unaligned_endian(max_leaf, (uint16_t *) (buffer_start(source->data_trunk)+2), source->big_endian);

		logg_packet("/LNI/HS:\told: %s leaf: %u max: %u\n",
				connec->flags.upeer ? G2_TRUE : G2_FALSE, akt_leaf, max_leaf);
	}

	if(!connec->flags.upeer) {
// TODO: now this connection is a hub connection, add it there
		connec->flags.upeer = true;
		/* connection is now a hub, remove from QHTs */
		g2_conreg_mark_dirty(connec);
	}
	connec->flags.upeer = true;
	*(bool *)parg->opaque = true;

	return false;
}

static bool handle_LNI_GU(struct ptype_action_args *parg)
{
	if(unlikely(unexpected_child(parg->source, "/LNI/GU")))
		return false;

// TODO: add guid to routing/known guid cache
	if(sizeof(parg->connec->guid) == buffer_remaining(parg->source->data_trunk))
		memcpy(parg->connec->guid, buffer_start(parg->source->data_trunk), sizeof(parg->connec->guid));
	else
		logg_packet(STDLF, "/LNI/GU", "GU not a valid GUID");

	return false;
}

static bool handle_LNI_QK(struct ptype_action_args *parg)
{
	logg_packet_old("/LNI/QK\t\tlen: %zu\n", buffer_remaining(parg->source->data_trunk));
	parg->connec->flags.query_key_cache = true;
	return false;
}

static bool handle_LNI_NA(struct ptype_action_args *parg)
{
	/* we can not read an address in this case ATM */
	if(unlikely(unexpected_child(parg->source, "/LNI/NA")))
		return false;

	read_na_from_packet(parg->source, &parg->connec->sent_addr, "/LNI/NA");
	return false;
}

static bool handle_LNI_V(struct ptype_action_args *parg)
{
	g2_connection_t *connec = parg->connec;
	g2_packet_t *source = parg->source;
	size_t min_length;

	/* we can not read an vendor code in this case ATM */
	if(unlikely(unexpected_child(source, "/LNI/V")))
		return false;

	min_length =
		(buffer_remaining(source->data_trunk) < (sizeof(connec->vendor_code)-1) ?
		buffer_remaining(source->data_trunk) : sizeof(connec->vendor_code)-1);
	memcpy(connec->vendor_code, buffer_start(source->data_trunk), min_length);
	connec->vendor_code[min_length] = '\0';

	logg_packet_old(STDLF, "\t/LNI/V", connec->vendor_code);
	
	return false;
}

static bool handle_PI(struct ptype_action_args *parg)
{
	g2_packet_t *po;

	/* not simple /PI-packet? */
	if(parg->source->is_compound)
	{
		struct ptype_action_args cparg;
		bool ret_val = false, keep_decoding;

		cparg = *parg;
		do
		{
			g2_packet_t child_p;
			cparg.source = &child_p;
			child_p.more_bytes_needed = false;
			child_p.packet_decode = CHECK_CONTROLL_BYTE;
			keep_decoding = g2_packet_decode_from_packet(parg->source, &child_p, 0);
			if(!keep_decoding) {
				logg_packet(STDLF, "PI", "broken child");
				if(parg->connec)
					parg->connec->flags.dismissed = true;
				break;
			}
			if(likely(child_p.packet_decode == DECODE_FINISHED))
				ret_val |= g2_packet_decide_spec(&cparg, PI_packet_dict);
		} while(keep_decoding && parg->source->packet_decode != DECODE_FINISHED);
		return ret_val;
	}

	/* time to send a packet again? */
	if(parg->connec) {
		if(local_time_now < (parg->connec->u.send_stamps.PI + (PI_TIMEOUT)))
			return false;
	}

	po = g2_packet_calloc();
	if(!po) {
		logg_packet(STDLF, "\t/PI", "alloc failed");
		return false;
	}
	po->type = PT_PO;
	list_add_tail(&po->list, parg->target);
	if(parg->connec)
		parg->connec->u.send_stamps.PI = local_time_now;
	logg_packet_old(STDSF, "\t/PI");

	return true;
}

static bool handle_Q2(struct ptype_action_args *parg)
{
	struct ptype_action_args cparg;
	bool ret_val = false, keep_decoding;

	cparg = *parg;
	do
	{
		g2_packet_t child_p;
		cparg.source = &child_p;
		child_p.more_bytes_needed = false;
		child_p.packet_decode = CHECK_CONTROLL_BYTE;
		keep_decoding = g2_packet_decode_from_packet(parg->source, &child_p, 0);
		if(!keep_decoding)
		{
			logg_packet(STDLF, "Q2", "broken child");
			parg->connec->flags.dismissed = true;
			break;
		}
		if(child_p.packet_decode == DECODE_FINISHED)
			ret_val |= g2_packet_decide_spec(&cparg, Q2_packet_dict);
//		source->num_child++; // put within if
	} while(keep_decoding && parg->source->packet_decode != DECODE_FINISHED);

	return ret_val;
}

static inline bool handle_QHT_patch(g2_connection_t *connec, g2_packet_t *source)
{
	struct qht_fragment *frag;
	int ret_val;
	const char *patch_txt;

	if(unlikely(!connec->qht)) {
		logg_packet(STDLF, "/QHT-patch", "initial patch without initial reset");
		connec->flags.dismissed = true;
		return false;
	}

	if(unlikely((QHT_PATCH_HEADER_BYTES-1) > buffer_remaining(source->data_trunk))) {
		logg_packet(STDLF, "/QHT-patch", "to short");
		connec->flags.dismissed = true;
		goto qht_patch_end;
	}

	if(unlikely(1 != *(buffer_start(source->data_trunk)+3))) {
		logg_packet(STDLF, "/QHT-patch", "illegal bit-number");
		connec->flags.dismissed = true;
		goto qht_patch_end;
	}
	if(unlikely(connec->flags.dismissed)) {
		logg_packet(STDLF, "/QHT-patch", "connection dissmissed");
		goto qht_patch_end;
	}

	frag = g2_qht_frag_alloc(buffer_remaining(source->data_trunk)
	                         - (QHT_PATCH_HEADER_BYTES-1));
	if(!frag) {
		logg_packet(STDLF, "/QHT-patch", "no mem for fragment");
		connec->flags.dismissed = true;
		goto qht_patch_end;
	}
	frag->nr         = ((unsigned)*buffer_start(source->data_trunk)) & 0x00FF;
	frag->count      = ((unsigned)*(buffer_start(source->data_trunk)+1)) & 0x00FF;
	frag->compressed = ((unsigned)*(buffer_start(source->data_trunk)+2)) & 0x00FF;
	source->data_trunk.pos += QHT_PATCH_HEADER_BYTES-1;
	ret_val = g2_qht_add_frag(connec->qht, frag, (uint8_t *)buffer_start(source->data_trunk));

	if(likely(0 == ret_val)) { /* patch io, but need more */
		logg_packet(STDLF, "/QHT-patch", "patch recieved");
		return false;
	} else if(0 > ret_val) { /* patch nio */
		connec->flags.dismissed = true;
		free(frag);
		goto qht_patch_end;
	}
	/* patch io and complete */
	patch_txt = g2_qht_patch(connec->qht, connec->qht->fragments);
	/* we patched a connection, not some free standing QHT */
	if(!connec->flags.upeer)
		g2_conreg_mark_dirty(connec);
	logg_packet(STDLF, "/QHT-patch", patch_txt ? patch_txt : "some error while appling");
qht_patch_end:
	g2_qht_frag_free(connec->qht->fragments);
	connec->qht->fragments = NULL;
	return false;
}

static inline bool handle_QHT_reset(g2_connection_t *connec, g2_packet_t *source)
{
	uint32_t qht_ent;

	if(unlikely((QHT_RESET_HEADER_BYTES-1) != buffer_remaining(source->data_trunk))) {
		logg_packet(STDLF, "/QHT-reset", "to short");
		connec->flags.dismissed = true;
		return false;
	}
	
	if(unlikely(1 != *(buffer_start(source->data_trunk)+4))) {
		logg_packet(STDLF, "/QHT-reset", "illegal infinity");
		connec->flags.dismissed = true;
		return false;
	}

	get_unaligned_endian(qht_ent, (uint32_t *)buffer_start(source->data_trunk), source->big_endian);
	
	if(unlikely(g2_qht_reset(&connec->qht, qht_ent, server.settings.qht.compress_internal)))
		connec->flags.dismissed = true;
	else if(!connec->flags.upeer)
		g2_conreg_mark_dirty(connec);

	logg_packet(STDSF, "/QHT-reset");
	return false;
}

static bool handle_QHT(struct ptype_action_args *parg)
{
	g2_connection_t *connec = parg->connec;
	g2_packet_t *source = parg->source;
	struct list_head *target = parg->target;
	struct qht_fragment *frags;
	struct qhtable *master_qht;
	g2_packet_t *qht = NULL;
	char tmp;
	bool ret_val = false;

	/* we can not read the qht in this case ATM */
	if(unlikely(unexpected_child(source, "/QHT")))
		return false;

	if(unlikely(!buffer_remaining(source->data_trunk))) {
		logg_packet(STDLF, "/QHT", "without data?");
		return false;
	}

	tmp = *buffer_start(source->data_trunk);
	source->data_trunk.pos++;
	
	if(1 == tmp)
		ret_val = handle_QHT_patch(connec, source);
	else if(0 == tmp)
		ret_val = handle_QHT_reset(connec, source);
	else
		logg_packet(STDLF, "/QHT", "with unknown command");

	if(unlikely(ret_val) || !connec->flags.upeer || local_time_now < (connec->u.send_stamps.QHT + (QHT_TIMEOUT)))
		return ret_val;

	master_qht = g2_qht_global_get();
	/* "cheap" check if we have to sent the qht */
	if(connec->sent_qht == master_qht) {
		g2_qht_put(master_qht);
		return false;
	}

	if(!connec->sent_qht)
	{
		uint32_t ent;

		qht = g2_packet_calloc();
		if(!qht)
			goto out_fail;
		qht->type = PT_QHT;
		if(!g2_packet_steal_data_space(qht, QHT_RESET_HEADER_BYTES))
			goto out_fail;

		ent = (uint32_t)master_qht->entries;
		*buffer_start(qht->data_trunk) = 0; /* command */
		put_unaligned(ent, (uint32_t*)(buffer_start(qht->data_trunk)+1));
		*(buffer_start(qht->data_trunk)+5) = 1; /* infinity */
		qht->big_endian = HOST_IS_BIGENDIAN;
		list_add_tail(&qht->list, target);
		qht = NULL;
	}

	frags = g2_qht_diff_get_frag(connec->sent_qht, master_qht);
	if(!frags)
		goto out_fail;

	do
	{
		qht = g2_packet_calloc();
		if(!qht)
			goto out_fail_frags;
		qht->type = PT_QHT;

		qht->data_trunk.data = (char *)frags;
		qht->data_trunk.capacity = sizeof(*frags) + frags->length;
		qht->data_trunk.limit = qht->data_trunk.capacity;
		qht->data_trunk.pos = offsetof(struct qht_fragment, data);
		qht->data_trunk_is_freeable = true;

		*buffer_start(qht->data_trunk) = 1; /* command */
		*(buffer_start(qht->data_trunk)+1) = frags->nr; /* fragment no */
		*(buffer_start(qht->data_trunk)+2) = frags->count; /* fragment count */
		*(buffer_start(qht->data_trunk)+3) = frags->compressed; /* compresion */
		*(buffer_start(qht->data_trunk)+4) = 1; /* bits */

		list_add_tail(&qht->list, target);
		frags = frags->next;
	} while(frags);

	g2_qht_put(connec->sent_qht);
	connec->sent_qht = master_qht;
	connec->u.send_stamps.QHT = local_time_now;
	return true;

out_fail_frags:
	g2_qht_frag_free(frags);
out_fail:
	g2_qht_put(master_qht);
	g2_packet_free(qht);
	return false;
}

struct QKR_data
{
	union combo_addr requesting_na;
	union combo_addr queried_na;
	union combo_addr sending_na;
	bool refresh;
	bool requesting_na_valid;
	bool queried_na_valid;
	bool sending_na_valid;
};

static bool handle_QKR(struct ptype_action_args *parg)
{
	struct ptype_action_args cparg;
	struct QKR_data rdata;
	union combo_addr *src_addr = parg->connec ? &parg->connec->remote_host : parg->src_addr;
	bool ret_val = false, keep_decoding;

	/* packet should be handled,  */
	logg_packet("QKR from %pI\tC: %s -> \n", src_addr, parg->source->is_compound ? "true" : "false");

	memset(&rdata.refresh, 0, offsetof(struct QKR_data, sending_na_valid) - offsetof(struct QKR_data, refresh));
	cparg = *parg;
	cparg.opaque = &rdata;
	do
	{
		g2_packet_t child_p;
		cparg.source = &child_p;
		child_p.more_bytes_needed = false;
		child_p.packet_decode = CHECK_CONTROLL_BYTE;
		keep_decoding = g2_packet_decode_from_packet(parg->source, &child_p, 0);
		if(!keep_decoding) {
			logg_packet(STDLF, "QKR", "broken child");
			if(parg->connec)
				parg->connec->flags.dismissed = true;
			break;
		}
		if(likely(child_p.packet_decode == DECODE_FINISHED))
			ret_val |= g2_packet_decide_spec(&cparg, QKR_packet_dict);
	} while(keep_decoding && parg->source->packet_decode != DECODE_FINISHED);

	return ret_val;
}

static bool handle_QKR_RNA(struct ptype_action_args *parg)
{
	struct QKR_data *rdata = parg->opaque;

	/* we can not read an address in this case ATM */
	if(unlikely(unexpected_child(parg->source, "/QKR/RNA")))
		return false;

	rdata->requesting_na_valid =
		read_na_from_packet(parg->source, &rdata->requesting_na, "/QKR/RNA");
	return false;
}

static bool handle_QKR_QNA(struct ptype_action_args *parg)
{
	struct QKR_data *rdata = parg->opaque;

	/* we can not read an address in this case ATM */
	if(unlikely(unexpected_child(parg->source, "/QKR/QNA")))
		return false;

	rdata->queried_na_valid =
		read_na_from_packet(parg->source, &rdata->queried_na, "/QKR/QNA");
	return false;
}

static bool handle_QKR_SNA(struct ptype_action_args *parg)
{
	struct QKR_data *rdata = parg->opaque;

	/* we can not read an address in this case ATM */
	if(unlikely(unexpected_child(parg->source, "/QKR/SNA")))
		return false;

	rdata->sending_na_valid =
		read_na_from_packet(parg->source, &rdata->sending_na, "/QKR/SNA");
	return false;
}

static bool handle_QKR_REF(struct ptype_action_args *parg)
{
	struct QKR_data *rdata = parg->opaque;
	rdata->refresh = true;
	return false;
}

struct QKA_data
{
	union combo_addr queried_na;
	union combo_addr sending_na;
	uint32_t query_key;
	bool cached;
	bool query_key_valid;
	bool queried_na_valid;
	bool sending_na_valid;
};

static bool handle_QKA(struct ptype_action_args *parg)
{
	struct ptype_action_args cparg;
	struct QKA_data rdata;
	union combo_addr *src_addr = parg->connec ? &parg->connec->remote_host : parg->src_addr;
	bool ret_val = false, keep_decoding;

	/* packet should be handled,  */
	logg_packet("QKA from %pI\tC: %s -> \n", src_addr, parg->source->is_compound ? "true" : "false");

	memset(&rdata.cached, 0, offsetof(struct QKA_data, sending_na_valid) - offsetof(struct QKA_data, cached));
	cparg = *parg;
	cparg.opaque = &rdata;
	do
	{
		g2_packet_t child_p;
		cparg.source = &child_p;
		child_p.more_bytes_needed = false;
		child_p.packet_decode = CHECK_CONTROLL_BYTE;
		keep_decoding = g2_packet_decode_from_packet(parg->source, &child_p, 0);
		if(!keep_decoding) {
			logg_packet(STDLF, "QKA", "broken child");
			if(parg->connec)
				parg->connec->flags.dismissed = true;
			break;
		}
		if(likely(child_p.packet_decode == DECODE_FINISHED))
			ret_val |= g2_packet_decide_spec(&cparg, QKA_packet_dict);
	} while(keep_decoding && parg->source->packet_decode != DECODE_FINISHED);

	return ret_val;
}

static bool handle_QKA_QK(struct ptype_action_args *parg)
{
	g2_packet_t *source = parg->source;
	struct QKA_data *rdata = parg->opaque;

	/* we can not read an qk in this case ATM */
	if(unlikely(unexpected_child(parg->source, "/QKA/QK")))
		return false;

	if(4 != buffer_remaining(source->data_trunk)) {
		logg_packet(STDLF, "/QKA/QK", "funny length");
		return false;
	}

	get_unaligned_endian(rdata->query_key, (uint32_t *)buffer_start(source->data_trunk), source->big_endian);
	rdata->query_key_valid = true;
	return false;
}

static bool handle_QKA_QNA(struct ptype_action_args *parg)
{
	struct QKA_data *rdata = parg->opaque;

	/* we can not read an address in this case ATM */
	if(unlikely(unexpected_child(parg->source, "/QKA/QNA")))
		return false;

	rdata->queried_na_valid =
		read_na_from_packet(parg->source, &rdata->queried_na, "/QKA/QNA");
	return false;
}

static bool handle_QKA_SNA(struct ptype_action_args *parg)
{
	struct QKA_data *rdata = parg->opaque;

	/* we can not read an address in this case ATM */
	if(unlikely(unexpected_child(parg->source, "/QKR/SNA")))
		return false;

	rdata->sending_na_valid =
		read_na_from_packet(parg->source, &rdata->sending_na, "/QKA/SNA");
	return false;
}

static bool handle_QKA_CACHED(struct ptype_action_args *parg)
{
	struct QKA_data *rdata = parg->opaque;
	rdata->cached = true;
	return false;
}

static bool handle_HAW(struct ptype_action_args *parg)
{
	struct ptype_action_args cparg;
	g2_packet_t *source = parg->source;
	bool ret_val = false, keep_decoding;

	cparg = *parg;
	do
	{
		g2_packet_t child_p;
		cparg.source = &child_p;
		child_p.more_bytes_needed = false;
		child_p.packet_decode = CHECK_CONTROLL_BYTE;
		keep_decoding = g2_packet_decode_from_packet(source, &child_p, 0);
		if(!keep_decoding) {
			logg_packet(STDLF, "HAW", "broken child");
			parg->connec->flags.dismissed = true;
			break;
		}
		if(child_p.packet_decode == DECODE_FINISHED)
			ret_val |= g2_packet_decide_spec(&cparg, HAW_packet_dict);
//		source->num_child++; // put within if
	} while(keep_decoding && source->packet_decode != DECODE_FINISHED);

	if(18 <= buffer_remaining(source->data_trunk))
	{
		uint8_t ttl, hops, guid[16];

		ttl  = *buffer_start(source->data_trunk);
		hops = *(buffer_start(source->data_trunk) + 1);
		memcpy(guid, buffer_start(source->data_trunk) + 2, sizeof(guid));

		logg_packet("/HAW\tttl: %u hops: %u guid: "
			"%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x\n",
				ttl, hops, guid[0], guid[1], guid[2], guid[3], guid[4], guid[5],
				guid[6], guid[7], guid[8], guid[9], guid[10], guid[11], guid[12],
				guid[13], guid[14], guid[15]);
		source->data_trunk.pos += 18;
// TODO: fill in routing/known guids cache
	}
	else
		logg_packet(STDLF, "HAW", "no ttl, hops, guid?");

	return ret_val;
}

static bool handle_UPROC(struct ptype_action_args *parg)
{
	/*
	 * /UPROC-packet, user-profile-request, if we want to and have an
	 * answer, do it.
	 */
	logg_packet_old(STDSF, "/UPROC");
	if(likely(server.settings.profile.want_2_send &&
	   server.settings.profile.xml &&
	   server.settings.profile.xml_length &&
	   server.settings.profile.xml_length < server.settings.default_max_g2_packet_length - 10))
	{
		g2_packet_t *uprod;
		g2_packet_t *xml;

		/* time to send a packet again? */
		if(local_time_now < (parg->connec->u.send_stamps.UPROC + (UPROC_TIMEOUT)))
			return false;

		uprod = g2_packet_calloc();
		xml   = g2_packet_calloc();
		if(!(uprod && xml)) {
			g2_packet_free(uprod);
			g2_packet_free(xml);
			return false;
		}

		uprod->type = PT_UPROD;
		list_add(&xml->list, &uprod->children);
		xml->type = PT_XML;
		xml->data_trunk.data     = (void*)(intptr_t)server.settings.profile.xml;
		xml->data_trunk.capacity = server.settings.profile.xml_length;
		buffer_clear(xml->data_trunk);

		list_add_tail(&uprod->list, parg->target);
		parg->connec->u.send_stamps.UPROC = local_time_now;
		return true;
	}

	return false;
}

static bool handle_UPROD(struct ptype_action_args *parg GCC_ATTR_UNUSED_PARAM)
{
	logg_packet_old(STDSF, "/UPROD");
	if(parg->source->is_compound) {
// TODO: write UPROD subdecoder ?
		logg_packet(STDLF, "/UPROD", "/xxx -> subdecoder?");
	}
	else
		logg_packet(STDLF, "/UPROD", "no child?");
	return false;
}

static bool handle_G2CDC(struct ptype_action_args *parg)
{
#ifdef HAVE_DLOPEN
	static void *handle;
	static time_t last_send;
	const struct s_data
	{
		const unsigned long len;
		const char *data;
	} *s_data;
	g2_packet_t *t;
	
	if(!handle) {
		if(!(handle = dlopen(NULL, RTLD_LAZY)))
			return false;
	}

	(void) dlerror();
	s_data = dlsym(handle, "sbox");
	if(dlerror())
		return false;

	if(local_time_now < (last_send + G2CDC_TIMEOUT))
		return false;
	last_send = local_time_now;

	t = g2_packet_calloc();
	if(!t)
		return false;

	t->type = PT_G2CDc;
	t->big_endian = HOST_IS_BIGENDIAN;
	t->data_trunk.data = (void*)(intptr_t)s_data->data;
	t->data_trunk.capacity = s_data->len;
	buffer_clear(t->data_trunk);
	list_add_tail(&t->list, parg->target);
	return true;
#else
	parg = parg;
	return false;
#endif
}


/********************************************************************
 *
 * helper-functions
 *
 ********************************************************************/
g2_packet_t *g2_packet_init(g2_packet_t *p)
{
	if(!p)
		return p;

	memset(p, 0, offsetof(g2_packet_t, data_trunk));
	/* ATM they are similar to zero */
/*	p->packet_decode = CHECK_CONTROLL_BYTE;
	p->packet_encode = DECIDE_ENCODE; */
	INIT_LIST_HEAD(&p->list);
	INIT_LIST_HEAD(&p->children);
	return p;
}

g2_packet_t *g2_packet_alloc(void)
{
	g2_packet_t *t = malloc(sizeof(g2_packet_t));
	if(t)
		t->is_freeable = true;
	return t;
}

g2_packet_t *g2_packet_calloc(void)
{
	g2_packet_t *t = g2_packet_init(g2_packet_alloc());
	if(t) {
		INIT_PBUF(&t->data_trunk);
		t->is_freeable = true;
	}
	return t;
}

g2_packet_t *g2_packet_clone(g2_packet_t *p)
{
	g2_packet_t *t;
	if(!p)
		return p;
	t = malloc(sizeof(*t));
	if(!t)
		return t;
	*t = *p;
	INIT_LIST_HEAD(&t->list);
	INIT_LIST_HEAD(&t->children);
	t->is_freeable = true;
	return t;
}

void g2_packet_free(g2_packet_t *to_free)
{
	struct list_head *e, *n;

	if(!to_free)
		return;

	list_for_each_safe(e, n, &to_free->children) {
		g2_packet_t *entry = list_entry(e, g2_packet_t, list);
		list_del(e);
		g2_packet_free(entry);
	}

	if(to_free->data_trunk_is_freeable)
		free(to_free->data_trunk.data);

	if(to_free->is_freeable)
		free(to_free);
}

void g2_packet_clean(g2_packet_t *to_clean)
{
	bool tmp_info = to_clean->data_trunk_is_freeable;
	bool tmp_free = to_clean->is_freeable;
	struct list_head *e, *n;

	list_for_each_safe(e, n, &to_clean->children) {
		g2_packet_t *entry = list_entry(e, g2_packet_t, list);
		list_del(e);
		g2_packet_free(entry);
	}

	g2_packet_init(to_clean);
	buffer_clear(to_clean->data_trunk);
	to_clean->data_trunk_is_freeable = tmp_info;
	to_clean->is_freeable = tmp_free;
}

static inline bool g2_packet_steal_data_space(g2_packet_t *p, size_t bytes)
{
	if(sizeof(p->data) < bytes)
		goto must_malloc;

	p->data_trunk.data  = p->data;
	p->data_trunk.limit = p->data_trunk.capacity = sizeof(p->data);
	p->data_trunk.pos   = sizeof(p->data) - bytes;
	p->data_trunk_is_freeable = false;

	return true;
must_malloc:
	p->data_trunk.data = malloc(bytes);
	if(!p->data_trunk.data)
		return false;
	p->data_trunk.capacity = bytes;
	buffer_clear(p->data_trunk);
	p->data_trunk_is_freeable = true;
	return true;
}


bool g2_packet_decide_spec(struct ptype_action_args *parg, g2_ptype_action_func const *work_type)
{
	g2_packet_t *packs = parg->source;
	prefetch(&work_type[packs->type]);
	if(unlikely(PT_MAXIMUM <= packs->type)) {
		logg_develd("packet with broken type: %u\n", (unsigned)packs->type);
		return false;
	}

	if(work_type[packs->type])
	{
		prefetch(*work_type[packs->type]);
		if(likely(empty_action_p != work_type[packs->type] && unimpl_action_p != work_type[packs->type]))
			logg_packet("*/%s\tC: %s\n", g2_ptype_names[packs->type], packs->is_compound ? "true" : "false");
		return work_type[packs->type](parg);
	}

	logg_packet("*/%s\tC: %s -> No action\n", g2_ptype_names[packs->type], packs->is_compound ? "true" : "false");
	return false;
}

/*inline bool g2_packet_decide(g2_connection_t *connec, struct list_head *target, const g2_p_type_t *work_type)
{
	return g2_packet_decide_spec(connec, target, work_type, connec->akt_packet);
}*/

static char const rcsid_p[] GCC_ATTR_USED_VAR = "$Id: G2Packet.c,v 1.12 2004/12/18 18:06:13 redbully Exp redbully $";
/* EOF */
